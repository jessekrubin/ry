<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ry(o3) docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ry(o3) docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jessekrubin/ry" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><strong>updated:</strong> <code>2025-09-22T18:16:24.982311738+00:00[Etc/UTC]</code></p>
<hr />
<h1 id="readme"><a class="header" href="#readme">README</a></h1>
<h1 id="ry"><a class="header" href="#ry">ry</a></h1>
<p>A growing collection of Python shims around Rust crates; fast, async-first, and
ergonomic.</p>
<p><a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/v/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/pyversions/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Python Version" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/wheel/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Wheel" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/dm/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Downloads" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/status/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Status" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/l/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - License" /></a></p>
<p><strong>DOCS:</strong> <a href="https://ryo3.dev">ryo3.dev</a> (WIP)</p>
<p><strong>API:</strong> <a href="https://ryo3.dev/api">ryo3.dev/api</a></p>
<p><strong>This is a work in progress ~ feedback and PRs are welcome.</strong></p>
<h2 id="highlights"><a class="header" href="#highlights">Highlights</a></h2>
<ul>
<li><strong>Async-first HTTP client:</strong> Built on <code>reqwest</code>, with a <code>fetch</code>-like API.
Supports streaming, zero-copy IO via the buffer protocol, timeouts,
redirect-following, and native JSON parsing via <code>jiter</code>.</li>
<li><strong>Async file I/O:</strong> Built on <code>tokio</code>, with an <code>AsyncFile</code> API similar to
<code>aiofiles</code> and <code>anyio</code>’s async-file api. Supports buffered reads/writes,
truncation, streaming reads, and <code>anyio</code> compatibility.</li>
<li><strong>(de)compression:</strong> (de)compression tools for <code>zstd</code>, <code>brotli</code>, <code>gzip</code>, and
<code>bzip2</code>.</li>
<li><strong>Datetime utilities via <code>jiff</code>:</strong> Fast, accurate, timezone-aware datetime
parsing and formatting, with <code>datetime</code> interop and much more</li>
<li><strong>Miscellaneous bindings:</strong> Includes crates like <code>globset</code>, <code>walkdir</code>,
<code>sqlformat</code>, <code>unindent</code>, <code>xxhash</code>, and more.</li>
<li><strong>Designed for ergonomics:</strong> Async where it matters. Simple where possible.
Python-native behavior with minimal friction.</li>
<li><strong>Type Annotated:</strong> All public APIs are (painstakingly) type annotated.</li>
<li><strong>Performant:</strong> Speed without the words “blazingly fast.” <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></li>
</ul>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-bash">pip install ry
uv add ry

# check install
python -m ry
</code></pre>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Check out the <a href="https://github.com/jessekrubin/ry/tree/main/examples">examples</a>
directory for some quickstart examples.</p>
<hr />
<h2 id="what"><a class="header" href="#what">What?</a></h2>
<ul>
<li><code>ry</code> – the python package</li>
<li><code>ryo3-*</code> – the rust crates that are used by <code>ry</code> and possibly your own
<code>pyo3</code>-based python package</li>
</ul>
<h2 id="who"><a class="header" href="#who">Who?</a></h2>
<ul>
<li>jessekrubin <a href="mailto:jessekrubin@gmail.com">jessekrubin@gmail.com</a></li>
<li>possibly you!?</li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><em>(aka: questions that I have been asking myself)</em></p>
<ul>
<li><strong>Q:</strong> Why?
<ul>
<li><strong>A:</strong> I (jesse) needed several hashing functions for python and then kept
adding things as I needed them</li>
</ul>
</li>
<li><strong>Q:</strong> Does this have anything to do with the (excellent) package manager
<code>rye</code>?
<ul>
<li><strong>A:</strong> short answer: no. long answer: no, it does not.</li>
</ul>
</li>
<li><strong>Q:</strong> Why is the repo split into <code>ry</code> and <code>ryo3</code>?
<ul>
<li><strong>A:</strong> <code>ry</code> is the python package, <code>ryo3</code> is a rust crate setup to let you
“register” functions you may want if you were writing your own pyo3-python
bindings library; maybe someday the <code>ryo3::libs</code> module will be split up
into separate packages</li>
</ul>
</li>
</ul>
<h2 id="crate-bindings"><a class="header" href="#crate-bindings">Crate bindings</a></h2>
<ul>
<li>wrapped crates:
<ul>
<li><code>std</code> - many stdlib types and apis</li>
<li><code>bytes</code></li>
<li><code>dirs</code></li>
<li><code>glob</code></li>
<li><code>heck</code></li>
<li><code>http</code></li>
<li><code>jiter</code></li>
<li><code>reqwest</code></li>
<li><code>shlex</code></li>
<li><code>size</code></li>
<li><code>sqlformat</code></li>
<li><code>tokio</code> (<code>fs</code> and <code>process</code>)</li>
<li><code>unindent</code></li>
<li><code>url</code></li>
<li><code>uuid</code></li>
<li><code>which</code></li>
<li>compression:
<ul>
<li><code>brotli</code></li>
<li><code>bzip2</code></li>
<li><code>flate2</code></li>
<li><code>zstd</code></li>
</ul>
</li>
<li>hashing:
<ul>
<li><code>fnv</code></li>
<li><code>xxhash</code></li>
</ul>
</li>
<li>burnt-sushi:
<ul>
<li><code>globset</code> (formerly <a href="https://pypi.org/project/globsters/">globsters</a>)</li>
<li><code>jiff</code></li>
<li><code>memchr</code></li>
<li><code>regex</code> (WIP ~ very incomplete)</li>
<li><code>same-file</code></li>
<li><code>walkdir</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="dev"><a class="header" href="#dev">DEV</a></h2>
<ul>
<li><code>just</code> is used to run tasks</li>
<li>Do not use the phrase <code>blazing fast</code> or any emojis in any PRs or issues or
docs</li>
<li>type annotations are required</li>
<li><code>ruff</code> used for formatting and linting</li>
</ul>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<ul>
<li>utiles (web-map tile utils): https://github.com/jessekrubin/utiles</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Release‑version benchmarks of <code>ry</code> (via <code>pytest-benchmark</code>) showed no real
performance variance, regardless of whether “blazingly fast” appeared in the
README or docs. <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">DEVELOPMENT</a></h1>
<p><strong>OPEN TO PRS!</strong></p>
<h2 id="goals"><a class="header" href="#goals">goals</a></h2>
<ol>
<li>Provide a really nice ergonomic API to work with (this is the highest
priority)</li>
<li>Get naming right (this is a hard one!)</li>
<li>Be fast</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">development-setup</a></h2>
<ul>
<li>clone repo</li>
<li>install <code>just</code> (<code>cargo install just</code>)</li>
<li>create a virtual env (using ye olde <code>venv</code> or <code>uv</code> or dare I say <code>conda</code>) – I
am still working out the kinks of using <code>uv</code> with maturin</li>
<li>install the dev-requirements (<code>pip install -r requirements.dev.txt</code>)</li>
<li>run <code>just dev</code> to build and test the library</li>
<li>run <code>just fmt</code> to format the python and rust code</li>
</ul>
<h2 id="style-guide"><a class="header" href="#style-guide">style guide</a></h2>
<ul>
<li><strong>NO UNWRAPPING</strong> – use <code>expect</code> over <code>unwrap</code></li>
<li><strong>NO PANICS</strong> – don’t panic!</li>
<li><strong>NO <code>blazingly-fast</code></strong> – <code>ry</code> is fast and does not need an adverb</li>
<li><strong>USE CLIPPY</strong> <code>just clippy</code> or <code>just ci</code></li>
<li><strong>USE RUSTFMT AND RUFF</strong> <code>just fmt</code></li>
<li>avoid using macros as they are not as easy to reason about and/or debug, but
feel free to say ‘yolo’</li>
<li>library style guide:
<ul>
<li>python objects/structs/classes defined in the library should be named either
<code>Py&lt;CLASSNAME&gt;</code> or <code>Ry&lt;CLASSNAME&gt;</code> and the prefix should be consistent
throughout the library (eg <code>ryo3-jiff</code> uses <code>Ry</code> as the internal prefix to
not conflict with the <code>Py&lt;CLASSNAME&gt;</code> structs provided by <code>pyo3</code>)</li>
<li>if a <code>pyclass</code> or <code>pyfunction</code> is not mirroring a rust function prefer names
that are puns but also semi-descriptive (eg <code>Globsters</code> in <code>ryo3-globset</code>)</li>
<li>attempt to mirror the structure of the og library as much as possible</li>
<li>wrapper libraries should be of the form <code>ryo3-&lt;LIB_NAME&gt;</code> where <code>&lt;LIB_NAME&gt;</code>
is the name of the library they</li>
<li>library directories should be <code>kebab-case</code> and should be <code>ryo3-&lt;LIB_NAME&gt;</code></li>
<li>MUST PROVIDE TYPE ANNOTATIONS</li>
</ul>
</li>
</ul>
<h2 id="creating-a-new-librarywrapper-thing"><a class="header" href="#creating-a-new-librarywrapper-thing">Creating a new library/wrapper-thing</a></h2>
<ul>
<li>copy the template library <code>ryo3-quick-maths</code> library to your new library name</li>
<li>refer to the above style guide for naming conventions</li>
</ul>
<hr />
<h2 id="tools"><a class="header" href="#tools">tools</a></h2>
<h3 id="python"><a class="header" href="#python">python</a></h3>
<ul>
<li>we use <code>maturin</code> for building the python wheels</li>
<li>we support <code>python-3.9+</code></li>
<li>we use <code>pytest</code> for testing as well as the following plugins:
<ul>
<li><code>pytest-benchmark</code></li>
<li><code>pytest-asyncio</code> (may switch to <code>anyio</code> in the future)</li>
<li><code>hypothesis</code></li>
</ul>
</li>
</ul>
<h3 id="just"><a class="header" href="#just">just</a></h3>
<p><strong><code>cargo install just</code></strong></p>
<ul>
<li>we use <code>just</code> for task running</li>
<li>to see all tasks run <code>just</code> or <code>just --list</code> (our default task echos the list
of tasks)</li>
</ul>
<p>tasks as of 2024-12-03:</p>
<pre><code class="language-txt">Available recipes:
    dev            # dev run build + tests
    develop        # maturin develop
    cargo-test     # cargo test
    build          # build
    build-release  # build release
    dev-rel        # maturin develop release
    pytest         # run pytest
    pytestv        # run pytest (printing captured output)
    test           # run all test
    test-release   # test ry package
    bench          # benchmark ry python package
    ci             # ci rust checks
    cargo-fmt      # cargo format
    cargo-fmtc     # cargo format check
    sort-all-check # ruff check sorting of '__all__'
    sort-all       # ruff sort '__all__'
    ruff-fmt       # ruff format
    ruff-fmtc      # ruff format check
    black          # python format black
    fmtpy          # python format
    fmtcpy         # python format check
    justfilefmt    # justfile format
    justfilefmtc   # justfile format check
    fmt            # format
    fmtc           # format check
    ruff           # run ruff linter
    ruffix         # run ruff + fix
    clippy         # run clippy
    lint           # lint python and rust
    mypy           # run mypy type checker
    pyright        # run pyright
    pip-compile    # pip compile requirements
    gen            # generate code tasks
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>This project would not be possible without the incredible work of many others.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">THANK YOU</a></h2>
<ul>
<li>pyo3 developers</li>
<li>all authors of all libraries used in this project!</li>
<li>burnt-sushi for the incredible set of libraries</li>
<li>Kyle Barron for working on <code>pyo3-bytes</code> and letting me contribute to it</li>
<li>The academy and the hollywood foreign press</li>
</ul>
<hr />
<p>If you want to be added to this list, please open an issue or PR! Happy to add
you if you’ve helped in any way!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ry-dist-archives"><a class="header" href="#ry-dist-archives">ry-dist-archives</a></h1>
<p><strong>TLDR: If you are using an older version of <code>ry</code> and it is not longer on PyPI,
you can find it either on primary ry-repo’s
<a href="https://github.com/jessekrubin/ry/releases">releases</a> page, or in the
<a href="https://github.com/jessekrubin/ry-dist-archives">ry-dist-archives</a>
repository.</strong></p>
<p>PyPI imposes a 10 GB limit on the total size of all files in a given project.
Once that limit is reached, you must either delete old files or request a size
increase. As of now (<code>2025-07-22T08:34:51.3412157-07:00[America/Los_Angeles]</code>),
the <code>ry</code> package is still very much in beta, and I (jesse) am not going to
request a size increase while the project remains pre-<code>0.1.0</code>.</p>
<p><code>ry</code> builds are performed with github cicd, and published builds for versions
<code>0.44.0</code> are uploaded to github
<a href="https://github.com/jessekrubin/ry/releases">releases</a>, <strong>but</strong> publishing
releases was not previously a part of the cicd workflow.</p>
<p>The script for downloading wheels is located at
<a href="https://github.com/jessekrubin/ry-dist-archives/blob/main/scripts/dl_versions.py">ry-dist-archives/scripts/dl_versions.py</a>.
It serves as a good example of how to use <code>ry</code>’s HTTP client, JSON parsing and
dumping, and async file I/O tools.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">CHANGELOG</a></h1>
<h2 id="v0059-unreleased"><a class="header" href="#v0059-unreleased">v0.0.59 [unreleased]</a></h2>
<ul>
<li><code>ryo3-sqlformat</code>
<ul>
<li>Updated to version 0.4.0 of <code>sqlformat</code> crate</li>
<li>Added sqlformat version 0.4.0 new options:
<ul>
<li><code>ignore_case_convert: list[str] | None = None</code></li>
<li><code>inline: bool = False</code></li>
<li><code>max_inline_block: int = 50</code></li>
<li><code>max_inline_arguments: int | None = None</code></li>
<li><code>max_inline_top_level: int | None = None</code></li>
<li><code>joins_as_top_level: bool = False</code></li>
</ul>
</li>
<li>Changed <code>indent</code> arg/kwarg to accept either:
<ul>
<li><code>int</code> (positive integer for number of spaces)</li>
<li><code>str</code> (“tabs”, “\t” or “spaces”)</li>
</ul>
</li>
<li>Changed <code>uppercase</code> arg/kwarg to default to <code>False</code> instead of <code>True</code> to be
more inline with the default behaviour of <code>sqlformat</code> crate</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0058-2025-09-18"><a class="header" href="#v0058-2025-09-18">v0.0.58 [2025-09-18]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>added <code>.__format__()</code> methods to several jiff structs to allow custom
f-string formatting</li>
<li>Fixed <code>SignedDuration.__truediv__</code> operator</li>
</ul>
</li>
<li>internal
<ul>
<li>migrated all <code>downcast*</code> usages to <code>cast*</code></li>
</ul>
</li>
<li>Min python version for ry is now 3.11+</li>
</ul>
<hr />
<h2 id="v0057-2025-09-12"><a class="header" href="#v0057-2025-09-12">v0.0.57 [2025-09-12]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>Added <code>TimeRound</code> python struct</li>
<li>Fixed types for all <code>*Round</code> operations limiting max “smallest” arg literal
types.</li>
<li>Round-api changes
<ul>
<li>builder-y functions and getter functions have been flip-flopped:
<ul>
<li>Switched “builder”-y apis to start with prefix for all <code>*Round</code> structs:
<ul>
<li><code>increment(n: int) -&gt; Self</code> -&gt; <code>_increment(n: int) -&gt; Self</code></li>
<li><code>mode(m: str) -&gt; Self</code> -&gt; <code>_mode(m: str) -&gt; Self</code></li>
<li><code>smallest(unit: str) -&gt; Self</code> -&gt; <code>_smallest(unit: str) -&gt; Self</code></li>
</ul>
</li>
<li>Switched all getter functions to be properties:
<ul>
<li><code>round_obj._increment() -&gt; int</code> -&gt; <code>round_obj.increment -&gt; int</code></li>
<li><code>round_obj._mode() -&gt; str</code> -&gt; <code>round_obj.mode -&gt; str</code></li>
<li><code>round_obj._smallest() -&gt; str</code> -&gt; <code>round_obj.smallest -&gt; str</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>to_dict()</code>
<ul>
<li><code>.asdict()</code> renamed to <code>.to_dict()</code> all structs</li>
<li>renames structs:
<ul>
<li><code>ry.DateTime.asdict()</code> -&gt; <code>ry.DateTime.to_dict()</code></li>
<li><code>ry.Date.asdict()</code> -&gt; <code>ry.Date.to_dict()</code></li>
<li><code>ry.TimeSpan.asdict()</code> -&gt; <code>ry.TimeSpan.to_dict()</code></li>
<li><code>ry.Time.asdict()</code> -&gt; <code>ry.Time.to_dict()</code></li>
<li><code>ry.Headers.asdict()</code> -&gt; <code>ry.Headers.to_dict()</code></li>
</ul>
</li>
<li>Added <code>.to_dict()</code> to:</li>
</ul>
</li>
<li>migrated from <code>xxhash-rust</code> to <code>twox-hash</code> ~ retiring <code>ryo3-xxhash</code> :( - the
<code>xxhash-rust</code> hashers liked to sometimes crash, whereas the <code>twox-hash</code>
py-hashers dont</li>
</ul>
<hr />
<h2 id="v0056-2025-09-05"><a class="header" href="#v0056-2025-09-05">v0.0.56 [2025-09-05]</a></h2>
<ul>
<li><code>ryo3-serde</code>
<ul>
<li>refactoring and testing recursion and stitch</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>Fix: python open mode parsing for <code>aiopen</code> function</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>Add <code>jiter</code> parsing options to <code>Response.json()</code></li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>use <code>#[pyo3(warn(...))]</code> for deprecation warnings instead of doing it
manually</li>
<li>fixed utc methods to use <code>.with_time_zone(TimeZone::UTC)</code> instead of
<code>.in_tz("UTC")</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0055-2025-09-03"><a class="header" href="#v0055-2025-09-03">v0.0.55 [2025-09-03]</a></h2>
<ul>
<li>upgrade pyo3 v0.26.x</li>
<li><code>ryo3-bytes</code>
<ul>
<li>Update buffer usage based on kyle barron <code>pyo3-bytes</code>
<a href="https://github.com/developmentseed/obstore/commit/2ca22a8c3949ae51fbf750ef5a08e3a76f583819">changes</a></li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>Make each sub-module a feature flag <code>std-net</code>, <code>std-fs</code>, <code>std-time</code>, etc…</li>
</ul>
</li>
<li>internal changes
<ul>
<li>Implemented <code>Display</code> for several types for use in their <code>__repr__</code> methods</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0054-2025-08-28"><a class="header" href="#v0054-2025-08-28">v0.0.54 [2025-08-28]</a></h2>
<ul>
<li><code>ryo3-std</code>
<ul>
<li>Serialization for std types</li>
<li>Speed run of socketaddr types (WIP); needs more testing and the socket types
could be cleaner…</li>
</ul>
</li>
<li><code>ryo3-memchr</code>
<ul>
<li>Basic functionality for <code>memchr</code> and <code>memrchr</code> operations</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Changed <code>human</code> arg/kwarg in <code>ry.TimeSpan</code> and <code>ry.SignedDuration</code> to
<code>friendly</code> and also make keyword only</li>
<li>Changed <code>strptime</code> and <code>strftime</code> functions to be more inline with python’s
<code>datetime</code> module by changing the order of args to be <code>(string, format)</code>
instead of <code>(format, string)</code>; the strptime signature is
<code>strptime(s: str, /, fmt: str) -&gt; Self</code></li>
<li>Added to <code>ry.TimeSpan</code> and <code>ry.SignedDuration</code> the <code>friendly</code> method for
more natural string representations</li>
<li>Many internal refactors and cleanup</li>
<li>Converted all <code>__repr__</code> methods to use struct <code>Display</code> impls</li>
<li>Fixed rounding object repr function(s) and added pickling and tests for
round objects</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>Missing <code>lstrip</code>/<code>rstrip</code> method types for <code>ry.Bytes</code></li>
<li>Updated types for <code>ry.TimeSpan</code> and <code>ry.SignedDuration</code> w/ correct
<code>friendly</code> kwarg and <code>friendly()</code> methods</li>
</ul>
</li>
<li>Added ruff <code>A002</code> lint</li>
<li>Added ruff <code>FBT</code> lints</li>
</ul>
<hr />
<h2 id="v0053-2025-08-18"><a class="header" href="#v0053-2025-08-18">v0.0.53 [2025-08-18]</a></h2>
<ul>
<li><code>ry</code>
<ul>
<li>Bump min python version 3.10 – this is a breaking change, but ry is still
very much a WIP/in-beta, so the versioning schema is “yolo-versioning”</li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>internal refactoring and cleanup</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0052-2025-07-30"><a class="header" href="#v0052-2025-07-30">v0.0.52 [2025-07-30]</a></h2>
<ul>
<li><code>ryo3-bytes</code>
<ul>
<li>internal refactoring</li>
<li>added
<ul>
<li><code>ry.Bytes.__rmul__</code></li>
<li><code>ry.Bytes.lstrip</code></li>
<li><code>ry.Bytes.rstrip</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-xxhash</code>
<ul>
<li>all xxhash-ing classes are now <code>frozen</code> pyclasses
<a href="https://github.com/jessekrubin/ry/issues/259">#259</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0051-2025-07-25"><a class="header" href="#v0051-2025-07-25">v0.0.51 [2025-07-25]</a></h2>
<ul>
<li><code>ryo3-bytes</code>
<ul>
<li>Separated <code>pyo3-bytes</code> and <code>ryo3-bytes</code>
<ul>
<li><code>pyo3-bytes</code> mirrors the official <code>pyo3-bytes</code> crate + extra methods, BUT
it requires the <code>multiple-pymethods</code> feature to be enabled</li>
<li><code>ryo3-bytes</code> is a crammed together version of the <code>pyo3-bytes</code>
implementation and extra methods and does NOT require the
<code>multiple-pymethods</code> feature to be enabled</li>
</ul>
</li>
<li>Made <code>PythonBytesMethods</code> trait for the methods that are shared between
<code>pyo3-bytes</code> and <code>ryo3-bytes</code></li>
</ul>
</li>
<li><code>ryo3-ulid</code>
<ul>
<li>strict + lax ulid parsing for pydantic</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Renamed <code>checked_add</code> and <code>checked_sub</code> to <code>add</code> and <code>sub</code> where the
checked_version can error; did not remove where the checked version returns
an <code>Option</code> type (<code>ry.SignedDuration</code>). <code>.checked_add</code> may return later as a
method that returns an <code>Option</code> type for all types (tbd). This is also meant
to pave the way for <code>add</code>/<code>sub</code> functions with a more familiar api akin to
<code>whenever</code>, <code>pendulum</code>, <code>arrow</code>, <code>insert-other-datetime-lib-here</code></li>
<li>Added <code>replace</code> methods to <code>Date</code>, <code>DateTime</code> and <code>Time</code> structs that use
the underlying jiff <code>with</code> functions</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0050-2025-07-14"><a class="header" href="#v0050-2025-07-14">v0.0.50 [2025-07-14]</a></h2>
<ul>
<li>internal
<ul>
<li>clippy lint fixes <code>unused_self</code> (all but <code>ryo3-bytes</code> which needs its own
cleanup)</li>
</ul>
</li>
<li><code>ryo3-bytes</code>
<ul>
<li>Added (bc I need them) more python compat methods:
<ul>
<li><code>title()</code></li>
<li><code>swapcase()</code></li>
<li><code>expandtabs()</code></li>
<li><code>strip()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>Added <code>open</code> method that forwards to <code>open</code> method of <code>pathlib.Path</code></li>
<li>Added <code>mkdir</code> method that mimics <code>mkdir</code> method of <code>pathlib.Path</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0049-2025-07-04-fourth-o-july"><a class="header" href="#v0049-2025-07-04-fourth-o-july">v0.0.49 [2025-07-04] (fourth o july)</a></h2>
<ul>
<li>workspace
<ul>
<li>set rust edition to 2024</li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>Fixed recursive serialization w/ max depth of 255 (aligning with <code>orjson</code>)</li>
<li>support <code>PyEllipsis</code> for <code>None</code> values in serialization</li>
</ul>
</li>
<li><code>ryo3-json</code>
<ul>
<li><code>minify</code> function to remove whitespace/newlines from json-string/bytes</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>internal refactoring</li>
<li><code>isoformat</code> methods aligned with python’s <code>datetime</code> library methods</li>
<li>Freeze (make pyclass frozen) for all jiff types (changed <code>*Series</code>
iterables)</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li><code>which</code> feature allowing <code>FsPath.which</code> and <code>FsPath.which_all</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0048-2025-06-24"><a class="header" href="#v0048-2025-06-24">v0.0.48 [2025-06-24]</a></h2>
<ul>
<li><code>ryo3-json</code>
<ul>
<li><code>pybytes</code> bool kwargs to return <code>builtins.bytes</code> if <code>True</code> and <code>ry.Bytes</code> if
<code>False</code>; default is <code>False</code></li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>support for types defined in <code>ryo3-http</code></li>
<li>support for <code>default</code> kwarg that is passed to the serde serializer; like w/
the stdlib-json and orjson serializers, this allows for serializing types
that are not natively supported by ry/serde and if failure should occur, it
should raise a <code>TypeError</code> or <code>ValueError</code> instead of returning <code>None</code> by
default</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>json</code> kwarg added to request builders that auto-serializes via
<code>ryo3-serde</code>; also because it uses the <code>reqwest::RequestBuilder</code> it auto
sets the <code>Content-Type</code> header to <code>application/json</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0047-2025-06-17"><a class="header" href="#v0047-2025-06-17">v0.0.47 [2025-06-17]</a></h2>
<ul>
<li>pyo3 v0.25.1</li>
<li><code>ryo3-serde</code> (wip)
<ul>
<li>serializers for <code>PyAny</code> and more</li>
<li>this should theoretically allow for serializing any python object that is
<code>serde</code> serializable with almost any <code>serde</code> serializer… that is the goal</li>
</ul>
</li>
<li><code>ryo3-json</code>
<ul>
<li>Where json stuff + ry is going to live in the near future (may consolidate
<code>ryo3-jiter</code> into this newer crate)</li>
<li><code>ry.stringify()</code> uses <code>ryo3-serde</code> + <code>serde_json</code> to write json bytes/bufs
and it is pretty fast, faster than ujson and rapidjson (not tested yyjson),
BUT orjson is still fastest (read a bunch of their code and it is remarkably
advanced and optimized)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0046-2025-06-06"><a class="header" href="#v0046-2025-06-06">v0.0.46 [2025-06-06]</a></h2>
<ul>
<li>version 0.0.46</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>ResponseStream</code>
<ul>
<li>Added <code>__repr__</code> method</li>
<li>Added <code>async def take(self, n: int=1): ...</code> method returns n chunks as a
list</li>
<li>Added <code>async def collect(self: join = False) -&gt; ...:</code> method that collects
the stream into a single <code>ry.Bytes</code> object if <code>join=True</code> or a list of
<code>ry.Bytes</code> objects if <code>join=False</code></li>
<li>Added <code>async def take(self, n: int=1): ...</code> which returns n chunks as a
list</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>add <code>dtype</code> kwarg that takes either <code>dtype=str | ry.FsPath | pathlib.Path</code>
as type of obj yielded by the iterable; something about this feels really
icky, the default may be changed to <code>str</code> (from <code>pathlib.Path</code>)</li>
</ul>
</li>
<li><code>ryo3-ulid</code>
<ul>
<li>Added mostly as a way to test how much pydantic + ry integration would be</li>
</ul>
</li>
<li><code>ryo3-which</code>
<ul>
<li>upgrade which to version 8</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0045-2025-05-30"><a class="header" href="#v0045-2025-05-30">v0.0.45 [2025-05-30]</a></h2>
<ul>
<li>added <code>__target__</code> to python package metadata in <code>ry.__about__</code> with the
target triple of the current build</li>
<li><code>ryo3-std</code>
<ul>
<li>Buffering for <code>FileReadStream</code></li>
</ul>
</li>
<li><code>ryo3-jiter</code>
<ul>
<li>Add function <code>parse_jsonl</code> for parsing json lines</li>
<li>Add <code>lines</code> kwarg to <code>read_json</code> for parsing/reading json lines</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>
<p><code>ZonedDateTime.__new__</code> takes more python-datetime like args/kwargs, old
version of constructor moved to classmethod
<code>ZonedDateTime.from_parts(timestamp: ry.Timestamp, tz: ry.TimeZone) -&gt; ZonedDateTime</code></p>
</li>
<li>
<p><code>zoned</code> top level function</p>
<ul>
<li>if <code>tz</code> is <code>None</code> then it uses the system timezone</li>
<li>SIGNATURE</li>
</ul>
<pre><code class="language-python">def zoned(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
    tz: str | None = None,
) -&gt; ZonedDateTime: ...
</code></pre>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0044-2025-05-23"><a class="header" href="#v0044-2025-05-23">v0.0.44 [2025-05-23]</a></h2>
<ul>
<li>internal:
<ul>
<li>renamed <code>ryo3-macros</code> to <code>ryo3-macro-rules</code></li>
</ul>
</li>
<li>docs
<ul>
<li>Cleaned up <code>./README.md</code></li>
<li>Removed type-annotations from <code>./README.md</code></li>
</ul>
</li>
<li>pyo3-v0.25.0</li>
<li>py-types
<ul>
<li>reqwest-request functions use <code>TypedDict</code> and <code>Unpack</code></li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>serde serialization features/support</li>
<li><code>ry.ZonedDateTime.replace</code> method mirroring <code>ZonedWith</code> – <code>with</code> is a
python keyword, so used <code>replace</code> instead</li>
<li>example script based on jiff-docs examples</li>
<li><code>test_jiff_examples_v2.py</code> test script (basis for example script)
<ul>
<li>Was tired/fried so I copy-pasta-ed the <code>ry/ryo3/_jiff.pyi</code> type
annotations, the jiff-v2-docs-examples, and the jiff-v1-hand-translated
<code>test_jiff_examples_v1.py</code> file into Chad-Gippity who was able to do most
of the translation from <code>rust</code> to <code>ry</code>…</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-xxhash</code>
<ul>
<li>Align with <code>xxhash</code> pypi library w/ respect to naming conventions</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0043-2025-05-17"><a class="header" href="#v0043-2025-05-17">v0.0.43 [2025-05-17]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>panic-able functions to create new/altered (time)spans moved to use <code>try_*</code></li>
</ul>
</li>
<li>fix: anyio marker flat issue in pytests for cicd</li>
<li><code>ryo3-uuid</code>
<ul>
<li>added <code>uuid</code> wrapper for <code>uuid</code> crate; ty to the maintainers of <code>uuid-utils</code>
and <code>fastuuid</code> for helping figure out some of the nitty gritty bits and bobs</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>AsyncFile</code> and <code>aiopen</code> experiment(s) added for async file reading/writing
etc</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0042-2025-05-12"><a class="header" href="#v0042-2025-05-12">v0.0.42 [2025-05-12]</a></h2>
<ul>
<li>panic=abort
<ul>
<li>panic is now (maybe will go back) <code>abort</code> for release builds</li>
<li>means smaller binaries and faster error handling (in theory)</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>more type fixes to response</li>
<li>Got response type more inline with other python http-client libraries</li>
<li>try <code>parking_lot</code> for default <code>reqwest</code> client mutex</li>
<li>include missing kwargs for fetch functions</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>freeze struct(s) to be frozen</li>
</ul>
</li>
<li><code>ryo3-http</code>
<ul>
<li>http version python conversions to/from string/int</li>
<li>crude-ish serde implementation for <code>HeadersMap</code> for json
encoding/decoding… was a lot of googling</li>
<li>status code reason(s) interned</li>
<li>intern all standard http header-names</li>
</ul>
</li>
<li><code>ryo3-fnv</code>
<ul>
<li>align with hashlib style hashing</li>
</ul>
</li>
<li>deps-up
<ul>
<li>pyo3 version 0.24.2</li>
<li>brotli 8</li>
<li>jiff patch</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0041-2025-04-18"><a class="header" href="#v0041-2025-04-18">v0.0.41 [2025-04-18]</a></h2>
<ul>
<li><code>ryo3-jiter</code>
<ul>
<li>added <code>read_json</code> function to read from path-like obj</li>
</ul>
</li>
<li><code>ryo3-bytes</code>
<ul>
<li>misc small improvements and tests</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>ry.IpAddr</code> added to handle both ipv4/ipv6</li>
<li><code>ry.read_dir</code> implemented</li>
</ul>
</li>
<li><code>ryo3-walkdir</code>
<ul>
<li>added <code>objects</code> impl and example script</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>ry.read_dir_async</code> implemented; also contains fancy async take/collect</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0040-2025-04-11"><a class="header" href="#v0040-2025-04-11">v0.0.40 [2025-04-11]</a></h2>
<ul>
<li>scripts
<ul>
<li><code>dl_versions.py</code> script to download all versions of ry while ry is still
pre-1-point-oh and old version(s) are being nuked from pypi as needed</li>
</ul>
</li>
<li>types
<ul>
<li>fix types for few packages</li>
</ul>
</li>
<li>Updated several dependencies ~ most notably <code>pyo3</code> to <code>0.24.1</code></li>
<li>Fixed several new clippy lints that appear in CI stable rust builds</li>
<li><code>ryo3-std</code>
<ul>
<li><code>std::net</code> ipv4/ipv6 wrappers speed run impl</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0039-2025-03-14"><a class="header" href="#v0039-2025-03-14">v0.0.39 [2025-03-14]</a></h2>
<ul>
<li>internal
<ul>
<li>cleaned up several dependencies and features</li>
</ul>
</li>
<li><code>ryo3-zstd</code>
<ul>
<li>actually changed to use py buffer protocol this time… I dont know how it
got missed before…</li>
<li>re-factored a decent bit and made submodule with future plans to expand
encoding/decoding dictionary support</li>
<li>submodule is <code>ry.zstd</code> and/or <code>ry.ryo3.zstd</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0038-2025-03-13"><a class="header" href="#v0038-2025-03-13">v0.0.38 [2025-03-13]</a></h2>
<ul>
<li><code>ryo3-reqwest</code>
<ul>
<li>client configuration for pickling</li>
<li>allow buffer-protocol for <code>body</code> fetching methods (should add string maybe?)</li>
</ul>
</li>
<li><code>ryo3-walkdir</code>
<ul>
<li>Few more options added</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>new wrapper around <code>glob</code> crate</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Switched to use conversions from <code>jiff</code> feature of <code>pyo3-v24</code> as opposed to
hand-rolled conversions we had before</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0037-2025-03-11"><a class="header" href="#v0037-2025-03-11">v0.0.37 [2025-03-11]</a></h2>
<ul>
<li>pyo3 version <code>0.24.0</code></li>
<li><code>ryo3-which</code> functions return <code>pathlib.Path</code> now due to changes in pyo3-v24;
this may change in the near future…</li>
</ul>
<hr />
<h2 id="v0036-2025-03-11"><a class="header" href="#v0036-2025-03-11">v0.0.36 [2025-03-11]</a></h2>
<ul>
<li>dependencies updated</li>
<li>pickling support and tests for several types</li>
<li>bytes/buffer-protocol support for several sub-packages/packages:
<ul>
<li><code>ryo3-brotli</code></li>
<li><code>ryo3-bzip2</code></li>
<li><code>ryo3-flate2</code></li>
<li><code>ryo3-fnv</code></li>
<li><code>ryo3-xxhash</code></li>
<li><code>ryo3-zstd</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0035-2025-03-06"><a class="header" href="#v0035-2025-03-06">v0.0.35 [2025-03-06]</a></h2>
<ul>
<li>internal
<ul>
<li>types split up and cleaned up</li>
</ul>
</li>
<li><code>ryo3-size</code>
<ul>
<li><code>ry.Size</code> object</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li><code>series</code> iterators have <code>take</code> function that takes a <code>usize</code> returns a list
of size <code>usize</code></li>
<li>updated series types to be <code>JiffSeries</code> class</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0034-2025-02-28"><a class="header" href="#v0034-2025-02-28">v0.0.34 [2025-02-28]</a></h2>
<ul>
<li><code>ryo3-std</code>
<ul>
<li><code>fs</code>:
<ul>
<li><code>read_stream</code> function that returns an iterator of <code>ry.Bytes</code> objects from
a <code>PathLike</code> object</li>
<li>Several more fs functions added</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>Several more tokio fs functions added</li>
</ul>
</li>
<li>internal
<ul>
<li>reorganized type annotations to be not a HUGE file…</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0033-2025-02-26"><a class="header" href="#v0033-2025-02-26">v0.0.33 [2025-02-26]</a></h2>
<ul>
<li>update to pyo3 v0.23.5</li>
</ul>
<hr />
<h2 id="v0032-2025-02-25"><a class="header" href="#v0032-2025-02-25">v0.0.32 [2025-02-25]</a></h2>
<ul>
<li><code>ryo3-jiter</code>
<ul>
<li>Allow <code>PyBytes</code> wrapper/buffer protocol to be given</li>
<li>renamed <code>jiter_cache_clear</code> to <code>json_cache_clear</code> and <code>jiter_cache_usage</code> to
<code>json_cache_usage</code></li>
<li>Removed <code>parse_json_str</code> just use <code>parse_json</code> with <code>str</code> input</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>Allow read/write to take <code>ry.Bytes</code> or <code>Bytes</code> objects</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0031-2025-02-21"><a class="header" href="#v0031-2025-02-21">v0.0.31 [2025-02-21]</a></h2>
<ul>
<li><code>ryo3-core</code>
<ul>
<li>got rid of <code>ryo3-types</code> and moved into <code>ryo3-core</code></li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>read_async</code> and <code>write_async</code> async functions</li>
</ul>
</li>
<li><code>ryo3-which</code>
<ul>
<li><code>which_re</code> functions accepts <code>ry.Regex</code> or <code>str</code> now</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>read</code> and <code>write</code> functions which take/return <code>ry.Bytes</code> objects</li>
</ul>
</li>
<li><code>internal</code>
<ul>
<li>Changed many many many of the structs/classes to be pyo3 <code>frozen</code> behaviour
should not be different</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0030-2025-02-18"><a class="header" href="#v0030-2025-02-18">v0.0.30 [2025-02-18]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Upgraded jiff to version 2</li>
</ul>
</li>
<li>internal
<ul>
<li>Switch all lints from <code>#[allow(...)]</code>/<code>#![allow(...)]</code> to
<code>#[expect(...)]</code>/<code>#![expect(...)]</code></li>
<li>Removed a bunch o commented out code</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>added several <code>std::fs</code> structs</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>conversion to <code>pathlib.Path</code> by way of <code>FsPath.to_pathlib()</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0029-2025-02-03"><a class="header" href="#v0029-2025-02-03">v0.0.29 [2025-02-03]</a></h2>
<ul>
<li>internal
<ul>
<li>Made sure each <code>ryo3-*</code> crate has a <code>README.md</code></li>
</ul>
</li>
<li><code>ryo3-bytes</code> &amp; <code>ryo3-fspath</code>
<ul>
<li>added <code>__hash__</code> dunders to both <code>Bytes</code> and <code>FsPath</code> structs</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0028-2025-01-31"><a class="header" href="#v0028-2025-01-31">v0.0.28 [2025-01-31]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Per Mr. Sushi’s thoughts changed all <code>until</code>/<code>since</code> methods to use kwargs
instead of the rust-like tuples that impl <code>From</code>/<code>Into</code> as it does not
translate well to python</li>
<li>Gets rid of the following inane types:</li>
</ul>
</li>
</ul>
<pre><code class="language-python">IntoDateDifference = (
    DateDifference
    | Date
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimeDifference = (
    TimeDifference
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoDateTimeDifference = (
    DateTimeDifference
    | Date
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimestampDifference = (
    TimestampDifference
    | Timestamp
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Timestamp]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
</code></pre>
<hr />
<h2 id="v0027-2025-01-23"><a class="header" href="#v0027-2025-01-23">v0.0.27 [2025-01-23]</a></h2>
<ul>
<li><code>ry</code>
<ul>
<li>Warning on <code>debug</code> build</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>headers-property response returns <code>Headers</code> object instead of python dict</li>
</ul>
</li>
<li><code>same-file</code>
<ul>
<li>wrapper module added with <code>is_same_file</code> py-fn (yet another piece of burnt
sushi)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>jiff-version <code>0.1.25</code> ~ add <code>in_tz</code> methods and point old <code>intz</code> at new
<code>in_tz</code> methods and raise <code>DeprecationWarning</code> for old <code>intz</code> methods</li>
<li>Continued adding implementations that previously raised
<code>NotImplementedError</code>
<ul>
<li><code>Date.nth_weekday_of_month</code></li>
<li><code>Date.nth_weekday</code></li>
<li><code>DateTime.nth_weekday_of_month</code></li>
<li><code>DateTime.nth_weekday</code></li>
<li><code>TimeSpan.compare</code></li>
<li><code>TimeSpan.total</code></li>
<li><code>ZonedDateTime.nth_weekday_of_month</code></li>
<li><code>ZonedDateTime.nth_weekday</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0026-2025-01-13"><a class="header" href="#v0026-2025-01-13">v0.0.26 [2025-01-13]</a></h2>
<ul>
<li><code>reqwest</code>
<ul>
<li><code>AsyncClient</code> renamed to <code>HttpClient</code></li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>human timespan strings for <code>TimeSpan</code> and <code>SignedDuration</code> objects:
<ul>
<li><code>ry.TimeSpan.parse("P2M10DT2H30M").string(human=True) == "2mo 10d 2h 30m"</code></li>
<li><code>ry.SignedDuration.parse("PT2H30M").string(human=True) == "2h 30m"</code></li>
</ul>
</li>
</ul>
</li>
<li>internal
<ul>
<li>workspace-ified all the deps</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0025-2024-01-07-25-for-2025"><a class="header" href="#v0025-2024-01-07-25-for-2025">v0.0.25 [2024-01-07] (25 for 2025)</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Updated to <code>0.1.21</code> which has span and signed duration strings with capital
letters</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0024-2024-12-24-the-night-b4-xmas"><a class="header" href="#v0024-2024-12-24-the-night-b4-xmas">v0.0.24 [2024-12-24] (the night b4 xmas…)</a></h2>
<ul>
<li><code>http</code>
<ul>
<li>basic headers struct/obj – WIP</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>reqwest client (currently root-export)</li>
<li>default client + root <code>fetch</code> function likely needs work…</li>
<li>response <code>byte_stream</code>!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0023-2024-12-19"><a class="header" href="#v0023-2024-12-19">v0.0.23 [2024-12-19]</a></h2>
<ul>
<li><code>python -m ry.dev</code> repl for ipython/python repl ~ handy nifty secret tool
makes it into repo</li>
<li>internal
<ul>
<li>in process of renaming all python-rust <code>#[new]</code> functions to be named
<code>fn py_new(...)</code></li>
</ul>
</li>
<li><code>unindent</code>
<ul>
<li>Added <code>unindent</code> module for unindenting strings will move to <code>ryo3-unindent</code></li>
</ul>
</li>
<li><code>FsPath</code>
<ul>
<li>creeping ever closer to being a full-fledged pathlib.Path replacement</li>
<li>Added bindings to all rust <code>std::path::Path(buf)</code> methods for <code>FsPath</code></li>
</ul>
</li>
<li>sub-packaging
<ul>
<li><code>xxhash</code> is own sub package now <code>ry.xxhash</code></li>
<li><code>JSON</code> is own subpackage right now – named <code>ry.JSON</code> to avoid conflict with
<code>json</code> module but maybe will change…</li>
<li>food-for-thought-ing how <code>ryo3</code> and <code>ry</code> should be organized w/ respsect to
sub-packages and where that organization should be</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>required to break up the type annotations due to migration to sub-packages</li>
<li>breaking up the type annotations file into smaller files under
<code>&lt;REPO&gt;/python/ry/ryo3/*.pyi</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0022-2024-12-16"><a class="header" href="#v0022-2024-12-16">v0.0.22 [2024-12-16]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Super simple regex wrapper (must to do here, but was added for
<code>ryo3-which::which_re</code>)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li><code>until</code>/<code>since</code>
<ul>
<li>Basic <code>until</code>/<code>since</code> implementation but I do not like them and they
confusingly named <code>*Difference</code> structs/py-objects, so I may change how
they work…</li>
</ul>
</li>
<li><code>jiff</code> seems to be about as performant as <code>whenever</code> ~ yay! also the
whenever dude appears to be watching this repo (as of 2024-12-16)</li>
</ul>
</li>
<li><code>walkdir</code>
<ul>
<li><code>collect</code> added to <code>WalkdirGen</code> to collect the results into a list</li>
</ul>
</li>
<li>deps
<ul>
<li><code>thiserror</code> version <code>2.0.7</code> -&gt; <code>2.0.8</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0021-2024-12-13-friday-the-13th-spoogidy-oogidity"><a class="header" href="#v0021-2024-12-13-friday-the-13th-spoogidy-oogidity">v0.0.21 [2024-12-13] (friday the 13th… spoogidy oogidity)</a></h2>
<ul>
<li><code>walkdir</code>
<ul>
<li>add <code>glob</code> kwarg that takes a <code>ry.Glob</code> or <code>ry.GlobSet</code> or <code>ry.Globster</code> obj
to filter the walk on</li>
</ul>
</li>
<li><code>globset</code>
<ul>
<li>Internal refactoring</li>
<li>added <code>globster()</code> method to <code>ry.Glob</code> and <code>ry.GlobSet</code> to return a
<code>ry.Globster</code> obj</li>
<li>added <code>globset()</code> method to <code>ry.Glob</code> to return a <code>ry.GlobSet</code> obj from a
<code>ry.Glob</code> obj</li>
</ul>
</li>
<li><code>url</code>
<ul>
<li>python <code>Url</code> changed name <code>URL</code>; aligns with jawascript and other python
libs</li>
</ul>
</li>
<li><code>bzip2</code>
<ul>
<li>update to v5</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>conversions for jiff-round-mode/unit/weekday</li>
<li>not-implemented placeholders and new impls
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDateTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDate</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyOffset</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySignedDuration</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySpan</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTimeZone</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyZoned</code></li>
</ul>
</li>
<li>span builder functions use form <code>s._hours(1)</code> for panic-inducing building,
and <code>s.try_hours(1)</code> for non-panic-inducing building</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>fixes and updates and a hacky script I wrote to check for discrepancies</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0020-2024-12-10"><a class="header" href="#v0020-2024-12-10">v0.0.20 [2024-12-10]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Templated out regex package but nothing added</li>
</ul>
</li>
<li><code>ry</code>
<ul>
<li>python 3.13 yay!</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated jiter version thanks depbot!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0019-2024-12-05"><a class="header" href="#v0019-2024-12-05">v0.0.19 [2024-12-05]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>py-conversions
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDateTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDate</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffOffset</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSignedDuration</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSpan</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTimeZone</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffZoned</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0018-2024-12-03"><a class="header" href="#v0018-2024-12-03">v0.0.18 [2024-12-03]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Renamed <code>ry.Span</code> to <code>ry.TimeSpan</code></li>
<li>Renamed <code>ry.Zoned</code> to <code>ry.ZonedDateTime</code></li>
<li>Updated type stubs to reflect renames</li>
</ul>
</li>
<li>docs
<ul>
<li>init-ed the docs</li>
<li>style guide under <code>DEVELOPMENT.md</code> file</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0017-2024-12-02"><a class="header" href="#v0017-2024-12-02">v0.0.17 [2024-12-02]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li><code>ry.TimeZone</code> testing and to/from <code>datetime.tzinfo</code> conversions</li>
<li>Using nu-types for <code>jiff</code> intermediate types bc of the classic orphans
problem (aka batman) w/ traits</li>
<li>hypothesis tests</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated to <code>jiter</code> v0.8.1</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0016-2024-11-29"><a class="header" href="#v0016-2024-11-29">v0.0.16 [2024-11-29]</a></h2>
<ul>
<li>Moved walkdir to <code>ryo3-walkdir</code></li>
<li>added <code>ryo3-types</code> for custom and shared types</li>
<li><code>heck</code> wrapper(s)</li>
<li>jiff
<ul>
<li>Added operators <code>+</code>/<code>+=</code>/<code>-</code>/<code>-=</code> to date/time/datetime/etc</li>
<li>TODO: figure out how to take refs in the union enum for the operators</li>
</ul>
</li>
<li>fspath
<ul>
<li>further beefing out as well as testing</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0015-2024-11-20"><a class="header" href="#v0015-2024-11-20">v0.0.15 [2024-11-20]</a></h2>
<ul>
<li><code>from __future__ import annotations</code> added to all modules</li>
<li>cicd updated to include more targets</li>
</ul>
<hr />
<h2 id="v0014-2024-11-20"><a class="header" href="#v0014-2024-11-20">v0.0.14 [2024-11-20]</a></h2>
<ul>
<li>Primitive/crude wrappers around Mr. Sushi’s <code>jiff</code> library</li>
<li>Updated to use pyo3 (had to use jiter git repo dep)</li>
<li><code>ry.FsPath</code> beefed out</li>
<li>Added iterdir gen wrapper</li>
<li>(todo undo when jiter + pyo3 23 is public)</li>
</ul>
<hr />
<h2 id="v0013-2024-11-20"><a class="header" href="#v0013-2024-11-20">v0.0.13 [2024-11-20]</a></h2>
<ul>
<li><strong>VERSION SKIPPED DUE TO <code>13</code> BEING SPOOKY AND ME BEING MODERATELY-STITCHOUS
(AKA fully ‘superstitchous’)</strong></li>
</ul>
<hr />
<h2 id="v0012-2024-11-14"><a class="header" href="#v0012-2024-11-14">v0.0.12 [2024-11-14]</a></h2>
<ul>
<li>sqlformat wrapper(s) (this is the first <code>ryo3-*</code> sub-crate)</li>
</ul>
<hr />
<h2 id="v0011-2024-09-22"><a class="header" href="#v0011-2024-09-22">v0.0.11 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
<li>prepare for python 3.13</li>
</ul>
<hr />
<h2 id="v0010-2024-09-22"><a class="header" href="#v0010-2024-09-22">v0.0.10 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
</ul>
<hr />
<h2 id="v009-2024-08-22"><a class="header" href="#v009-2024-08-22">v0.0.9 [2024-08-22]</a></h2>
<ul>
<li>Added <code>globset</code> wrapper(s)</li>
<li>Added <code>__init__.py</code> generator</li>
</ul>
<hr />
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<h2 id="v008-2024-06-25"><a class="header" href="#v008-2024-06-25">v0.0.8 [2024-06-25]</a></h2>
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<hr />
<h2 id="v007-2024-06-08"><a class="header" href="#v007-2024-06-08">v0.0.7 [2024-06-08]</a></h2>
<ul>
<li>internal refactoring</li>
</ul>
<hr />
<h2 id="v006-2024-06-05"><a class="header" href="#v006-2024-06-05">v0.0.6 [2024-06-05]</a></h2>
<ul>
<li>Added zstd (<code>zstd_encode</code>/<code>zstd</code> and <code>zstd_decode</code>)</li>
<li>Added gzip (<code>gzip_encode</code>/<code>gzip</code> and <code>gzip_decode</code>/<code>gunzip</code>)</li>
<li>Added bzip2 (<code>bzip2_encode</code>/<code>bzip2</code> and <code>bzip2_decode</code>)</li>
<li>Added walkdir</li>
<li>Reorg libs</li>
</ul>
<hr />
<h2 id="v005-2024-04-19"><a class="header" href="#v005-2024-04-19">v0.0.5 [2024-04-19]</a></h2>
<ul>
<li>Added brotli (<code>brotli_encode</code> and <code>brotli_decode</code>)</li>
<li>xxhash
<ul>
<li>const functions</li>
<li>hasher streaming objects</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fspath"><a class="header" href="#fspath">fspath</a></h1>
<pre><code class="language-python">import ry

# get current directory
current_dir = ry.FsPath.cwd()

# write file
(current_dir / "test.txt").write_text("data!")

# read file
data = (current_dir / "test.txt").read_text()
print(data)
</code></pre>
<h1 id="get"><a class="header" href="#get">get</a></h1>
<pre><code class="language-python">import asyncio

import ry

try:
    from rich import print  # noqa: A004
except ImportError:
    ...


async def main() -&gt; None:
    response = await ry.fetch("https://httpbin.org/anything")
    print("Raw response:", response)
    print("socket:", response.remote_addr)
    print("url:", response.url)
    print("status:", response.status)
    print("headers:", response.headers)
    print("http-version:", response.http_version)
    print("content-length:", response.content_length)
    json_data = await response.json()
    print("JSON data: ", json_data)

    print("stringified: ", ry.stringify(json_data, fmt=True).decode())


if __name__ == "__main__":
    asyncio.run(main())
</code></pre>
<h1 id="http_fetch"><a class="header" href="#http_fetch">http_fetch</a></h1>
<pre><code class="language-python">"""Example of using the `ry.fetch` function to make http requests

The stuff at the top of this file is a simple http server for example purposes
"""

from __future__ import annotations

import asyncio
import json
from http.server import BaseHTTPRequestHandler, HTTPServer
from threading import Thread

# =============================================================================
import ry


def _print_break() -&gt; None:
    print("\n" + "=" * 79 + "\n")


async def main(server_url: str = "http://127.0.0.1:8000") -&gt; None:
    # -------------------------------------------------------------------------
    # GET
    # -------------------------------------------------------------------------
    _print_break()
    response = await ry.fetch(server_url)
    print("Raw response:", response)
    json_data = await response.json()
    print("JSON data:\n", json.dumps(json_data, indent=2))

    # **THE RESPONSE HAS BEEN CONSUMED**
    # No you cannot get the json again.... You are responsible for storing
    # The response has been consumed. This is how http requests really work.
    # Libraries like requests, httpx, aiohttp, etc. store the response data
    # in memory so you can access it multiple times, ry mirrors how fetch
    # works in reqwest which is also kinda how fetch works in
    # jawascript/interface-script.
    try:
        _json_data = await response.json()
    except ValueError as e:
        print("Error:", e)

    # -------------------------------------------------------------------------
    # POST
    # -------------------------------------------------------------------------
    _print_break()
    post_response = await ry.fetch(
        server_url, method="POST", body=b"post post post... dumb as a post"
    )
    print("Raw post response:", post_response)
    post_response_data = await post_response.json()
    print("JSON post response:\n", json.dumps(post_response_data, indent=2))

    # -------------------------------------------------------------------------
    # STREAMING
    # -------------------------------------------------------------------------
    _print_break()
    long_body = "\n".join([f"dingo{i}" for i in range(1000)]).encode()
    response = await ry.fetch(server_url, method="POST", body=long_body)

    async for chunk in response.bytes_stream():
        assert isinstance(chunk, ry.Bytes)  # tis a bytes
        py_bytes = bytes(chunk)
        assert isinstance(py_bytes, bytes)
        assert py_bytes == chunk
        print("chunk this! len =:", len(chunk))


# -----------------------------------------------------------------------------
# HTTP SERVER THAT DOES SUPER SIMPLE JSON RESPONSES
# -----------------------------------------------------------------------------
class HTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self) -&gt; None:
        self.send_response(200)
        self.send_header("Content-type", "application/json")
        self.end_headers()
        res_data = {
            "path": self.path,
            "method": "GET",
            "data": {
                "dog": "dingo",
                "oreo": "mcflurry",
            },
        }
        res_bytes = json.dumps(res_data).encode()
        self.wfile.write(res_bytes)

    def do_POST(self) -&gt; None:
        self.send_response(200)
        self.send_header("Content-type", "application/json")
        self.end_headers()
        body = self.rfile.read(int(self.headers["Content-Length"]))

        res_data = {
            "path": self.path,
            "method": "POST",
            "body": body.decode(),
            "data": {
                "dog": "dingo",
                "oreo": "mcflurry",
            },
        }
        res_bytes = json.dumps(res_data).encode()
        self.wfile.write(res_bytes)


def start_server(
    host: str = "127.0.0.1", port: int = 8888, logging: bool = False
) -&gt; HTTPServer:
    class HttpRequestHandlerNoLog(HTTPRequestHandler):
        def log_message(self, format, *args):  # type: ignore[no-untyped-def]
            ...

    server_address = (host, port)
    handler = HttpRequestHandlerNoLog if not logging else HTTPRequestHandler
    httpd = HTTPServer(server_address, handler)
    Thread(target=httpd.serve_forever, daemon=True).start()
    return httpd


if __name__ == "__main__":
    server = start_server(logging=True)
    try:
        asyncio.run(
            main(server_url=f"http://{server.server_name}:{server.server_port}")
        )
    except KeyboardInterrupt:
        print("KeyboardInterrupt")
    finally:
        server.shutdown()
</code></pre>
<h1 id="jiff_examples"><a class="header" href="#jiff_examples">jiff_examples</a></h1>
<pre><code class="language-python">"""Jiff examples (v2)

Translated jiff-examples from jiff-v2's docs

REF: https://docs.rs/jiff/latest/jiff/#examples
DATE: 2025-05-23
"""

from __future__ import annotations

import json
from dataclasses import dataclass

import ry


def test_get_current_time_in_system_tz() -&gt; None:
    now = ry.ZonedDateTime.now()
    assert isinstance(now, ry.ZonedDateTime)
    assert now.tz.name


def test_print_current_time_rounded_to_second() -&gt; None:
    rounded = ry.ZonedDateTime.now().round("second")
    # nanoseconds should be zero after rounding to second
    assert rounded.nanosecond == 0


def test_print_todays_date_at_specific_time() -&gt; None:
    zdt = ry.ZonedDateTime.now().replace(
        hour=14, minute=0, second=0, nanosecond=0
    )
    assert zdt.hour == 14 and zdt.minute == 0 and zdt.second == 0
    assert zdt.nanosecond == 0


def test_print_current_unix_timestamp() -&gt; None:
    ts = ry.Timestamp.now()
    sec = ts.as_second()
    ns = ts.as_nanosecond()
    assert isinstance(sec, int) and sec &gt; 1_600_000_000
    # nanosecond count divided by 1e9 should equal seconds
    assert ns // 1_000_000_000 == sec


def test_print_datetime_for_a_timestamp() -&gt; None:
    ts = ry.Timestamp.from_millisecond(1_720_646_365_567)
    zdt = ts.to_zoned(ry.TimeZone("America/New_York"))
    assert zdt.string() == "2024-07-10T17:19:25.567-04:00[America/New_York]"
    assert ts.string() == "2024-07-10T21:19:25.567Z"


def test_create_zoned_datetime_from_civil_time() -&gt; None:
    zdt = ry.date(2023, 12, 31).at(18, 30, 0, 0).in_tz("America/New_York")
    assert zdt.string() == "2023-12-31T18:30:00-05:00[America/New_York]"


def test_change_an_instant_from_one_timezone_to_another() -&gt; None:
    paris = ry.date(1918, 11, 11).at(11, 0, 0, 0).in_tz("Europe/Paris")
    nyc = paris.in_tz("America/New_York")
    assert nyc.string() == "1918-11-11T06:00:00-05:00[America/New_York]"


def test_find_duration_between_two_zoned_datetimes() -&gt; None:
    a = ry.date(2020, 8, 26).at(6, 27, 0, 0).in_tz("America/New_York")
    b = ry.date(2023, 12, 31).at(18, 30, 0, 0).in_tz("America/New_York")
    span = b - a
    assert str(span) == "PT29341H3M"
    # until: specify largest unit via helper
    span2 = a.until(b, largest="year")
    assert str(span2) == "P3Y4M5DT12H3M"


def test_add_duration_to_a_zoned_datetime() -&gt; None:
    start = ry.date(2020, 8, 26).at(6, 27, 0, 0).in_tz("America/New_York")
    span = ry.TimeSpan()._years(3)._months(4)._days(5)._hours(12)._minutes(3)
    finish = start.add(span)  # previously `checked_add`
    assert finish.string() == "2023-12-31T18:30:00-05:00[America/New_York]"


def test_dealing_with_ambiguity() -&gt; None:
    gap = ry.date(2024, 3, 10).at(2, 30, 0, 0).in_tz("America/New_York")
    assert gap.string() == "2024-03-10T03:30:00-04:00[America/New_York]"

    fold = ry.date(2024, 11, 3).at(1, 30, 0, 0).in_tz("America/New_York")
    assert fold.string() == "2024-11-03T01:30:00-04:00[America/New_York]"


def test_parsing_a_span() -&gt; None:
    iso = ry.TimeSpan.parse("P5y1w10dT5h59m")
    expected = (
        ry.TimeSpan()._years(5)._weeks(1)._days(10)._hours(5)._minutes(59)
    )
    assert iso == expected
    assert str(iso) == "P5Y1W10DT5H59M"

    from_friendly = ry.TimeSpan.parse(
        "5 years, 1 week, 10 days, 5 hours, 59 minutes"
    )
    assert iso == from_friendly
    assert from_friendly.string(friendly=True) == "5y 1w 10d 5h 59m"
    assert from_friendly.friendly() == "5y 1w 10d 5h 59m"
    assert str(from_friendly) == "P5Y1W10DT5H59M"


def test_parsing_an_rfc2822_datetime_string() -&gt; None:
    base = ry.ZonedDateTime.parse_rfc2822("Thu, 29 Feb 2024 05:34 -0500")
    tas = base.in_tz("Australia/Tasmania")
    kol = base.in_tz("Asia/Kolkata")
    assert tas.format_rfc2822() == "Thu, 29 Feb 2024 21:34:00 +1100"
    assert kol.format_rfc2822() == "Thu, 29 Feb 2024 16:04:00 +0530"


def test_using_strftime_and_strptime() -&gt; None:
    zdt = ry.ZonedDateTime.strptime(
        "Monday, July 15, 2024 at 5:30pm US/Eastern",
        "%A, %B %d, %Y at %I:%M%p %Q",
    )
    assert zdt.string() == "2024-07-15T17:30:00-04:00[US/Eastern]"

    tas = ry.date(2024, 7, 15).at(17, 30, 59, 0).in_tz("Australia/Tasmania")
    formatted = tas.strftime("%A, %B %d, %Y at %-I:%M%P %Q")
    assert formatted == "Monday, July 15, 2024 at 5:30pm Australia/Tasmania"


@dataclass
class Record:
    timestamp: ry.Timestamp

    def to_json(self) -&gt; str:
        return json.dumps({"timestamp": self.timestamp.as_second()})

    @classmethod
    def from_json(cls, raw: str) -&gt; Record:
        data = json.loads(raw)
        return cls(timestamp=ry.Timestamp.from_second(data["timestamp"]))


def test_serializing_and_deserializing_integer_timestamps() -&gt; None:
    src = Record(timestamp=ry.Timestamp.from_second(1_517_644_800))
    wire = src.to_json()
    got = Record.from_json(wire)
    assert got.timestamp == src.timestamp
    assert wire == '{"timestamp": 1517644800}'


def main() -&gt; None:
    test_get_current_time_in_system_tz()
    test_print_current_time_rounded_to_second()
    test_print_todays_date_at_specific_time()
    test_print_current_unix_timestamp()
    test_print_datetime_for_a_timestamp()
    test_create_zoned_datetime_from_civil_time()
    test_change_an_instant_from_one_timezone_to_another()
    test_find_duration_between_two_zoned_datetimes()
    test_add_duration_to_a_zoned_datetime()
    test_dealing_with_ambiguity()
    test_parsing_a_span()
    test_parsing_an_rfc2822_datetime_string()
    test_using_strftime_and_strptime()
    test_serializing_and_deserializing_integer_timestamps()


if __name__ == "__main__":
    main()
</code></pre>
<h1 id="walking"><a class="header" href="#walking">walking</a></h1>
<pre><code class="language-python">"""
ry.walkdir example
"""

from __future__ import annotations

import os

import ry

PWD = os.path.dirname(os.path.abspath(__file__))


def _print_br(s: str | None = None) -&gt; None:
    print("_" * 79)
    if s:
        print(s)


def main() -&gt; None:
    dir2walk = PWD

    _print_br("Walking the directory tree")
    # Walking the directory tree
    for filepath in ry.walkdir(dir2walk):
        print(filepath)

    _print_br("Walking the directory tree with entries")
    # Walking the directory tree
    for direntry in ry.walkdir(dir2walk, objects=True):
        print(direntry, type(direntry))

    _print_br("Walking the directory tree with depth 1")
    # walking only files
    for filepath in ry.walkdir(dir2walk, dirs=False):
        print(filepath)
        assert ry.FsPath(filepath).is_file()

    # walking only directories
    for filepath in ry.walkdir(dir2walk, files=False):
        print(filepath)
        assert ry.FsPath(filepath).is_dir()

    # globset/globster
    for filepath in ry.walkdir(
        dir2walk,
        glob=ry.globster([
            "*.py",
        ]),
    ):
        assert filepath.endswith(".py")


if __name__ == "__main__":
    main()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="api.html#ry.ryo3.__init__"><code>ry.ryo3.__init__</code></a></li>
<li><a href="api.html#ry.ryo3._brotli"><code>ry.ryo3._brotli</code></a></li>
<li><a href="api.html#ry.ryo3._bytes"><code>ry.ryo3._bytes</code></a></li>
<li><a href="api.html#ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></a></li>
<li><a href="api.html#ry.ryo3._dev"><code>ry.ryo3._dev</code></a></li>
<li><a href="api.html#ry.ryo3._flate2"><code>ry.ryo3._flate2</code></a></li>
<li><a href="api.html#ry.ryo3._fnv"><code>ry.ryo3._fnv</code></a></li>
<li><a href="api.html#ry.ryo3._fspath"><code>ry.ryo3._fspath</code></a></li>
<li><a href="api.html#ry.ryo3._glob"><code>ry.ryo3._glob</code></a></li>
<li><a href="api.html#ry.ryo3._globset"><code>ry.ryo3._globset</code></a></li>
<li><a href="api.html#ry.ryo3._heck"><code>ry.ryo3._heck</code></a></li>
<li><a href="api.html#ry.ryo3._http"><code>ry.ryo3._http</code></a></li>
<li><a href="api.html#ry.ryo3._jiff"><code>ry.ryo3._jiff</code></a></li>
<li><a href="api.html#ry.ryo3._jiff_tz"><code>ry.ryo3._jiff_tz</code></a></li>
<li><a href="api.html#ry.ryo3._jiter"><code>ry.ryo3._jiter</code></a></li>
<li><a href="api.html#ry.ryo3._memchr"><code>ry.ryo3._memchr</code></a></li>
<li><a href="api.html#ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></a></li>
<li><a href="api.html#ry.ryo3._regex"><code>ry.ryo3._regex</code></a></li>
<li><a href="api.html#ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></a></li>
<li><a href="api.html#ry.ryo3._same_file"><code>ry.ryo3._same_file</code></a></li>
<li><a href="api.html#ry.ryo3._shlex"><code>ry.ryo3._shlex</code></a></li>
<li><a href="api.html#ry.ryo3._size"><code>ry.ryo3._size</code></a></li>
<li><a href="api.html#ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></a></li>
<li><a href="api.html#ry.ryo3._std"><code>ry.ryo3._std</code></a></li>
<li><a href="api.html#ry.ryo3._std_constants"><code>ry.ryo3._std_constants</code></a></li>
<li><a href="api.html#ry.ryo3._tokio"><code>ry.ryo3._tokio</code></a></li>
<li><a href="api.html#ry.ryo3._unindent"><code>ry.ryo3._unindent</code></a></li>
<li><a href="api.html#ry.ryo3._url"><code>ry.ryo3._url</code></a></li>
<li><a href="api.html#ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></a></li>
<li><a href="api.html#ry.ryo3._which"><code>ry.ryo3._which</code></a></li>
<li><a href="api.html#ry.ryo3._zstd"><code>ry.ryo3._zstd</code></a></li>
<li><a href="api.html#ry.ryo3.dirs"><code>ry.ryo3.dirs</code></a></li>
<li><a href="api.html#ry.ryo3.errors"><code>ry.ryo3.errors</code></a></li>
<li><a href="api.html#ry.ryo3.JSON"><code>ry.ryo3.JSON</code></a></li>
<li><a href="api.html#ry.ryo3.orjson"><code>ry.ryo3.orjson</code></a></li>
<li><a href="api.html#ry.ryo3.sh"><code>ry.ryo3.sh</code></a></li>
<li><a href="api.html#ry.ryo3.ulid"><code>ry.ryo3.ulid</code></a></li>
<li><a href="api.html#ry.ryo3.uuid"><code>ry.ryo3.uuid</code></a></li>
<li><a href="api.html#ry.ryo3.xxhash"><code>ry.ryo3.xxhash</code></a></li>
<li><a href="api.html#ry.ryo3.zstd"><code>ry.ryo3.zstd</code></a></li>
<li><a href="api.html#ry.dirs"><code>ry.dirs</code></a></li>
<li><a href="api.html#ry.JSON"><code>ry.JSON</code></a></li>
<li><a href="api.html#ry.ulid"><code>ry.ulid</code></a></li>
<li><a href="api.html#ry.uuid"><code>ry.uuid</code></a></li>
<li><a href="api.html#ry.xxhash"><code>ry.xxhash</code></a></li>
<li><a href="api.html#ry.zstd"><code>ry.zstd</code></a></li>
</ul>
<h2 id="ry.ryo3.__init__"><a class="header" href="#ry.ryo3.__init__"><code>ry.ryo3.__init__</code></a></h2>
<pre><code class="language-python">"""ry api ~ type annotations"""

from ry.ryo3 import JSON as JSON
from ry.ryo3 import ulid as ulid
from ry.ryo3 import uuid as uuid
from ry.ryo3 import xxhash as xxhash
from ry.ryo3 import zstd as zstd
from ry.ryo3._brotli import brotli as brotli
from ry.ryo3._brotli import brotli_decode as brotli_decode
from ry.ryo3._brotli import brotli_encode as brotli_encode
from ry.ryo3._bytes import Bytes as Bytes
from ry.ryo3._bzip2 import bzip2 as bzip2
from ry.ryo3._bzip2 import bzip2_decode as bzip2_decode
from ry.ryo3._bzip2 import bzip2_encode as bzip2_encode
from ry.ryo3._flate2 import gunzip as gunzip
from ry.ryo3._flate2 import gzip as gzip
from ry.ryo3._flate2 import gzip_decode as gzip_decode
from ry.ryo3._flate2 import gzip_encode as gzip_encode
from ry.ryo3._flate2 import is_gzipped as is_gzipped
from ry.ryo3._fnv import FnvHasher as FnvHasher
from ry.ryo3._fnv import fnv1a as fnv1a
from ry.ryo3._fspath import FsPath as FsPath
from ry.ryo3._glob import Pattern as Pattern
from ry.ryo3._glob import glob as glob
from ry.ryo3._globset import Glob as Glob
from ry.ryo3._globset import GlobSet as GlobSet
from ry.ryo3._globset import Globster as Globster
from ry.ryo3._globset import globster as globster
from ry.ryo3._heck import camel_case as camel_case
from ry.ryo3._heck import kebab_case as kebab_case
from ry.ryo3._heck import pascal_case as pascal_case
from ry.ryo3._heck import shouty_kebab_case as shouty_kebab_case
from ry.ryo3._heck import shouty_snake_case as shouty_snake_case
from ry.ryo3._heck import snake_case as snake_case
from ry.ryo3._heck import snek_case as snek_case
from ry.ryo3._heck import title_case as title_case
from ry.ryo3._heck import train_case as train_case
from ry.ryo3._http import Headers as Headers
from ry.ryo3._http import HttpStatus as HttpStatus
from ry.ryo3._jiff import Date as Date
from ry.ryo3._jiff import DateDifference as DateDifference
from ry.ryo3._jiff import DateTime as DateTime
from ry.ryo3._jiff import DateTimeDifference as DateTimeDifference
from ry.ryo3._jiff import DateTimeRound as DateTimeRound
from ry.ryo3._jiff import ISOWeekDate as ISOWeekDate
from ry.ryo3._jiff import JiffRoundMode as JiffRoundMode
from ry.ryo3._jiff import JiffUnit as JiffUnit
from ry.ryo3._jiff import Offset as Offset
from ry.ryo3._jiff import OffsetRound as OffsetRound
from ry.ryo3._jiff import SignedDuration as SignedDuration
from ry.ryo3._jiff import SignedDurationRound as SignedDurationRound
from ry.ryo3._jiff import Time as Time
from ry.ryo3._jiff import TimeDifference as TimeDifference
from ry.ryo3._jiff import TimeRound as TimeRound
from ry.ryo3._jiff import TimeSpan as TimeSpan
from ry.ryo3._jiff import Timestamp as Timestamp
from ry.ryo3._jiff import TimestampDifference as TimestampDifference
from ry.ryo3._jiff import TimestampRound as TimestampRound
from ry.ryo3._jiff import TimeZone as TimeZone
from ry.ryo3._jiff import TimeZoneDatabase as TimeZoneDatabase
from ry.ryo3._jiff import Weekday as Weekday
from ry.ryo3._jiff import WeekdayInt as WeekdayInt
from ry.ryo3._jiff import WeekdayStr as WeekdayStr
from ry.ryo3._jiff import ZonedDateTime as ZonedDateTime
from ry.ryo3._jiff import ZonedDateTimeDifference as ZonedDateTimeDifference
from ry.ryo3._jiff import ZonedDateTimeRound as ZonedDateTimeRound
from ry.ryo3._jiff import date as date
from ry.ryo3._jiff import datetime as datetime
from ry.ryo3._jiff import now as now
from ry.ryo3._jiff import offset as offset
from ry.ryo3._jiff import time as time
from ry.ryo3._jiff import timespan as timespan
from ry.ryo3._jiff import utcnow as utcnow
from ry.ryo3._jiff import zoned as zoned
from ry.ryo3._jiter import JsonParseKwargs as JsonParseKwargs
from ry.ryo3._jiter import JsonPrimitive as JsonPrimitive
from ry.ryo3._jiter import JsonValue as JsonValue
from ry.ryo3._jiter import json_cache_clear as json_cache_clear
from ry.ryo3._jiter import json_cache_usage as json_cache_usage
from ry.ryo3._jiter import parse_json as parse_json
from ry.ryo3._jiter import parse_jsonl as parse_jsonl
from ry.ryo3._jiter import read_json as read_json
from ry.ryo3._memchr import memchr as memchr
from ry.ryo3._memchr import memchr2 as memchr2
from ry.ryo3._memchr import memchr3 as memchr3
from ry.ryo3._memchr import memrchr as memrchr
from ry.ryo3._memchr import memrchr2 as memrchr2
from ry.ryo3._memchr import memrchr3 as memrchr3
from ry.ryo3._quick_maths import quick_maths as quick_maths
from ry.ryo3._regex import Regex as Regex
from ry.ryo3._reqwest import HttpClient as HttpClient
from ry.ryo3._reqwest import ReqwestError as ReqwestError
from ry.ryo3._reqwest import Response as Response
from ry.ryo3._reqwest import ResponseStream as ResponseStream
from ry.ryo3._reqwest import fetch as fetch
from ry.ryo3._same_file import is_same_file as is_same_file
from ry.ryo3._shlex import shplit as shplit
from ry.ryo3._size import Size as Size
from ry.ryo3._size import SizeFormatter as SizeFormatter
from ry.ryo3._size import fmt_size as fmt_size
from ry.ryo3._size import parse_size as parse_size
from ry.ryo3._sqlformat import SqlfmtQueryParams as SqlfmtQueryParams
from ry.ryo3._sqlformat import sqlfmt as sqlfmt
from ry.ryo3._sqlformat import sqlfmt_params as sqlfmt_params
from ry.ryo3._std import DirEntry as DirEntry
from ry.ryo3._std import Duration as Duration
from ry.ryo3._std import FileReadStream as FileReadStream
from ry.ryo3._std import FileType as FileType
from ry.ryo3._std import Instant as Instant
from ry.ryo3._std import IpAddr as IpAddr
from ry.ryo3._std import Ipv4Addr as Ipv4Addr
from ry.ryo3._std import Ipv6Addr as Ipv6Addr
from ry.ryo3._std import Metadata as Metadata
from ry.ryo3._std import SocketAddr as SocketAddr
from ry.ryo3._std import SocketAddrV4 as SocketAddrV4
from ry.ryo3._std import SocketAddrV6 as SocketAddrV6
from ry.ryo3._std import canonicalize as canonicalize
from ry.ryo3._std import copy as copy
from ry.ryo3._std import create_dir as create_dir
from ry.ryo3._std import create_dir_all as create_dir_all
from ry.ryo3._std import exists as exists
from ry.ryo3._std import instant as instant
from ry.ryo3._std import is_dir as is_dir
from ry.ryo3._std import is_file as is_file
from ry.ryo3._std import is_symlink as is_symlink
from ry.ryo3._std import metadata as metadata
from ry.ryo3._std import read as read
from ry.ryo3._std import read_bytes as read_bytes
from ry.ryo3._std import read_dir as read_dir
from ry.ryo3._std import read_stream as read_stream
from ry.ryo3._std import read_text as read_text
from ry.ryo3._std import remove_dir as remove_dir
from ry.ryo3._std import remove_dir_all as remove_dir_all
from ry.ryo3._std import remove_file as remove_file
from ry.ryo3._std import rename as rename
from ry.ryo3._std import sleep as sleep
from ry.ryo3._std import write as write
from ry.ryo3._std import write_bytes as write_bytes
from ry.ryo3._std import write_text as write_text
from ry.ryo3._std_constants import I8_BITS as I8_BITS
from ry.ryo3._std_constants import I8_MAX as I8_MAX
from ry.ryo3._std_constants import I8_MIN as I8_MIN
from ry.ryo3._std_constants import I16_BITS as I16_BITS
from ry.ryo3._std_constants import I16_MAX as I16_MAX
from ry.ryo3._std_constants import I16_MIN as I16_MIN
from ry.ryo3._std_constants import I32_BITS as I32_BITS
from ry.ryo3._std_constants import I32_MAX as I32_MAX
from ry.ryo3._std_constants import I32_MIN as I32_MIN
from ry.ryo3._std_constants import I64_BITS as I64_BITS
from ry.ryo3._std_constants import I64_MAX as I64_MAX
from ry.ryo3._std_constants import I64_MIN as I64_MIN
from ry.ryo3._std_constants import I128_BITS as I128_BITS
from ry.ryo3._std_constants import I128_MAX as I128_MAX
from ry.ryo3._std_constants import I128_MIN as I128_MIN
from ry.ryo3._std_constants import ISIZE_BITS as ISIZE_BITS
from ry.ryo3._std_constants import ISIZE_MAX as ISIZE_MAX
from ry.ryo3._std_constants import ISIZE_MIN as ISIZE_MIN
from ry.ryo3._std_constants import U8_BITS as U8_BITS
from ry.ryo3._std_constants import U8_MAX as U8_MAX
from ry.ryo3._std_constants import U8_MIN as U8_MIN
from ry.ryo3._std_constants import U16_BITS as U16_BITS
from ry.ryo3._std_constants import U16_MAX as U16_MAX
from ry.ryo3._std_constants import U16_MIN as U16_MIN
from ry.ryo3._std_constants import U32_BITS as U32_BITS
from ry.ryo3._std_constants import U32_MAX as U32_MAX
from ry.ryo3._std_constants import U32_MIN as U32_MIN
from ry.ryo3._std_constants import U64_BITS as U64_BITS
from ry.ryo3._std_constants import U64_MAX as U64_MAX
from ry.ryo3._std_constants import U64_MIN as U64_MIN
from ry.ryo3._std_constants import U128_BITS as U128_BITS
from ry.ryo3._std_constants import U128_MAX as U128_MAX
from ry.ryo3._std_constants import U128_MIN as U128_MIN
from ry.ryo3._std_constants import USIZE_BITS as USIZE_BITS
from ry.ryo3._std_constants import USIZE_MAX as USIZE_MAX
from ry.ryo3._std_constants import USIZE_MIN as USIZE_MIN
from ry.ryo3._tokio import AsyncFile as AsyncFile
from ry.ryo3._tokio import aiopen as aiopen
from ry.ryo3._tokio import asleep as asleep
from ry.ryo3._tokio import canonicalize_async as canonicalize_async
from ry.ryo3._tokio import copy_async as copy_async
from ry.ryo3._tokio import create_dir_all_async as create_dir_all_async
from ry.ryo3._tokio import create_dir_async as create_dir_async
from ry.ryo3._tokio import exists_async as exists_async
from ry.ryo3._tokio import hard_link_async as hard_link_async
from ry.ryo3._tokio import metadata_async as metadata_async
from ry.ryo3._tokio import read_async as read_async
from ry.ryo3._tokio import read_dir_async as read_dir_async
from ry.ryo3._tokio import read_link_async as read_link_async
from ry.ryo3._tokio import read_to_string_async as read_to_string_async
from ry.ryo3._tokio import remove_dir_all_async as remove_dir_all_async
from ry.ryo3._tokio import remove_dir_async as remove_dir_async
from ry.ryo3._tokio import remove_file_async as remove_file_async
from ry.ryo3._tokio import rename_async as rename_async
from ry.ryo3._tokio import sleep_async as sleep_async
from ry.ryo3._tokio import try_exists_async as try_exists_async
from ry.ryo3._tokio import write_async as write_async
from ry.ryo3._unindent import unindent as unindent
from ry.ryo3._unindent import unindent_bytes as unindent_bytes
from ry.ryo3._url import URL as URL
from ry.ryo3._walkdir import WalkDirEntry as WalkDirEntry
from ry.ryo3._walkdir import WalkdirGen as WalkdirGen
from ry.ryo3._walkdir import walkdir as walkdir
from ry.ryo3._which import which as which
from ry.ryo3._which import which_all as which_all
from ry.ryo3._which import which_re as which_re
from ry.ryo3._zstd import is_zstd as is_zstd
from ry.ryo3._zstd import zstd_compress as zstd_compress
from ry.ryo3._zstd import zstd_decode as zstd_decode
from ry.ryo3._zstd import zstd_decompress as zstd_decompress
from ry.ryo3._zstd import zstd_encode as zstd_encode
from ry.ryo3.errors import FeatureNotEnabledError as FeatureNotEnabledError
from ry.ryo3.JSON import stringify as stringify
from ry.ryo3.JSON import stringify_unsafe as stringify_unsafe
from ry.ryo3.orjson import orjson_default as orjson_default
from ry.ryo3.sh import cd as cd
from ry.ryo3.sh import home as home
from ry.ryo3.sh import ls as ls
from ry.ryo3.sh import mkdir as mkdir
from ry.ryo3.sh import pwd as pwd

# =============================================================================
# CONSTANTS
# =============================================================================
__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str
__target__: str
</code></pre>
<h2 id="ry.ryo3._brotli"><a class="header" href="#ry.ryo3._brotli"><code>ry.ryo3._brotli</code></a></h2>
<pre><code class="language-python">"""ryo3-brotli types"""

from ry._types import Buffer


def brotli_encode(
    data: Buffer, quality: int = 11, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(data: Buffer) -&gt; bytes: ...
def brotli(
    data: Buffer, quality: int = 11, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""
</code></pre>
<h2 id="ry.ryo3._bytes"><a class="header" href="#ry.ryo3._bytes"><code>ry.ryo3._bytes</code></a></h2>
<pre><code class="language-python">import sys
from typing import overload

import typing_extensions

if sys.version_info &gt;= (3, 12):
    from collections.abc import Buffer as Buffer
else:
    from typing_extensions import Buffer as Buffer


class Bytes(Buffer):
    """
    A buffer implementing the Python buffer protocol, allowing zero-copy access
    to underlying Rust memory.

    You can pass this to `memoryview` for a zero-copy view into the underlying
    data or to `bytes` to copy the underlying data into a Python `bytes`.

    Many methods from the Python `bytes` class are implemented on this,
    """

    def __init__(self, buf: Buffer = b"") -&gt; None:
        """Construct a new Bytes object.

        This will be a zero-copy view on the Python byte slice.
        """

    def __add__(self, other: Buffer) -&gt; Bytes: ...
    def __buffer__(self, flags: int) -&gt; memoryview: ...
    def __contains__(self, other: Buffer) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @overload
    def __getitem__(self, other: int) -&gt; int: ...
    @overload
    def __getitem__(self, other: slice) -&gt; Bytes: ...
    def __mul__(self, other: int) -&gt; Bytes: ...
    def __rmul__(self, other: int) -&gt; Bytes: ...
    def __len__(self) -&gt; int: ...
    def __bytes__(self) -&gt; bytes:
        """Return the underlying data as a Python `bytes` object."""

    def removeprefix(self, prefix: Buffer, /) -&gt; Bytes:
        """
        If the binary data starts with the prefix string, return `bytes[len(prefix):]`.
        Otherwise, return the original binary data.
        """

    def removesuffix(self, suffix: Buffer, /) -&gt; Bytes:
        """
        If the binary data ends with the suffix string and that suffix is not empty,
        return `bytes[:-len(suffix)]`. Otherwise, return the original binary data.
        """

    def isalnum(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetical ASCII characters or
        ASCII decimal digits and the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal digits
        are those byte values in the sequence `b'0123456789'`.
        """

    def isalpha(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetic ASCII characters and
        the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
        """

    def isascii(self) -&gt; bool:
        """
        Return `True` if the sequence is empty or all bytes in the sequence are ASCII,
        `False` otherwise.

        ASCII bytes are in the range `0-0x7F`.
        """

    def isdigit(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII decimal digits and the
        sequence is not empty, `False` otherwise.

        ASCII decimal digits are those byte values in the sequence `b'0123456789'`.
        """

    def islower(self) -&gt; bool:
        """
        Return `True` if there is at least one lowercase ASCII character in the sequence
        and no uppercase ASCII characters, `False` otherwise.
        """

    def isspace(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII whitespace and the sequence
        is not empty, `False` otherwise.

        ASCII whitespace characters are those byte values
        in the sequence `b' \t\n\r\x0b\f'` (space, tab, newline, carriage return,
        vertical tab, form feed).
        """

    def isupper(self) -&gt; bool:
        """
        Return `True` if there is at least one uppercase alphabetic ASCII character in
        the sequence and no lowercase ASCII characters, `False` otherwise.
        """

    def lower(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the uppercase ASCII characters converted
        to their corresponding lowercase counterpart.
        """

    def upper(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the lowercase ASCII characters converted
        to their corresponding uppercase counterpart.
        """

    def to_bytes(self) -&gt; bytes:
        """Copy this buffer's contents into a Python `bytes` object."""

    # =========================================================================
    # IMPL IN RY
    # =========================================================================

    def istitle(self) -&gt; bool:
        """
        Return `True` if the sequence is non-empty and contains only ASCII letters,
        digits, underscores, and hyphens, and starts with an ASCII letter or underscore.
        Otherwise, return `False`.
        """

    def decode(self, encoding: str = "utf-8", errors: str = "strict") -&gt; str:
        """Decode the binary data using the given encoding."""

    def hex(
        self, sep: str | None = None, bytes_per_sep: int | None = None
    ) -&gt; str:
        """Return a hexadecimal representation of the binary data."""

    @classmethod
    def fromhex(cls, hexstr: str) -&gt; Bytes:
        """Construct a `Bytes` object from a hexadecimal string."""

    def startswith(self, prefix: Buffer) -&gt; bool:
        """Return `True` if the binary data starts with the prefix string, `False` otherwise."""

    def endswith(self, suffix: Buffer) -&gt; bool:
        """Return `True` if the binary data ends with the suffix string, `False` otherwise."""

    def capitalize(self) -&gt; Bytes:
        """
        Return a copy of the sequence with the first byte converted to uppercase and
        all other bytes converted to lowercase.
        """

    def strip(self, chars: Buffer | None = None) -&gt; Bytes:
        """
        Return a copy of the sequence with leading and trailing bytes removed.
        If `chars` is provided, remove all bytes in `chars` from both ends.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def lstrip(self, chars: Buffer | None = None) -&gt; Bytes:
        """
        Return a copy of the sequence with leading bytes removed.
        If `chars` is provided, remove all bytes in `chars` from the left end.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def rstrip(self, chars: Buffer | None = None) -&gt; Bytes:
        """
        Return a copy of the sequence with trailing bytes removed.
        If `chars` is provided, remove all bytes in `chars` from the right end.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def expandtabs(self, tabsize: int = 8) -&gt; Bytes:
        """
        Return a copy of the sequence with all ASCII tab characters replaced by spaces.
        The number of spaces is determined by the `tabsize` parameter.
        """

    def title(self) -&gt; Bytes:
        """
        Return a copy of the sequence with the first byte of each word converted to
        uppercase and all other bytes converted to lowercase.
        """

    def swapcase(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all uppercase ASCII characters converted to
        their corresponding lowercase counterpart and vice versa.
        """


BytesLike: typing_extensions.TypeAlias = (
    Buffer | bytes | bytearray | memoryview | Bytes
)
</code></pre>
<h2 id="ry.ryo3._bzip2"><a class="header" href="#ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></a></h2>
<pre><code class="language-python">"""ryo3-bzip2 types"""

from ry._types import Buffer


# =============================================================================
# BZIP2
# =============================================================================
def bzip2_encode(data: Buffer, quality: int = 9) -&gt; bytes: ...
def bzip2_decode(data: Buffer) -&gt; bytes: ...
def bzip2(data: Buffer, quality: int = 9) -&gt; bytes:
    """Alias for bzip2_encode"""
</code></pre>
<h2 id="ry.ryo3._dev"><a class="header" href="#ry.ryo3._dev"><code>ry.ryo3._dev</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.dev"""

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,  # noqa: A002
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...
</code></pre>
<h2 id="ry.ryo3._flate2"><a class="header" href="#ry.ryo3._flate2"><code>ry.ryo3._flate2</code></a></h2>
<pre><code class="language-python">"""ryo3-flate2 types"""

from typing import Literal, TypeAlias

from ry import Bytes
from ry._types import Buffer

Quality: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "best", "fast"]


def gzip_encode(data: Buffer, quality: Quality = 6) -&gt; Bytes: ...
def gzip_decode(data: Buffer) -&gt; Bytes: ...
def gzip(data: Buffer, quality: Quality = 6) -&gt; Bytes:
    """Alias for gzip_encode"""


def gunzip(data: Buffer) -&gt; Bytes:
    """Alias for gzip_decode"""


def is_gzipped(data: Buffer) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._fnv"><a class="header" href="#ry.ryo3._fnv"><code>ry.ryo3._fnv</code></a></h2>
<pre><code class="language-python">"""ryo3-fnv types"""

import typing as t

from ry._types import Buffer
from ry.ryo3._bytes import Bytes


@t.final
class FnvHasher:
    name: t.Literal["fnv1a"]
    digest_size: t.Literal[8]
    block_size: t.Literal[1]

    def __init__(
        self, data: Buffer | None = None, key: int | None = None
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; Bytes: ...
    def intdigest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; FnvHasher: ...


def fnv1a(data: Buffer, key: int | None = None) -&gt; FnvHasher: ...
</code></pre>
<h2 id="ry.ryo3._fspath"><a class="header" href="#ry.ryo3._fspath"><code>ry.ryo3._fspath</code></a></h2>
<pre><code class="language-python">"""ryo3-fspath types"""

import typing as t
from os import PathLike
from pathlib import Path

from ry._types import Buffer, ToPy
from ry.ryo3._bytes import Bytes
from ry.ryo3._regex import Regex
from ry.ryo3._std import Metadata


@t.final
class FsPath(ToPy[Path]):
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def to_py(self) -&gt; Path: ...
    def to_pathlib(self) -&gt; Path: ...
    # =========================================================================
    # IO
    # =========================================================================
    def read(self) -&gt; Bytes: ...
    def read_bytes(self) -&gt; bytes: ...
    def read_text(self) -&gt; str: ...
    def write(self, data: Buffer | bytes) -&gt; None: ...
    def write_bytes(self, data: Buffer | bytes) -&gt; None: ...
    def write_text(self, data: str) -&gt; None: ...
    def open(
        self,
        mode: str,
        buffering: int = -1,
        encoding: str | None = None,
        errors: str | None = None,
        newline: str | None = None,
    ) -&gt; t.IO[t.Any]: ...

    # =========================================================================
    # METHODS
    # =========================================================================
    def absolute(self) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...
    def as_uri(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def exists(self) -&gt; bool: ...
    def iterdir(self) -&gt; FsPathReaddir: ...
    def join(self, *paths: str) -&gt; FsPath: ...
    def joinpath(self, *paths: str) -&gt; FsPath: ...
    def metadata(self) -&gt; Metadata: ...
    def mkdir(
        self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False
    ) -&gt; None: ...
    def read_dir(self) -&gt; FsPathReaddir: ...
    def read_link(self) -&gt; FsPath: ...
    def relative_to(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def rename(self, new_path: PathLike[str] | str) -&gt; FsPath: ...
    def replace(self, new_path: PathLike[str] | str) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def rmdir(self, recursive: bool = False) -&gt; None: ...
    def string(self) -&gt; str: ...
    def unlink(
        self, missing_ok: bool = False, recursive: bool = False
    ) -&gt; None: ...
    def with_name(self, name: str) -&gt; t.Self: ...
    def with_suffix(self, suffix: str) -&gt; t.Self: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; t.Self: ...
    @classmethod
    def home(cls) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; t.Self: ...
    @property
    def parents(self) -&gt; t.Sequence[t.Self]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; str: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; t.Iterator[t.Self]: ...
    def canonicalize(self) -&gt; t.Self: ...
    def components(self) -&gt; t.Iterator[t.Self]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; t.Self: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, prefix: PathLike[str] | str) -&gt; t.Self: ...
    def with_extension(self, ext: str) -&gt; t.Self: ...
    def with_file_name(self, name: str) -&gt; t.Self: ...

    # =========================================================================
    # FEATURE: `same-file`
    # =========================================================================
    def samefile(self, other: PathLike[str] | str | t.Self) -&gt; bool: ...
    def symlink_metadata(self) -&gt; Metadata: ...

    # =========================================================================
    # FEATURE: `which` &amp; `which-regex`
    # =========================================================================
    @staticmethod
    def which(cmd: str, path: str) -&gt; FsPath | None: ...
    @staticmethod
    def which_all(cmd: str, path: str) -&gt; list[FsPath]: ...
    @staticmethod
    def which_re(regex: str | Regex, path: str) -&gt; FsPath | None: ...

    # =========================================================================
    # DUNDERS
    # =========================================================================
    def __truediv__(self, other: PathLike[str] | str) -&gt; t.Self: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; t.Self: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __bytes__(self) -&gt; bytes: ...


class FsPathReaddir:
    def __init__(self) -&gt; t.NoReturn: ...
    def __next__(self) -&gt; FsPath: ...
    def collect(self) -&gt; list[FsPath]: ...
    def take(self, n: int) -&gt; list[FsPath]: ...
    def __iter__(self) -&gt; t.Iterator[FsPath]: ...
</code></pre>
<h2 id="ry.ryo3._glob"><a class="header" href="#ry.ryo3._glob"><code>ry.ryo3._glob</code></a></h2>
<pre><code class="language-python">"""ryo3-glob types"""

import typing as t
from os import PathLike
from pathlib import Path

from ry.ryo3._fspath import FsPath

_T = t.TypeVar("_T", bound=str | Path | FsPath)


@t.final
class GlobPaths(t.Generic[_T]):
    """glob::Paths iterable wrapper"""

    def __next__(self) -&gt; _T: ...
    def __iter__(self) -&gt; GlobPaths[_T]: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = False,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
) -&gt; GlobPaths[Path]: ...
@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = False,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
    dtype: type[_T],
) -&gt; GlobPaths[_T]: ...


@t.final
class Pattern:
    def __init__(self, pattern: str) -&gt; None: ...
    def __call__(
        self,
        ob: str | PathLike[str],
        *,
        case_sensitive: bool = False,
        require_literal_separator: bool = False,
        require_literal_leading_dot: bool = False,
    ) -&gt; bool: ...
    def matches(self, s: str) -&gt; bool: ...
    def matches_path(self, path: PathLike[str]) -&gt; bool: ...
    def matches_with(
        self,
        s: str,
        *,
        case_sensitive: bool = False,
        require_literal_separator: bool = False,
        require_literal_leading_dot: bool = False,
    ) -&gt; bool: ...
    def matches_path_with(
        self,
        path: PathLike[str],
        *,
        case_sensitive: bool = False,
        require_literal_separator: bool = False,
        require_literal_leading_dot: bool = False,
    ) -&gt; bool: ...
    @staticmethod
    def escape(pattern: str) -&gt; str: ...
    @property
    def pattern(self) -&gt; str: ...
</code></pre>
<h2 id="ry.ryo3._globset"><a class="header" href="#ry.ryo3._globset"><code>ry.ryo3._globset</code></a></h2>
<pre><code class="language-python">"""ryo3-globset types"""

import typing as t
from os import PathLike


@t.final
class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def regex(self) -&gt; str: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


@t.final
class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def globster(self) -&gt; Globster: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


@t.final
class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


def globster(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Globster: ...
</code></pre>
<h2 id="ry.ryo3._heck"><a class="header" href="#ry.ryo3._heck"><code>ry.ryo3._heck</code></a></h2>
<pre><code class="language-python">"""ryo3-heck types"""


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...
</code></pre>
<h2 id="ry.ryo3._http"><a class="header" href="#ry.ryo3._http"><code>ry.ryo3._http</code></a></h2>
<pre><code class="language-python">import typing as t
from collections.abc import Mapping

# fmt: off
HttpVersionLike: t.TypeAlias = t.Literal[
    "HTTP/0.9", "0.9", 0,
    "HTTP/1.0", "1.0", 1, 10,
    "HTTP/1.1", "1.1", 11,
    "HTTP/2.0", "2.0", 2, 20,
    "HTTP/3.0", "3.0", 3, 30,
]
# fmt: on

_StandardHeader: t.TypeAlias = t.Literal[
    "accept",
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept-ranges",
    "access-control-allow-credentials",
    "access-control-allow-headers",
    "access-control-allow-methods",
    "access-control-allow-origin",
    "access-control-expose-headers",
    "access-control-max-age",
    "access-control-request-headers",
    "access-control-request-method",
    "age",
    "allow",
    "alt-svc",
    "authorization",
    "cache-control",
    "cache-status",
    "cdn-cache-control",
    "connection",
    "content-disposition",
    "content-encoding",
    "content-language",
    "content-length",
    "content-location",
    "content-range",
    "content-security-policy",
    "content-security-policy-report-only",
    "content-type",
    "cookie",
    "dnt",
    "date",
    "etag",
    "expect",
    "expires",
    "forwarded",
    "from",
    "host",
    "if-match",
    "if-modified-since",
    "if-none-match",
    "if-range",
    "if-unmodified-since",
    "last-modified",
    "link",
    "location",
    "max-forwards",
    "origin",
    "pragma",
    "proxy-authenticate",
    "proxy-authorization",
    "public-key-pins",
    "public-key-pins-report-only",
    "range",
    "referer",
    "referrer-policy",
    "refresh",
    "retry-after",
    "sec-websocket-accept",
    "sec-websocket-extensions",
    "sec-websocket-key",
    "sec-websocket-protocol",
    "sec-websocket-version",
    "server",
    "set-cookie",
    "strict-transport-security",
    "te",
    "trailer",
    "transfer-encoding",
    "user-agent",
    "upgrade",
    "upgrade-insecure-requests",
    "vary",
    "via",
    "warning",
    "www-authenticate",
    "x-content-type-options",
    "x-dns-prefetch-control",
    "x-frame-options",
    "x-xss-protection",
]

_HeaderName: t.TypeAlias = _StandardHeader | str
_VT = t.TypeVar("_VT", bound=str | t.Sequence[str])


@t.final
class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(
        self,
        headers: Mapping[_HeaderName, _VT] | t.Self | None = None,
        /,
        **kwargs: _VT,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: _HeaderName) -&gt; str: ...
    def __setitem__(self, key: _HeaderName, value: str) -&gt; None: ...
    def __delitem__(self, key: _HeaderName) -&gt; None: ...
    def __contains__(self, key: _HeaderName) -&gt; bool: ...
    def __or__(self, other: t.Self | dict[str, str]) -&gt; t.Self: ...
    def __ror__(self, other: t.Self | dict[str, str]) -&gt; t.Self: ...
    def __iter__(self) -&gt; t.Iterator[_HeaderName]: ...
    def __bool__(self) -&gt; bool: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def to_py(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def to_dict(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def stringify(self, *, fmt: bool = False) -&gt; str: ...
    def append(self, key: _HeaderName, value: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def contains_key(self, key: _HeaderName) -&gt; bool: ...
    def get(self, key: _HeaderName) -&gt; str | None: ...
    def get_all(self, key: _HeaderName) -&gt; list[str]: ...
    def insert(self, key: _HeaderName, value: str) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def keys(self) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def pop(self, key: _HeaderName) -&gt; str: ...
    def remove(self, key: _HeaderName) -&gt; None: ...
    def update(self, headers: t.Self | dict[str, str]) -&gt; None: ...
    def values(self) -&gt; list[str]: ...
    @property
    def is_flat(self) -&gt; bool: ...


@t.final
class HttpStatus:
    def __init__(self, code: int) -&gt; None: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: t.Self | int) -&gt; bool: ...
    def __le__(self, other: t.Self | int) -&gt; bool: ...
    def __gt__(self, other: t.Self | int) -&gt; bool: ...
    def __ge__(self, other: t.Self | int) -&gt; bool: ...
    def to_py(self) -&gt; int: ...
    @property
    def reason(self) -&gt; str: ...
    @property
    def canonical_reason(self) -&gt; str: ...
    @property
    def is_informational(self) -&gt; bool: ...
    @property
    def is_success(self) -&gt; bool: ...
    @property
    def is_redirect(self) -&gt; bool: ...
    @property
    def is_redirection(self) -&gt; bool: ...
    @property
    def is_client_error(self) -&gt; bool: ...
    @property
    def is_server_error(self) -&gt; bool: ...
    @property
    def is_error(self) -&gt; bool: ...
    @property
    def is_ok(self) -&gt; bool: ...
    @property
    def ok(self) -&gt; bool: ...

    # =========================================================================
    # CONST STATUS CODES
    # =========================================================================
    # fmt: off
    # 1xx: Informational
    CONTINUE: t.ClassVar[HttpStatus]  # 100 ~ Continue
    SWITCHING_PROTOCOLS: t.ClassVar[HttpStatus]  # 101 ~ Switching Protocols
    PROCESSING: t.ClassVar[HttpStatus]  # 102 ~ Processing
    # 2xx: Success
    OK: t.ClassVar[HttpStatus]  # 200 ~ OK
    CREATED: t.ClassVar[HttpStatus]  # 201 ~ Created
    ACCEPTED: t.ClassVar[HttpStatus]  # 202 ~ Accepted
    NON_AUTHORITATIVE_INFORMATION: t.ClassVar[HttpStatus]  # 203 ~ Non Authoritative Information
    NO_CONTENT: t.ClassVar[HttpStatus]  # 204 ~ No Content
    RESET_CONTENT: t.ClassVar[HttpStatus]  # 205 ~ Reset Content
    PARTIAL_CONTENT: t.ClassVar[HttpStatus]  # 206 ~ Partial Content
    MULTI_STATUS: t.ClassVar[HttpStatus]  # 207 ~ Multi-Status
    ALREADY_REPORTED: t.ClassVar[HttpStatus]  # 208 ~ Already Reported
    IM_USED: t.ClassVar[HttpStatus]  # 226 ~ IM Used
    # 3xx: Redirection
    MULTIPLE_CHOICES: t.ClassVar[HttpStatus]  # 300 ~ Multiple Choices
    MOVED_PERMANENTLY: t.ClassVar[HttpStatus]  # 301 ~ Moved Permanently
    FOUND: t.ClassVar[HttpStatus]  # 302 ~ Found
    SEE_OTHER: t.ClassVar[HttpStatus]  # 303 ~ See Other
    NOT_MODIFIED: t.ClassVar[HttpStatus]  # 304 ~ Not Modified
    USE_PROXY: t.ClassVar[HttpStatus]  # 305 ~ Use Proxy
    TEMPORARY_REDIRECT: t.ClassVar[HttpStatus]  # 307 ~ Temporary Redirect
    PERMANENT_REDIRECT: t.ClassVar[HttpStatus]  # 308 ~ Permanent Redirect
    # 4xx: Client Error
    BAD_REQUEST: t.ClassVar[HttpStatus]  # 400 ~ Bad Request
    UNAUTHORIZED: t.ClassVar[HttpStatus]  # 401 ~ Unauthorized
    PAYMENT_REQUIRED: t.ClassVar[HttpStatus]  # 402 ~ Payment Required
    FORBIDDEN: t.ClassVar[HttpStatus]  # 403 ~ Forbidden
    NOT_FOUND: t.ClassVar[HttpStatus]  # 404 ~ Not Found
    METHOD_NOT_ALLOWED: t.ClassVar[HttpStatus]  # 405 ~ Method Not Allowed
    NOT_ACCEPTABLE: t.ClassVar[HttpStatus]  # 406 ~ Not Acceptable
    PROXY_AUTHENTICATION_REQUIRED: t.ClassVar[HttpStatus]  # 407 ~ Proxy Authentication Required
    REQUEST_TIMEOUT: t.ClassVar[HttpStatus]  # 408 ~ Request Timeout
    CONFLICT: t.ClassVar[HttpStatus]  # 409 ~ Conflict
    GONE: t.ClassVar[HttpStatus]  # 410 ~ Gone
    LENGTH_REQUIRED: t.ClassVar[HttpStatus]  # 411 ~ Length Required
    PRECONDITION_FAILED: t.ClassVar[HttpStatus]  # 412 ~ Precondition Failed
    PAYLOAD_TOO_LARGE: t.ClassVar[HttpStatus]  # 413 ~ Payload Too Large
    URI_TOO_LONG: t.ClassVar[HttpStatus]  # 414 ~ URI Too Long
    UNSUPPORTED_MEDIA_TYPE: t.ClassVar[HttpStatus]  # 415 ~ Unsupported Media Type
    RANGE_NOT_SATISFIABLE: t.ClassVar[HttpStatus]  # 416 ~ Range Not Satisfiable
    EXPECTATION_FAILED: t.ClassVar[HttpStatus]  # 417 ~ Expectation Failed
    IM_A_TEAPOT: t.ClassVar[HttpStatus]  # 418 ~ I'm a teapot
    MISDIRECTED_REQUEST: t.ClassVar[HttpStatus]  # 421 ~ Misdirected Request
    UNPROCESSABLE_ENTITY: t.ClassVar[HttpStatus]  # 422 ~ Unprocessable Entity
    LOCKED: t.ClassVar[HttpStatus]  # 423 ~ Locked
    FAILED_DEPENDENCY: t.ClassVar[HttpStatus]  # 424 ~ Failed Dependency
    TOO_EARLY: t.ClassVar[HttpStatus]  # 425 ~ Too Early
    UPGRADE_REQUIRED: t.ClassVar[HttpStatus]  # 426 ~ Upgrade Required
    PRECONDITION_REQUIRED: t.ClassVar[HttpStatus]  # 428 ~ Precondition Required
    TOO_MANY_REQUESTS: t.ClassVar[HttpStatus]  # 429 ~ Too Many Requests
    REQUEST_HEADER_FIELDS_TOO_LARGE: t.ClassVar[HttpStatus]  # 431 ~ Request Header Fields Too Large
    UNAVAILABLE_FOR_LEGAL_REASONS: t.ClassVar[HttpStatus]  # 451 ~ Unavailable For Legal Reasons
    # 5xx: Server Error
    INTERNAL_SERVER_ERROR: t.ClassVar[HttpStatus]  # 500 ~ Internal Server Error
    NOT_IMPLEMENTED: t.ClassVar[HttpStatus]  # 501 ~ Not Implemented
    BAD_GATEWAY: t.ClassVar[HttpStatus]  # 502 ~ Bad Gateway
    SERVICE_UNAVAILABLE: t.ClassVar[HttpStatus]  # 503 ~ Service Unavailable
    GATEWAY_TIMEOUT: t.ClassVar[HttpStatus]  # 504 ~ Gateway Timeout
    HTTP_VERSION_NOT_SUPPORTED: t.ClassVar[HttpStatus]  # 505 ~ HTTP Version Not Supported
    VARIANT_ALSO_NEGOTIATES: t.ClassVar[HttpStatus]  # 506 ~ Variant Also Negotiates
    INSUFFICIENT_STORAGE: t.ClassVar[HttpStatus]  # 507 ~ Insufficient Storage
    LOOP_DETECTED: t.ClassVar[HttpStatus]  # 508 ~ Loop Detected
    NOT_EXTENDED: t.ClassVar[HttpStatus]  # 510 ~ Not Extended
    NETWORK_AUTHENTICATION_REQUIRED: t.ClassVar[HttpStatus]  # 511 ~ Network Authentication Required
    # fmt: on
</code></pre>
<h2 id="ry.ryo3._jiff"><a class="header" href="#ry.ryo3._jiff"><code>ry.ryo3._jiff</code></a></h2>
<pre><code class="language-python">"""ryo3-jiff types"""

import datetime as pydt
import typing as t

from ry._types import (
    DateDifferenceTypedDict,
    DateTimeDifferenceTypedDict,
    DateTimeRoundTypedDict,
    DateTimeTypedDict,
    DateTypedDict,
    FromStr,
    ISOWeekDateTypedDict,
    OffsetRoundTypedDict,
    OffsetTypedDict,
    SignedDurationRoundTypedDict,
    SignedDurationTypedDict,
    TimeDifferenceTypedDict,
    TimeRoundTypedDict,
    TimeSpanTypedDict,
    TimestampDifferenceTypedDict,
    TimestampRoundTypedDict,
    TimestampTypedDict,
    TimeTypedDict,
    ToPy,
    ToPyDate,
    ToPyDateTime,
    ToPyTime,
    ToPyTimeDelta,
    ToPyTzInfo,
    ZonedDateTimeDifferenceTypedDict,
    ZonedDateTimeRoundTypedDict,
    ZonedDateTimeTypedDict,
    deprecated,
)
from ry.ryo3 import Duration
from ry.ryo3._jiff_tz import TimezoneDbName

_T = t.TypeVar("_T")
_TDict = t.TypeVar("_TDict")

TimezoneName: t.TypeAlias = TimezoneDbName | str
JiffUnit: t.TypeAlias = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JiffRoundMode: t.TypeAlias = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half-ceil",
    "half-floor",
    "half-expand",
    "half-trunc",
    "half-even",
]
_DateTimeRoundSmallest: t.TypeAlias = t.Literal[
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_SignedDurationRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_TimeRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_TimestampRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_ZonedDateTimeRoundSmallest: t.TypeAlias = t.Literal[
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_OffsetRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
]

WeekdayStr: t.TypeAlias = t.Literal[
    "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
]
WeekdayInt: t.TypeAlias = t.Literal[
    1,  # Monday
    2,  # Tuesday
    3,  # Wednesday
    4,  # Thursday
    5,  # Friday
    6,  # Saturday
    7,  # Sunday
]
Weekday: t.TypeAlias = WeekdayStr | WeekdayInt


@t.final
class Date(ToPy[pydt.date], ToPyDate):
    MIN: t.ClassVar[Date]
    MAX: t.ClassVar[Date]
    ZERO: t.ClassVar[Date]

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.date: ...
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls, date: pydt.date) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(
        cls, year: int, week: int, weekday: int
    ) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...
    @t.overload
    def sub(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int = 0
    ) -&gt; DateTime: ...
    def to_dict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def replace(
        self,
        year: int | None = None,
        month: int | None = None,
        day: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
    ) -&gt; t.Self: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def to_datetime(self, t: Time) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal["year", "month", "week", "day"] = "day",
        largest: t.Literal["year", "month", "week", "day"] | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal["year", "month", "week", "day"] = "day",
        largest: t.Literal["year", "month", "week", "day"] | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class Time(ToPy[pydt.time], ToPyTime, FromStr):
    MIN: t.ClassVar[Time]
    MAX: t.ClassVar[Time]

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.time: ...
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls, t: pydt.time) -&gt; t.Self: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def utcnow(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def to_dict(self) -&gt; TimeTypedDict: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def replace(
        self,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _TimeRoundSmallest = "nanosecond",
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; t.Self: ...
    def _round(self, options: TimeRound) -&gt; t.Self: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def to_datetime(self, d: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class DateTime(ToPy[pydt.datetime], ToPyDate, ToPyTime, ToPyDateTime, FromStr):
    MIN: t.ClassVar[DateTime]
    MAX: t.ClassVar[DateTime]
    ZERO: t.ClassVar[DateTime]

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, fmt: str) -&gt; str: ...
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def __format__(self, fmt: str) -&gt; str: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, dt: pydt.datetime) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def from_parts(cls, date: Date, time: Time) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def saturating_sub(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def to_dict(self) -&gt; DateTimeTypedDict: ...
    def date(self) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; t.Self: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def replace(
        self,
        obj: Date | DateTime | Time | None = None,
        *,
        date: Date | None = None,
        time: Time | None = None,
        year: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        month: int | None = None,
        day: int | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _DateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; t.Self: ...
    def _round(self, options: DateTimeRound) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def start_of_day(self) -&gt; t.Self: ...
    def time(self) -&gt; Time: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class TimeZone(ToPy[pydt.tzinfo], ToPyTzInfo, FromStr):
    def __init__(self, name: TimezoneName) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __call__(self) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================

    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    @classmethod
    def from_str(cls, s: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def from_pytzinfo(cls, tz: pydt.tzinfo) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...
    @property
    def is_unknown(self) -&gt; bool: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls, offset: Offset) -&gt; t.Self: ...
    @classmethod
    def get(cls, name: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def posix(cls, name: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def system(cls) -&gt; t.Self: ...
    @classmethod
    def try_system(cls) -&gt; t.Self: ...
    @classmethod
    def tzif(cls, name: str, data: bytes) -&gt; t.Self: ...
    @classmethod
    def utc(cls) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, dt: Timestamp) -&gt; DateTime: ...
    def to_fixed_offset(self) -&gt; Offset:
        """Return a TimeZone with a fixed offset equivalent to this TimeZone.

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; tz = ry.TimeZone.fixed(ry.Offset(hours=-5))
            &gt;&gt;&gt; fixed_tz = tz.to_fixed_offset()
            &gt;&gt;&gt; fixed_tz
            Offset(hours=-5)

        """

    def to_offset(self, timestamp: Timestamp) -&gt; Offset: ...
    def to_timestamp(self, dt: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, other: DateTime) -&gt; ZonedDateTime: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


@t.final
class SignedDuration(ToPy[pydt.timedelta], ToPyTimeDelta, FromStr):
    MIN: t.ClassVar[SignedDuration]
    MAX: t.ClassVar[SignedDuration]
    ZERO: t.ClassVar[SignedDuration]

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __rmul__(self, other: int) -&gt; t.Self: ...
    def __sub__(self, other: t.Self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; t.Self: ...
    def __add__(self, other: t.Self) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    @t.overload
    def __truediv__(self, other: t.Self) -&gt; float: ...
    @t.overload
    def __truediv__(self, other: float) -&gt; t.Self: ...
    def abs(self) -&gt; t.Self: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(self, other: t.Self | pydt.timedelta, op: int) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self, *, friendly: bool = False) -&gt; str: ...
    def friendly(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, td: pydt.timedelta) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.timedelta: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_dict(self) -&gt; SignedDurationTypedDict: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def from_hours(cls, n: int) -&gt; t.Self: ...
    @classmethod
    def from_micros(cls, n: int) -&gt; t.Self: ...
    @classmethod
    def from_millis(cls, n: int) -&gt; t.Self: ...
    @classmethod
    def from_mins(cls, n: int) -&gt; t.Self: ...
    @classmethod
    def from_nanos(cls, n: int) -&gt; t.Self: ...
    @classmethod
    def from_secs(cls, n: int) -&gt; t.Self: ...
    @classmethod
    def from_secs_f32(cls, n: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f64(cls, n: float) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: t.Self) -&gt; t.Self | None: ...
    def checked_div(self, other: int) -&gt; t.Self | None: ...
    def checked_mul(self, other: int) -&gt; t.Self | None: ...
    def checked_neg(self) -&gt; t.Self | None: ...
    def checked_sub(self, other: t.Self) -&gt; t.Self | None: ...
    def div_duration_f32(self, other: t.Self) -&gt; float: ...
    def div_duration_f64(self, other: t.Self) -&gt; float: ...
    def div_f32(self, other: int) -&gt; float: ...
    def div_f64(self, other: int) -&gt; float: ...
    def is_positive(self) -&gt; bool: ...
    def mul_f32(self, other: int) -&gt; t.Self: ...
    def mul_f64(self, other: int) -&gt; t.Self: ...
    def saturating_add(self, other: t.Self) -&gt; t.Self: ...
    def saturating_mul(self, other: int) -&gt; t.Self: ...
    def saturating_sub(self, other: t.Self) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def subsec_micros(self) -&gt; int: ...
    def subsec_millis(self) -&gt; int: ...
    def subsec_nanos(self) -&gt; int: ...
    def to_timespan(self) -&gt; TimeSpan: ...
    def round(
        self,
        smallest: _SignedDurationRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: SignedDurationRound) -&gt; t.Self: ...


TimeSpanArithmetic: t.TypeAlias = (
    TimeSpan
    | Duration
    | SignedDuration
    | tuple[
        TimeSpan | Duration | SignedDuration, ZonedDateTime | Date | DateTime
    ]
)


@t.final
class TimeSpan(ToPy[pydt.timedelta], ToPyTimeDelta, FromStr):
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self, *, friendly: bool = False) -&gt; str: ...
    def friendly(self) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, td: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse_common_iso(cls, s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __neg__(self) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __invert__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: int) -&gt; t.Self: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(self, val: TimeSpanArithmetic) -&gt; t.Self: ...
    def mul(self, other: int) -&gt; t.Self: ...
    def sub(self, val: TimeSpanArithmetic) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; t.Self: ...
    def to_dict(self) -&gt; TimeSpanTypedDict: ...
    def compare(
        self,
        other: t.Self,
        relative: ZonedDateTime | DateTime | Date | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def negate(self) -&gt; t.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: JiffUnit,
        increment: int = 1,
        *,
        relative: ZonedDateTime | Date | DateTime | None = None,
        largest: JiffUnit | None = None,
        mode: JiffRoundMode | None = None,
    ) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self, relative: ZonedDateTime | Date | DateTime
    ) -&gt; SignedDuration: ...
    def total(
        self,
        unit: JiffUnit,
        relative: ZonedDateTime | Date | DateTime | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def total_seconds(self) -&gt; float: ...
    def _years(self, years: int) -&gt; t.Self: ...
    def _months(self, months: int) -&gt; t.Self: ...
    def _weeks(self, weeks: int) -&gt; t.Self: ...
    def _days(self, days: int) -&gt; t.Self: ...
    def _hours(self, hours: int) -&gt; t.Self: ...
    def _minutes(self, minutes: int) -&gt; t.Self: ...
    def _seconds(self, seconds: int) -&gt; t.Self: ...
    def _milliseconds(self, milliseconds: int) -&gt; t.Self: ...
    def _microseconds(self, microseconds: int) -&gt; t.Self: ...
    def _nanoseconds(self, nanoseconds: int) -&gt; t.Self: ...


@t.final
class Timestamp(ToPy[pydt.datetime], ToPyDate, ToPyTime, ToPyDateTime, FromStr):
    """
    A representation of a timestamp with second and nanosecond precision.
    """

    MIN: t.ClassVar[Timestamp]
    MAX: t.ClassVar[Timestamp]
    UNIX_EPOCH: t.ClassVar[Timestamp]

    def __init__(
        self, second: int | None = None, nanosecond: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def from_millisecond(cls, millisecond: int) -&gt; t.Self: ...
    @classmethod
    def from_microsecond(cls, microsecond: int) -&gt; t.Self: ...
    @classmethod
    def from_nanosecond(cls, nanosecond: int) -&gt; t.Self: ...
    @classmethod
    def from_second(cls, second: int) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, dt: pydt.datetime) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    def to_dict(self) -&gt; TimestampTypedDict: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def time(self) -&gt; Time: ...
    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...
    def as_second(self) -&gt; int: ...
    def display_with_offset(self, offset: Offset) -&gt; str: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime:
        """Deprecated ~ use `in_tz`"""

    def is_zero(self) -&gt; bool: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def string(self) -&gt; str: ...
    def subsec_microsecond(self) -&gt; int: ...
    def subsec_millisecond(self) -&gt; int: ...
    def subsec_nanosecond(self) -&gt; int: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def round(
        self,
        unit: _TimestampRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: TimestampRound) -&gt; t.Self: ...


@t.final
class ZonedDateTime(
    ToPy[pydt.datetime], ToPyDate, ToPyTime, ToPyDateTime, ToPyTzInfo, FromStr
):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
        tz: TimezoneName | None = None,
    ) -&gt; None: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, dt: pydt.datetime) -&gt; t.Self: ...
    def to_dict(self) -&gt; ZonedDateTimeTypedDict: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls, tz: TimezoneName | None = None) -&gt; t.Self: ...
    @classmethod
    def utcnow(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def from_rfc2822(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse_rfc2822(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def from_parts(
        cls, timestamp: Timestamp, time_zone: TimeZone
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...
    @property
    def timezone(self) -&gt; TimeZone: ...
    @property
    def tz(self) -&gt; TimeZone: ...

    # =========================================================================
    # STRING/FORMAT
    # =========================================================================
    def string(self) -&gt; str: ...
    def to_rfc2822(self) -&gt; str: ...
    def format_rfc2822(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def saturating_sub(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; t.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; t.Self: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; t.Self: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; t.Self: ...
    def inutc(self) -&gt; t.Self: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; Date: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; Date: ...
    def offset(self) -&gt; Offset: ...
    def replace(
        self,
        obj: Date | DateTime | Time | Offset | None = None,
        *,
        date: Date | None = None,
        time: Time | None = None,
        year: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        month: int | None = None,
        day: int | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
        offset: Offset | None = None,
        offset_conflict: t.Any = None,
        disambiguation: t.Any = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _ZonedDateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: ZonedDateTimeRound) -&gt; t.Self: ...
    def start_of_day(self) -&gt; t.Self: ...
    def time(self) -&gt; Time: ...
    def timestamp(self) -&gt; Timestamp: ...
    def tomorrow(self) -&gt; t.Self: ...
    def with_time_zone(self, tz: TimeZone) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self,
        other: t.Self,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: t.Self,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class ISOWeekDate:
    MIN: t.ClassVar[ISOWeekDate]
    MAX: t.ClassVar[ISOWeekDate]
    ZERO: t.ClassVar[ISOWeekDate]

    def __init__(self, year: int, week: int, weekday: Weekday) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================

    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __le__(self, other: ISOWeekDate) -&gt; bool: ...
    def __gt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __ge__(self, other: ISOWeekDate) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_date(cls, date: Date) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def week(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; WeekdayInt: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...
    def string(self) -&gt; str: ...
    def to_dict(self) -&gt; ISOWeekDateTypedDict: ...


@t.final
class Offset(ToPy[pydt.tzinfo], ToPyTzInfo, FromStr):
    MIN: t.ClassVar[Offset]
    MAX: t.ClassVar[Offset]
    UTC: t.ClassVar[Offset]
    ZERO: t.ClassVar[Offset]

    def __init__(
        self, hours: int | None = None, seconds: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    # __FROM__
    @classmethod
    def from_pytzinfo(cls, tz: pydt.tzinfo) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...

    # __TO__
    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    def to_dict(self) -&gt; OffsetTypedDict: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls) -&gt; t.Self: ...
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_seconds(cls, seconds: int) -&gt; t.Self: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...
    def sub(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def negate(self) -&gt; t.Self: ...
    def since(self, other: t.Self) -&gt; TimeSpan: ...
    def until(self, other: t.Self) -&gt; TimeSpan: ...
    def round(
        self,
        smallest: _OffsetRoundSmallest = "second",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: OffsetRound) -&gt; t.Self: ...


# =============================================================================
# DIFFERENCE
# =============================================================================
_Tobj = t.TypeVar("_Tobj", Date, DateTime, Time, Timestamp, ZonedDateTime)


@t.type_check_only
class _Difference(t.Generic[_Tobj, _TDict]):
    def __init__(
        self,
        obj: _Tobj,
        *,
        smallest: JiffUnit | None = None,
        largest: JiffUnit | None = None,
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @property
    def smallest(self) -&gt; JiffUnit: ...
    @property
    def largest(self) -&gt; JiffUnit | None: ...
    @property
    def mode(self) -&gt; JiffRoundMode: ...
    @property
    def increment(self) -&gt; int: ...
    def _smallest(self, unit: JiffUnit) -&gt; t.Self: ...
    def _largest(self, unit: JiffUnit) -&gt; t.Self: ...
    def _mode(self, mode: JiffRoundMode) -&gt; t.Self: ...
    def _increment(self, increment: int) -&gt; t.Self: ...
    def to_dict(self) -&gt; _TDict: ...


@t.final
class DateDifference(_Difference[Date, DateDifferenceTypedDict]): ...


@t.final
class DateTimeDifference(
    _Difference[DateTime, DateTimeDifferenceTypedDict]
): ...


@t.final
class TimeDifference(_Difference[Time, TimeDifferenceTypedDict]): ...


@t.final
class TimestampDifference(
    _Difference[Timestamp, TimestampDifferenceTypedDict]
): ...


@t.final
class ZonedDateTimeDifference(
    _Difference[ZonedDateTime, ZonedDateTimeDifferenceTypedDict]
): ...


# =============================================================================
# ROUND
# =============================================================================

_TSmallest = t.TypeVar(
    "_TSmallest",
)


@t.type_check_only
class _Round(t.Generic[_TSmallest, _TDict]):
    def __eq__(self, other: object) -&gt; bool: ...
    def _mode(self, mode: JiffRoundMode) -&gt; t.Self: ...
    def _smallest(self, smallest: _TSmallest) -&gt; t.Self: ...
    def _increment(self, increment: int) -&gt; t.Self: ...
    @property
    def smallest(self) -&gt; _TSmallest: ...
    @property
    def mode(self) -&gt; JiffRoundMode: ...
    @property
    def increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: _TSmallest | None = None,
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; t.Self: ...
    def to_dict(self) -&gt; _TDict: ...


@t.final
class DateTimeRound(_Round[_DateTimeRoundSmallest, DateTimeRoundTypedDict]):
    def __init__(
        self,
        smallest: _DateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, dt: DateTime) -&gt; DateTime: ...


@t.final
class SignedDurationRound(
    _Round[_SignedDurationRoundSmallest, SignedDurationRoundTypedDict]
):
    def __init__(
        self,
        smallest: _SignedDurationRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, sd: SignedDuration) -&gt; SignedDuration: ...


@t.final
class TimeRound(_Round[_TimeRoundSmallest, TimeRoundTypedDict]):
    def __init__(
        self,
        smallest: _TimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, dt: Time) -&gt; Time: ...


@t.final
class TimestampRound(_Round[_TimestampRoundSmallest, TimestampRoundTypedDict]):
    def __init__(
        self,
        smallest: _TimestampRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, dt: Timestamp) -&gt; Timestamp: ...


@t.final
class ZonedDateTimeRound(
    _Round[_ZonedDateTimeRoundSmallest, ZonedDateTimeRoundTypedDict]
):
    def __init__(
        self,
        smallest: _ZonedDateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, dt: ZonedDateTime) -&gt; ZonedDateTime: ...


@t.final
class OffsetRound(_Round[_OffsetRoundSmallest, OffsetRoundTypedDict]):
    def __init__(
        self,
        smallest: _OffsetRoundSmallest = "second",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, dt: Offset) -&gt; Offset: ...


@t.type_check_only
class JiffSeries(t.Protocol[_T]):
    def __iter__(self) -&gt; JiffSeries[_T]: ...
    def __next__(self) -&gt; _T: ...
    def take(self, n: int) -&gt; list[_T]: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def zoned(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
    tz: TimezoneName | None = None,
) -&gt; ZonedDateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...
def now() -&gt; ZonedDateTime: ...
def utcnow() -&gt; ZonedDateTime: ...


# =============================================================================
# TIMEZONE-DATABASE
# =============================================================================
@t.final
class TimeZoneDatabase:
    def __init__(self) -&gt; None:
        """Defaults to using the `self.from_env`"""

    @t.overload
    def get(self, name: TimezoneName, err: t.Literal[False]) -&gt; TimeZone | None:
        """Returns TimeZone or None if the timezone is not found"""

    @t.overload
    def get(self, name: TimezoneName, err: t.Literal[True] = True) -&gt; TimeZone:
        """Returns TimeZone, if not found raises a ValueError"""

    def available(self) -&gt; list[str]: ...
    def __getitem__(self, name: TimezoneName) -&gt; TimeZone: ...
    def __len__(self) -&gt; int: ...
    def is_definitively_empty(self) -&gt; bool: ...
    @classmethod
    def from_env(cls) -&gt; t.Self: ...
    @classmethod
    def from_dir(cls, path: str) -&gt; t.Self: ...
    @classmethod
    def from_concatenated_path(cls, path: str) -&gt; t.Self: ...
    @classmethod
    def bundled(cls) -&gt; t.Self: ...
</code></pre>
<h2 id="ry.ryo3._jiff_tz"><a class="header" href="#ry.ryo3._jiff_tz"><code>ry.ryo3._jiff_tz</code></a></h2>
<pre><code class="language-python">from typing import Literal, TypeAlias

TimezoneDbName: TypeAlias = Literal[
    "Africa/Abidjan",
    "Africa/Accra",
    "Africa/Addis_Ababa",
    "Africa/Algiers",
    "Africa/Asmara",
    "Africa/Asmera",
    "Africa/Bamako",
    "Africa/Bangui",
    "Africa/Banjul",
    "Africa/Bissau",
    "Africa/Blantyre",
    "Africa/Brazzaville",
    "Africa/Bujumbura",
    "Africa/Cairo",
    "Africa/Casablanca",
    "Africa/Ceuta",
    "Africa/Conakry",
    "Africa/Dakar",
    "Africa/Dar_es_Salaam",
    "Africa/Djibouti",
    "Africa/Douala",
    "Africa/El_Aaiun",
    "Africa/Freetown",
    "Africa/Gaborone",
    "Africa/Harare",
    "Africa/Johannesburg",
    "Africa/Juba",
    "Africa/Kampala",
    "Africa/Khartoum",
    "Africa/Kigali",
    "Africa/Kinshasa",
    "Africa/Lagos",
    "Africa/Libreville",
    "Africa/Lome",
    "Africa/Luanda",
    "Africa/Lubumbashi",
    "Africa/Lusaka",
    "Africa/Malabo",
    "Africa/Maputo",
    "Africa/Maseru",
    "Africa/Mbabane",
    "Africa/Mogadishu",
    "Africa/Monrovia",
    "Africa/Nairobi",
    "Africa/Ndjamena",
    "Africa/Niamey",
    "Africa/Nouakchott",
    "Africa/Ouagadougou",
    "Africa/Porto-Novo",
    "Africa/Sao_Tome",
    "Africa/Timbuktu",
    "Africa/Tripoli",
    "Africa/Tunis",
    "Africa/Windhoek",
    "America/Adak",
    "America/Anchorage",
    "America/Anguilla",
    "America/Antigua",
    "America/Araguaina",
    "America/Argentina/Buenos_Aires",
    "America/Argentina/Catamarca",
    "America/Argentina/ComodRivadavia",
    "America/Argentina/Cordoba",
    "America/Argentina/Jujuy",
    "America/Argentina/La_Rioja",
    "America/Argentina/Mendoza",
    "America/Argentina/Rio_Gallegos",
    "America/Argentina/Salta",
    "America/Argentina/San_Juan",
    "America/Argentina/San_Luis",
    "America/Argentina/Tucuman",
    "America/Argentina/Ushuaia",
    "America/Aruba",
    "America/Asuncion",
    "America/Atikokan",
    "America/Atka",
    "America/Bahia",
    "America/Bahia_Banderas",
    "America/Barbados",
    "America/Belem",
    "America/Belize",
    "America/Blanc-Sablon",
    "America/Boa_Vista",
    "America/Bogota",
    "America/Boise",
    "America/Buenos_Aires",
    "America/Cambridge_Bay",
    "America/Campo_Grande",
    "America/Cancun",
    "America/Caracas",
    "America/Catamarca",
    "America/Cayenne",
    "America/Cayman",
    "America/Chicago",
    "America/Chihuahua",
    "America/Ciudad_Juarez",
    "America/Coral_Harbour",
    "America/Cordoba",
    "America/Costa_Rica",
    "America/Coyhaique",
    "America/Creston",
    "America/Cuiaba",
    "America/Curacao",
    "America/Danmarkshavn",
    "America/Dawson",
    "America/Dawson_Creek",
    "America/Denver",
    "America/Detroit",
    "America/Dominica",
    "America/Edmonton",
    "America/Eirunepe",
    "America/El_Salvador",
    "America/Ensenada",
    "America/Fort_Nelson",
    "America/Fort_Wayne",
    "America/Fortaleza",
    "America/Glace_Bay",
    "America/Godthab",
    "America/Goose_Bay",
    "America/Grand_Turk",
    "America/Grenada",
    "America/Guadeloupe",
    "America/Guatemala",
    "America/Guayaquil",
    "America/Guyana",
    "America/Halifax",
    "America/Havana",
    "America/Hermosillo",
    "America/Indiana/Indianapolis",
    "America/Indiana/Knox",
    "America/Indiana/Marengo",
    "America/Indiana/Petersburg",
    "America/Indiana/Tell_City",
    "America/Indiana/Vevay",
    "America/Indiana/Vincennes",
    "America/Indiana/Winamac",
    "America/Indianapolis",
    "America/Inuvik",
    "America/Iqaluit",
    "America/Jamaica",
    "America/Jujuy",
    "America/Juneau",
    "America/Kentucky/Louisville",
    "America/Kentucky/Monticello",
    "America/Knox_IN",
    "America/Kralendijk",
    "America/La_Paz",
    "America/Lima",
    "America/Los_Angeles",
    "America/Louisville",
    "America/Lower_Princes",
    "America/Maceio",
    "America/Managua",
    "America/Manaus",
    "America/Marigot",
    "America/Martinique",
    "America/Matamoros",
    "America/Mazatlan",
    "America/Mendoza",
    "America/Menominee",
    "America/Merida",
    "America/Metlakatla",
    "America/Mexico_City",
    "America/Miquelon",
    "America/Moncton",
    "America/Monterrey",
    "America/Montevideo",
    "America/Montreal",
    "America/Montserrat",
    "America/Nassau",
    "America/New_York",
    "America/Nipigon",
    "America/Nome",
    "America/Noronha",
    "America/North_Dakota/Beulah",
    "America/North_Dakota/Center",
    "America/North_Dakota/New_Salem",
    "America/Nuuk",
    "America/Ojinaga",
    "America/Panama",
    "America/Pangnirtung",
    "America/Paramaribo",
    "America/Phoenix",
    "America/Port-au-Prince",
    "America/Port_of_Spain",
    "America/Porto_Acre",
    "America/Porto_Velho",
    "America/Puerto_Rico",
    "America/Punta_Arenas",
    "America/Rainy_River",
    "America/Rankin_Inlet",
    "America/Recife",
    "America/Regina",
    "America/Resolute",
    "America/Rio_Branco",
    "America/Rosario",
    "America/Santa_Isabel",
    "America/Santarem",
    "America/Santiago",
    "America/Santo_Domingo",
    "America/Sao_Paulo",
    "America/Scoresbysund",
    "America/Shiprock",
    "America/Sitka",
    "America/St_Barthelemy",
    "America/St_Johns",
    "America/St_Kitts",
    "America/St_Lucia",
    "America/St_Thomas",
    "America/St_Vincent",
    "America/Swift_Current",
    "America/Tegucigalpa",
    "America/Thule",
    "America/Thunder_Bay",
    "America/Tijuana",
    "America/Toronto",
    "America/Tortola",
    "America/Vancouver",
    "America/Virgin",
    "America/Whitehorse",
    "America/Winnipeg",
    "America/Yakutat",
    "America/Yellowknife",
    "Antarctica/Casey",
    "Antarctica/Davis",
    "Antarctica/DumontDUrville",
    "Antarctica/Macquarie",
    "Antarctica/Mawson",
    "Antarctica/McMurdo",
    "Antarctica/Palmer",
    "Antarctica/Rothera",
    "Antarctica/South_Pole",
    "Antarctica/Syowa",
    "Antarctica/Troll",
    "Antarctica/Vostok",
    "Arctic/Longyearbyen",
    "Asia/Aden",
    "Asia/Almaty",
    "Asia/Amman",
    "Asia/Anadyr",
    "Asia/Aqtau",
    "Asia/Aqtobe",
    "Asia/Ashgabat",
    "Asia/Ashkhabad",
    "Asia/Atyrau",
    "Asia/Baghdad",
    "Asia/Bahrain",
    "Asia/Baku",
    "Asia/Bangkok",
    "Asia/Barnaul",
    "Asia/Beirut",
    "Asia/Bishkek",
    "Asia/Brunei",
    "Asia/Calcutta",
    "Asia/Chita",
    "Asia/Choibalsan",
    "Asia/Chongqing",
    "Asia/Chungking",
    "Asia/Colombo",
    "Asia/Dacca",
    "Asia/Damascus",
    "Asia/Dhaka",
    "Asia/Dili",
    "Asia/Dubai",
    "Asia/Dushanbe",
    "Asia/Famagusta",
    "Asia/Gaza",
    "Asia/Harbin",
    "Asia/Hebron",
    "Asia/Ho_Chi_Minh",
    "Asia/Hong_Kong",
    "Asia/Hovd",
    "Asia/Irkutsk",
    "Asia/Istanbul",
    "Asia/Jakarta",
    "Asia/Jayapura",
    "Asia/Jerusalem",
    "Asia/Kabul",
    "Asia/Kamchatka",
    "Asia/Karachi",
    "Asia/Kashgar",
    "Asia/Kathmandu",
    "Asia/Katmandu",
    "Asia/Khandyga",
    "Asia/Kolkata",
    "Asia/Krasnoyarsk",
    "Asia/Kuala_Lumpur",
    "Asia/Kuching",
    "Asia/Kuwait",
    "Asia/Macao",
    "Asia/Macau",
    "Asia/Magadan",
    "Asia/Makassar",
    "Asia/Manila",
    "Asia/Muscat",
    "Asia/Nicosia",
    "Asia/Novokuznetsk",
    "Asia/Novosibirsk",
    "Asia/Omsk",
    "Asia/Oral",
    "Asia/Phnom_Penh",
    "Asia/Pontianak",
    "Asia/Pyongyang",
    "Asia/Qatar",
    "Asia/Qostanay",
    "Asia/Qyzylorda",
    "Asia/Rangoon",
    "Asia/Riyadh",
    "Asia/Saigon",
    "Asia/Sakhalin",
    "Asia/Samarkand",
    "Asia/Seoul",
    "Asia/Shanghai",
    "Asia/Singapore",
    "Asia/Srednekolymsk",
    "Asia/Taipei",
    "Asia/Tashkent",
    "Asia/Tbilisi",
    "Asia/Tehran",
    "Asia/Tel_Aviv",
    "Asia/Thimbu",
    "Asia/Thimphu",
    "Asia/Tokyo",
    "Asia/Tomsk",
    "Asia/Ujung_Pandang",
    "Asia/Ulaanbaatar",
    "Asia/Ulan_Bator",
    "Asia/Urumqi",
    "Asia/Ust-Nera",
    "Asia/Vientiane",
    "Asia/Vladivostok",
    "Asia/Yakutsk",
    "Asia/Yangon",
    "Asia/Yekaterinburg",
    "Asia/Yerevan",
    "Atlantic/Azores",
    "Atlantic/Bermuda",
    "Atlantic/Canary",
    "Atlantic/Cape_Verde",
    "Atlantic/Faeroe",
    "Atlantic/Faroe",
    "Atlantic/Jan_Mayen",
    "Atlantic/Madeira",
    "Atlantic/Reykjavik",
    "Atlantic/South_Georgia",
    "Atlantic/St_Helena",
    "Atlantic/Stanley",
    "Australia/ACT",
    "Australia/Adelaide",
    "Australia/Brisbane",
    "Australia/Broken_Hill",
    "Australia/Canberra",
    "Australia/Currie",
    "Australia/Darwin",
    "Australia/Eucla",
    "Australia/Hobart",
    "Australia/LHI",
    "Australia/Lindeman",
    "Australia/Lord_Howe",
    "Australia/Melbourne",
    "Australia/North",
    "Australia/NSW",
    "Australia/Perth",
    "Australia/Queensland",
    "Australia/South",
    "Australia/Sydney",
    "Australia/Tasmania",
    "Australia/Victoria",
    "Australia/West",
    "Australia/Yancowinna",
    "Brazil/Acre",
    "Brazil/DeNoronha",
    "Brazil/East",
    "Brazil/West",
    "Canada/Atlantic",
    "Canada/Central",
    "Canada/Eastern",
    "Canada/Mountain",
    "Canada/Newfoundland",
    "Canada/Pacific",
    "Canada/Saskatchewan",
    "Canada/Yukon",
    "CET",
    "Chile/Continental",
    "Chile/EasterIsland",
    "CST6CDT",
    "Cuba",
    "EET",
    "Egypt",
    "Eire",
    "EST",
    "EST5EDT",
    "Etc/GMT",
    "Etc/GMT+0",
    "Etc/GMT+1",
    "Etc/GMT+10",
    "Etc/GMT+11",
    "Etc/GMT+12",
    "Etc/GMT+2",
    "Etc/GMT+3",
    "Etc/GMT+4",
    "Etc/GMT+5",
    "Etc/GMT+6",
    "Etc/GMT+7",
    "Etc/GMT+8",
    "Etc/GMT+9",
    "Etc/GMT-0",
    "Etc/GMT-1",
    "Etc/GMT-10",
    "Etc/GMT-11",
    "Etc/GMT-12",
    "Etc/GMT-13",
    "Etc/GMT-14",
    "Etc/GMT-2",
    "Etc/GMT-3",
    "Etc/GMT-4",
    "Etc/GMT-5",
    "Etc/GMT-6",
    "Etc/GMT-7",
    "Etc/GMT-8",
    "Etc/GMT-9",
    "Etc/GMT0",
    "Etc/Greenwich",
    "Etc/UCT",
    "Etc/Universal",
    "Etc/UTC",
    "Etc/Zulu",
    "Europe/Amsterdam",
    "Europe/Andorra",
    "Europe/Astrakhan",
    "Europe/Athens",
    "Europe/Belfast",
    "Europe/Belgrade",
    "Europe/Berlin",
    "Europe/Bratislava",
    "Europe/Brussels",
    "Europe/Bucharest",
    "Europe/Budapest",
    "Europe/Busingen",
    "Europe/Chisinau",
    "Europe/Copenhagen",
    "Europe/Dublin",
    "Europe/Gibraltar",
    "Europe/Guernsey",
    "Europe/Helsinki",
    "Europe/Isle_of_Man",
    "Europe/Istanbul",
    "Europe/Jersey",
    "Europe/Kaliningrad",
    "Europe/Kiev",
    "Europe/Kirov",
    "Europe/Kyiv",
    "Europe/Lisbon",
    "Europe/Ljubljana",
    "Europe/London",
    "Europe/Luxembourg",
    "Europe/Madrid",
    "Europe/Malta",
    "Europe/Mariehamn",
    "Europe/Minsk",
    "Europe/Monaco",
    "Europe/Moscow",
    "Europe/Nicosia",
    "Europe/Oslo",
    "Europe/Paris",
    "Europe/Podgorica",
    "Europe/Prague",
    "Europe/Riga",
    "Europe/Rome",
    "Europe/Samara",
    "Europe/San_Marino",
    "Europe/Sarajevo",
    "Europe/Saratov",
    "Europe/Simferopol",
    "Europe/Skopje",
    "Europe/Sofia",
    "Europe/Stockholm",
    "Europe/Tallinn",
    "Europe/Tirane",
    "Europe/Tiraspol",
    "Europe/Ulyanovsk",
    "Europe/Uzhgorod",
    "Europe/Vaduz",
    "Europe/Vatican",
    "Europe/Vienna",
    "Europe/Vilnius",
    "Europe/Volgograd",
    "Europe/Warsaw",
    "Europe/Zagreb",
    "Europe/Zaporozhye",
    "Europe/Zurich",
    "Factory",
    "GB",
    "GB-Eire",
    "GMT",
    "GMT+0",
    "GMT-0",
    "GMT0",
    "Greenwich",
    "Hongkong",
    "HST",
    "Iceland",
    "Indian/Antananarivo",
    "Indian/Chagos",
    "Indian/Christmas",
    "Indian/Cocos",
    "Indian/Comoro",
    "Indian/Kerguelen",
    "Indian/Mahe",
    "Indian/Maldives",
    "Indian/Mauritius",
    "Indian/Mayotte",
    "Indian/Reunion",
    "Iran",
    "Israel",
    "Jamaica",
    "Japan",
    "Kwajalein",
    "Libya",
    "MET",
    "Mexico/BajaNorte",
    "Mexico/BajaSur",
    "Mexico/General",
    "MST",
    "MST7MDT",
    "Navajo",
    "NZ",
    "NZ-CHAT",
    "Pacific/Apia",
    "Pacific/Auckland",
    "Pacific/Bougainville",
    "Pacific/Chatham",
    "Pacific/Chuuk",
    "Pacific/Easter",
    "Pacific/Efate",
    "Pacific/Enderbury",
    "Pacific/Fakaofo",
    "Pacific/Fiji",
    "Pacific/Funafuti",
    "Pacific/Galapagos",
    "Pacific/Gambier",
    "Pacific/Guadalcanal",
    "Pacific/Guam",
    "Pacific/Honolulu",
    "Pacific/Johnston",
    "Pacific/Kanton",
    "Pacific/Kiritimati",
    "Pacific/Kosrae",
    "Pacific/Kwajalein",
    "Pacific/Majuro",
    "Pacific/Marquesas",
    "Pacific/Midway",
    "Pacific/Nauru",
    "Pacific/Niue",
    "Pacific/Norfolk",
    "Pacific/Noumea",
    "Pacific/Pago_Pago",
    "Pacific/Palau",
    "Pacific/Pitcairn",
    "Pacific/Pohnpei",
    "Pacific/Ponape",
    "Pacific/Port_Moresby",
    "Pacific/Rarotonga",
    "Pacific/Saipan",
    "Pacific/Samoa",
    "Pacific/Tahiti",
    "Pacific/Tarawa",
    "Pacific/Tongatapu",
    "Pacific/Truk",
    "Pacific/Wake",
    "Pacific/Wallis",
    "Pacific/Yap",
    "Poland",
    "Portugal",
    "PRC",
    "PST8PDT",
    "ROC",
    "ROK",
    "Singapore",
    "Turkey",
    "UCT",
    "Universal",
    "US/Alaska",
    "US/Aleutian",
    "US/Arizona",
    "US/Central",
    "US/East-Indiana",
    "US/Eastern",
    "US/Hawaii",
    "US/Indiana-Starke",
    "US/Michigan",
    "US/Mountain",
    "US/Pacific",
    "US/Samoa",
    "UTC",
    "W-SU",
    "WET",
    "Zulu",
]
</code></pre>
<h2 id="ry.ryo3._jiter"><a class="header" href="#ry.ryo3._jiter"><code>ry.ryo3._jiter</code></a></h2>
<pre><code class="language-python">import typing as t
from os import PathLike

from ry._types import Buffer, Unpack

# =============================================================================
# JSON
# =============================================================================
JsonPrimitive: t.TypeAlias = None | bool | int | float | str
JsonValue: t.TypeAlias = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


class JsonParseKwargs(t.TypedDict, total=False):
    allow_inf_nan: bool
    """Allow parsing of `Infinity`, `-Infinity`, `NaN` ~ default: False"""
    cache_mode: t.Literal[True, False, "all", "keys", "none"]
    """Cache mode for JSON parsing ~ default: `all` """
    partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"]
    """Partial mode for JSON parsing ~ default: False"""
    catch_duplicate_keys: bool
    """Catch duplicate keys in JSON objects ~ default: False"""


def parse_json(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_jsonl(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; list[JsonValue]: ...
def read_json(
    p: str | PathLike[str],
    /,
    lines: bool = False,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def json_cache_clear() -&gt; None: ...
def json_cache_usage() -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._memchr"><a class="header" href="#ry.ryo3._memchr"><code>ry.ryo3._memchr</code></a></h2>
<pre><code class="language-python">"""ryo3-memchr types"""

from typing import TypeAlias

from ry._types import Buffer

Byte: TypeAlias = int | bytes


def memchr(needle: Byte, haystack: Buffer) -&gt; int | None: ...
def memchr2(needle: Byte, needle2: Byte, haystack: Buffer) -&gt; int | None: ...
def memchr3(
    needle: Byte, needle2: Byte, needle3: Byte, haystack: Buffer
) -&gt; int | None: ...
def memrchr(needle: Byte, haystack: Buffer) -&gt; int | None: ...
def memrchr2(needle: Byte, needle2: Byte, haystack: Buffer) -&gt; int | None: ...
def memrchr3(
    needle: Byte, needle2: Byte, needle3: Byte, haystack: Buffer
) -&gt; int | None: ...
</code></pre>
<h2 id="ry.ryo3._quick_maths"><a class="header" href="#ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></a></h2>
<pre><code class="language-python">"""ryo3-quick-maths types"""

import typing as t


def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """
</code></pre>
<h2 id="ry.ryo3._regex"><a class="header" href="#ry.ryo3._regex"><code>ry.ryo3._regex</code></a></h2>
<pre><code class="language-python">"""ryo3-regex types"""

import typing as t

# =============================================================================
# Regex
# =============================================================================


@t.final
class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: str | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def is_match(self, string: str) -&gt; bool: ...
    def find(self, string: str) -&gt; str | None: ...
    def find_all(self, string: str) -&gt; list[tuple[int, int]]: ...
    def findall(self, string: str) -&gt; list[tuple[int, int]]: ...
    def replace(self, string: str, replacement: str) -&gt; str: ...
    def replace_all(self, string: str, replacement: str) -&gt; str: ...
    def split(self, string: str) -&gt; list[str]: ...
    def splitn(self, string: str, n: int) -&gt; list[str]: ...
</code></pre>
<h2 id="ry.ryo3._reqwest"><a class="header" href="#ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></a></h2>
<pre><code class="language-python">import typing as t

import ry
from ry._types import Buffer, Unpack
from ry.ryo3._http import Headers, HttpStatus, HttpVersionLike
from ry.ryo3._std import Duration, SocketAddr
from ry.ryo3._url import URL


class RequestKwargs(t.TypedDict, total=False):
    body: Buffer | None
    headers: Headers | dict[str, str] | None
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None
    json: t.Any
    form: t.Any
    multipart: t.Any
    timeout: Duration | None
    version: HttpVersionLike | None


@t.final
class HttpClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | None = None,
        cookies: bool = False,
        user_agent: str | None = None,  # default ~ 'ry-reqwest/&lt;VERSION&gt; ...'
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
    ) -&gt; None: ...
    async def get(
        self,
        url: str | URL,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def post(
        self,
        url: str | URL,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def put(
        self,
        url: str | URL,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def delete(
        self,
        url: str | URL,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def patch(
        self,
        url: str | URL,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def options(
        self,
        url: str | URL,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def head(
        self,
        url: str | URL,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: str | URL,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def __call__(
        self,
        url: str | URL,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...


@t.final
class ReqwestError(Exception):
    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None: ...
    def __dbg__(self) -&gt; str: ...
    def is_body(self) -&gt; bool: ...
    def is_builder(self) -&gt; bool: ...
    def is_connect(self) -&gt; bool: ...
    def is_decode(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_request(self) -&gt; bool: ...
    def is_status(self) -&gt; bool: ...
    def is_timeout(self) -&gt; bool: ...
    def status(self) -&gt; HttpStatus | None: ...
    def url(self) -&gt; URL | None: ...


@t.final
class Response:
    @property
    def headers(self) -&gt; Headers: ...
    async def text(self) -&gt; str: ...
    async def json(
        self,
        *,
        allow_inf_nan: bool = False,
        cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
        partial_mode: t.Literal[
            True, False, "off", "on", "trailing-strings"
        ] = False,
        catch_duplicate_keys: bool = False,
    ) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(self) -&gt; ResponseStream: ...
    def stream(self) -&gt; ResponseStream: ...
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def redirected(self) -&gt; bool: ...
    @property
    def content_length(self) -&gt; int | None: ...
    @property
    def content_encoding(self) -&gt; str | None: ...
    @property
    def body_used(self) -&gt; bool:
        """True if the body has been consumed"""

    @property
    def ok(self) -&gt; bool:
        """True if the status is a success (2xx)"""

    @property
    def remote_addr(self) -&gt; SocketAddr | None: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    def __bool__(self) -&gt; bool:
        """True if the status is a success (2xx)"""


@t.final
class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...
    async def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    @t.overload
    async def collect(
        self, join: t.Literal[False] = False
    ) -&gt; list[ry.Bytes]: ...
    @t.overload
    async def collect(self, join: t.Literal[True] = True) -&gt; ry.Bytes: ...


async def fetch(
    url: str | URL,
    *,
    client: HttpClient | None = None,
    method: str = "GET",
    **kwargs: Unpack[RequestKwargs],
) -&gt; Response: ...
</code></pre>
<h2 id="ry.ryo3._same_file"><a class="header" href="#ry.ryo3._same_file"><code>ry.ryo3._same_file</code></a></h2>
<pre><code class="language-python">"""ryo3-same-file types"""

from os import PathLike


def is_same_file(a: PathLike[str], b: PathLike[str]) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._shlex"><a class="header" href="#ry.ryo3._shlex"><code>ry.ryo3._shlex</code></a></h2>
<pre><code class="language-python">"""ryo3-shlex types"""


def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""
</code></pre>
<h2 id="ry.ryo3._size"><a class="header" href="#ry.ryo3._size"><code>ry.ryo3._size</code></a></h2>
<pre><code class="language-python">import typing as t

FormatSizeBase: t.TypeAlias = t.Literal[2, 10]  # default=2
FormatSizeStyle: t.TypeAlias = t.Literal[  # default="default"
    "default",
    "abbreviated",
    "abbreviated_lowercase",
    "abbreviated-lowercase",
    "full",
    "full-lowercase",
    "full_lowercase",
]


def fmt_size(
    n: int,
    *,
    base: FormatSizeBase = 2,
    style: FormatSizeStyle = "default",
) -&gt; str:
    """Return human-readable string representation of bytes-size."""


def parse_size(s: str) -&gt; int:
    """Return integer representation of human-readable bytes-size string.

    Raises:
        ValueError: If string is not a valid human-readable bytes-size string.
    """


@t.final
class SizeFormatter:
    """Human-readable bytes-size formatter."""

    def __init__(
        self,
        base: FormatSizeBase = 2,
        style: FormatSizeStyle = "default",
    ) -&gt; None:
        """Initialize human-readable bytes-size formatter."""

    def format(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __call__(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""


@t.final
class Size:
    """Bytes-size object."""

    def __init__(self, size: int) -&gt; None: ...
    @property
    def bytes(self) -&gt; int: ...
    def format(
        self,
        base: FormatSizeBase = 2,
        style: FormatSizeStyle = "default",
    ) -&gt; str: ...

    # =========================================================================
    # CLASS-METHODS
    # =========================================================================

    # -------------------------------------------------------------------------
    # PARSING
    # -------------------------------------------------------------------------
    @classmethod
    def parse(cls, size: str) -&gt; Size: ...
    @classmethod
    def from_str(cls, size: str) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # BYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_bytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # KILOBYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_kb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kibibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kilobytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # MEGABYTES
    # -------------------------------------------------------------------------

    @classmethod
    def from_mb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_mebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_megabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_mib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # GIGABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_gb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gibibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gigabytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # TERABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_tb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_tebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_terabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_tib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # PETABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_pb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_pebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_petabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_pib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # EXABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_eb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_eib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_exabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_exbibytes(cls, size: float) -&gt; Size: ...

    # =========================================================================
    # DUNDERS
    # =========================================================================
    def __add__(self, other: Size | float) -&gt; Size: ...
    def __sub__(self, other: Size | float) -&gt; Size: ...
    def __mul__(self, other: Size | float) -&gt; Size: ...
    def __rmul__(self, other: Size | float) -&gt; Size: ...
    def __neg__(self) -&gt; Size: ...
    def __pos__(self) -&gt; Size: ...
    def __abs__(self) -&gt; Size: ...
    def __invert__(self) -&gt; Size: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Size | float) -&gt; bool: ...
    def __le__(self, other: Size | float) -&gt; bool: ...
    def __gt__(self, other: Size | float) -&gt; bool: ...
    def __ge__(self, other: Size | float) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __int__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._sqlformat"><a class="header" href="#ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></a></h2>
<pre><code class="language-python">"""ryo3-sqlformat types"""

import typing as t

SqlfmtParamValue: t.TypeAlias = str | int | float | bool
_TSqlfmtParamValue_co = t.TypeVar(
    "_TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike: t.TypeAlias = (
    dict[str, _TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, _TSqlfmtParamValue_co]]
    | t.Sequence[_TSqlfmtParamValue_co]
)


class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    ) -&gt; None: ...
    def __len__(self) -&gt; int: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co] | SqlfmtQueryParams,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int | t.Literal["tabs", "\t"] = 2,
    uppercase: bool = False,
    lines_between_statements: int = 1,
    ignore_case_convert: list[str] | None = None,
    inline: bool = False,
    max_inline_block: int = 50,
    max_inline_arguments: int | None = None,
    max_inline_top_level: int | None = None,
    joins_as_top_level: bool = False,
) -&gt; str: ...
</code></pre>
<h2 id="ry.ryo3._std"><a class="header" href="#ry.ryo3._std"><code>ry.ryo3._std</code></a></h2>
<pre><code class="language-python">"""ryo3-std types"""

import datetime as pydt
import ipaddress
import pathlib
import typing as t

from ry._types import (
    Buffer,
    FileTypeDict,
    FsPathLike,
    MetadataDict,
    ToPy,
    ToPyTimeDelta,
)
from ry.ryo3._bytes import Bytes


# =============================================================================
# STD::TIME
# =============================================================================
@t.final
class Duration(ToPy[pydt.timedelta], ToPyTimeDelta):
    ZERO: t.ClassVar[Duration]
    MIN: t.ClassVar[Duration]
    MAX: t.ClassVar[Duration]
    NANOSECOND: t.ClassVar[Duration]
    MICROSECOND: t.ClassVar[Duration]
    MILLISECOND: t.ClassVar[Duration]
    SECOND: t.ClassVar[Duration]

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __add__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __sub__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __radd__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __rsub__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(self, other: t.Self | pydt.timedelta, op: int) -&gt; bool: ...
    def __bool__(self) -&gt; bool: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    @t.overload
    def __truediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __truediv__(self, other: float) -&gt; t.Self: ...
    @t.overload
    def __rtruediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __rtruediv__(self, other: float) -&gt; t.Self: ...
    def __mul__(self, other: float) -&gt; t.Self: ...
    def __rmul__(self, other: float) -&gt; t.Self: ...
    def abs_diff(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def sleep(self, interval: int = 10) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, td: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; t.Self: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; t.Self: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; t.Self: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; t.Self: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; t.Self: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_days(cls, days: int) -&gt; t.Self: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; t.Self: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; float: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # ARITHMETIC
    # =========================================================================
    def checked_add(self, other: t.Self) -&gt; t.Self | None: ...
    def checked_div(self, other: int) -&gt; t.Self | None: ...
    def checked_mul(self, other: float) -&gt; t.Self | None: ...
    def checked_sub(self, other: t.Self) -&gt; t.Self | None: ...
    def div_duration_f32(self, other: t.Self) -&gt; float: ...
    def div_duration_f64(self, other: t.Self) -&gt; float: ...
    def div_f32(self, other: float) -&gt; t.Self: ...
    def div_f64(self, other: float) -&gt; t.Self: ...
    def mul_f32(self, other: float) -&gt; t.Self: ...
    def mul_f64(self, other: float) -&gt; t.Self: ...
    def saturating_add(self, other: t.Self) -&gt; t.Self: ...
    def saturating_mul(self, other: int) -&gt; t.Self: ...
    def saturating_sub(self, other: t.Self) -&gt; t.Self: ...


@t.final
class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: t.Self) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; t.Self | None: ...
    def checked_duration_since(self, earlier: t.Self) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; t.Self | None: ...
    def duration_since(self, earlier: t.Self) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: t.Self) -&gt; Duration: ...


def instant() -&gt; Instant: ...
def sleep(seconds: float) -&gt; float: ...


# =============================================================================
# STD::FS
# =============================================================================
@t.final
class FileType:
    def __init__(self, *args: t.Never, **kwargs: t.Never) -&gt; t.NoReturn: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    def to_py(self) -&gt; FileTypeDict: ...


@t.final
class Permissions:
    @property
    def readonly(self) -&gt; bool: ...
    def __eq__(self, value: object) -&gt; bool: ...
    def __ne__(self, value: object) -&gt; bool: ...


@t.final
class Metadata:
    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def len(self) -&gt; int: ...
    @property
    def is_empty(self) -&gt; bool: ...
    @property
    def modified(self) -&gt; pydt.datetime: ...
    @property
    def accessed(self) -&gt; pydt.datetime: ...
    @property
    def created(self) -&gt; pydt.datetime: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def permissions(self) -&gt; Permissions: ...
    @property
    def readonly(self) -&gt; bool: ...
    def to_py(self) -&gt; MetadataDict: ...


@t.final
class DirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def basename(self) -&gt; str: ...
    @property
    def metadata(self) -&gt; Metadata: ...
    @property
    def file_type(self) -&gt; FileType: ...


_T = t.TypeVar("_T")


class RyIterable(t.Generic[_T]):
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; _T: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


@t.final
class ReadDir(RyIterable[DirEntry]): ...


@t.final
class FileReadStream:
    def __init__(
        self,
        path: FsPathLike,
        *,
        chunk_size: int = 65536,
        offset: int = 0,
        buffered: bool = True,
    ) -&gt; None: ...
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; Bytes: ...
    def collect(self) -&gt; list[Bytes]: ...
    def take(self, n: int = 1) -&gt; list[Bytes]: ...


# ============================================================================
# STD::FS ~ functions
# =============================================================================
def read(path: FsPathLike) -&gt; Bytes: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def read_dir(
    path: FsPathLike,
) -&gt; ReadDir: ...
def read_text(path: FsPathLike) -&gt; str: ...
def read_stream(
    path: FsPathLike,
    chunk_size: int = 65536,
    *,
    offset: int = 0,
) -&gt; FileReadStream: ...
def write(path: FsPathLike, data: Buffer | str) -&gt; int: ...
def write_bytes(path: FsPathLike, data: bytes) -&gt; int: ...
def write_text(path: FsPathLike, data: str) -&gt; int: ...
def canonicalize(path: FsPathLike) -&gt; pathlib.Path: ...
def copy(from_path: FsPathLike, to_path: FsPathLike) -&gt; int: ...
def create_dir(path: FsPathLike) -&gt; None: ...
def create_dir_all(path: FsPathLike) -&gt; None: ...
def exists(path: FsPathLike) -&gt; bool: ...
def is_dir(path: FsPathLike) -&gt; bool: ...
def is_file(path: FsPathLike) -&gt; bool: ...
def is_symlink(path: FsPathLike) -&gt; bool: ...
def metadata(path: FsPathLike) -&gt; Metadata: ...
def remove_dir(path: FsPathLike) -&gt; None: ...
def remove_dir_all(path: FsPathLike) -&gt; None: ...
def remove_file(path: FsPathLike) -&gt; None: ...
def rename(from_path: FsPathLike, to_path: FsPathLike) -&gt; None: ...


# =============================================================================
# STD::NET
# =============================================================================


class _Version4(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[4]: ...


class _Version6(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[6]: ...


class _Version(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[4, 6]: ...


class _Ipv4AddrProperties(t.Protocol):
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_link_local(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_reserved(self) -&gt; t.NoReturn: ...
    @property
    def is_shared(self) -&gt; t.NoReturn: ...
    @property
    def is_unspecified(self) -&gt; bool: ...


_T_ipaddress_co = t.TypeVar(
    "_T_ipaddress_co",
    bound=ipaddress.IPv4Address | ipaddress.IPv6Address,
    covariant=True,
)


class ToPyIpAddress(t.Protocol[_T_ipaddress_co]):
    def to_pyipaddress(self) -&gt; _T_ipaddress_co: ...


@t.final
class Ipv4Addr(
    _Ipv4AddrProperties,
    _Version4,
    ToPy[ipaddress.IPv4Address],
    ToPyIpAddress[ipaddress.IPv4Address],
):
    BROADCAST: Ipv4Addr
    LOCALHOST: Ipv4Addr
    UNSPECIFIED: Ipv4Addr

    @t.overload
    def __init__(self, a: int, b: int, c: int, d: int) -&gt; None: ...
    @t.overload
    def __init__(self, iplike: int | str | bytes | Ipv4Addr) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __le__(self, other: Ipv4Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv4Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv4Address: ...
    @property
    def version(self) -&gt; t.Literal[4]: ...
    @property
    def is_documentation(self) -&gt; bool: ...

    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def parse(cls, s: str) -&gt; Ipv4Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; Ipv4Addr: ...
    @classmethod
    def from_octets(cls, b: bytes) -&gt; Ipv4Addr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddr_v4(self, port: int) -&gt; SocketAddrV4: ...
    def to_socketaddr_v6(
        self, port: int, flowinfo: int = 0, scope_id: int = 0
    ) -&gt; SocketAddrV6: ...


class _Ipv6AddrProperties(t.Protocol):
    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_unicast_link_local(self) -&gt; bool: ...
    @property
    def is_unique_local(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4_mapped(self) -&gt; t.NoReturn: ...
    @property
    def is_unicast(self) -&gt; t.NoReturn: ...
    @property
    def is_unicast_global(self) -&gt; t.NoReturn: ...


@t.final
class Ipv6Addr(
    _Ipv6AddrProperties,
    _Version6,
    ToPy[ipaddress.IPv6Address],
    ToPyIpAddress[ipaddress.IPv6Address],
):
    LOCALHOST: Ipv6Addr
    UNSPECIFIED: Ipv6Addr

    @t.overload
    def __init__(
        self, a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int
    ) -&gt; None: ...
    @t.overload
    def __init__(self, iplike: int | str | bytes | Ipv6Addr) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __le__(self, other: Ipv6Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv6Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv6Address: ...
    @property
    def version(self) -&gt; t.Literal[6]: ...
    @property
    def is_documentation(self) -&gt; t.NoReturn: ...

    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def parse(cls, s: str) -&gt; Ipv4Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; IpAddr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddr_v4(self, port: int) -&gt; SocketAddrV4: ...
    def to_socketaddr_v6(
        self, port: int, flowinfo: int = 0, scope_id: int = 0
    ) -&gt; SocketAddrV6: ...


@t.final
class IpAddr(
    _Ipv4AddrProperties,
    _Ipv6AddrProperties,
    _Version,
    ToPy[ipaddress.IPv4Address | ipaddress.IPv6Address],
    ToPyIpAddress[ipaddress.IPv4Address | ipaddress.IPv6Address],
):
    BROADCAST: IpAddr
    LOCALHOST_V4: IpAddr
    UNSPECIFIED_V4: IpAddr
    LOCALHOST_V6: IpAddr
    UNSPECIFIED_V6: IpAddr

    def __init__(
        self,
        iplike: int
        | str
        | bytes
        | Ipv4Addr
        | Ipv6Addr
        | ipaddress.IPv4Address
        | ipaddress.IPv6Address,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: IpAddr) -&gt; bool: ...
    def __le__(self, other: IpAddr) -&gt; bool: ...
    def __gt__(self, other: IpAddr) -&gt; bool: ...
    def __ge__(self, other: IpAddr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv4Address | ipaddress.IPv6Address: ...
    def to_ipv4(self) -&gt; Ipv4Addr: ...
    def to_ipv6(self) -&gt; Ipv6Addr: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, ip: str) -&gt; IpAddr: ...

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def version(self) -&gt; t.Literal[4, 6]: ...
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; bool: ...
    @property
    def is_ipv6(self) -&gt; bool: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_canonical(self) -&gt; IpAddr: ...


@t.final
class SocketAddrV4(
    _Ipv4AddrProperties, _Version4, ToPyIpAddress[ipaddress.IPv4Address]
):
    def __init__(
        self,
        ip: IpAddr | Ipv4Addr | ipaddress.IPv4Address | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddrV4) -&gt; bool: ...
    def __le__(self, other: SocketAddrV4) -&gt; bool: ...
    def __gt__(self, other: SocketAddrV4) -&gt; bool: ...
    def __ge__(self, other: SocketAddrV4) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_ipaddrv4(self) -&gt; Ipv4Addr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    @staticmethod
    def parse(s: str) -&gt; SocketAddr: ...
    @property
    def port(self) -&gt; int: ...
    @property
    def ip(self) -&gt; Ipv4Addr: ...


@t.final
class SocketAddrV6(
    _Ipv6AddrProperties, _Version6, ToPyIpAddress[ipaddress.IPv6Address]
):
    def __init__(
        self,
        ip: IpAddr | Ipv6Addr | ipaddress.IPv4Address | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddrV6) -&gt; bool: ...
    def __le__(self, other: SocketAddrV6) -&gt; bool: ...
    def __gt__(self, other: SocketAddrV6) -&gt; bool: ...
    def __ge__(self, other: SocketAddrV6) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_ipaddrv6(self) -&gt; Ipv6Addr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    @staticmethod
    def parse(s: str) -&gt; SocketAddr: ...
    @property
    def port(self) -&gt; int: ...
    @property
    def ip(self) -&gt; Ipv6Addr: ...
    @property
    def is_documentation(self) -&gt; t.NoReturn: ...


@t.final
class SocketAddr(
    _Ipv4AddrProperties,
    _Ipv6AddrProperties,
    _Version,
    ToPyIpAddress[ipaddress.IPv4Address | ipaddress.IPv6Address],
):
    def __init__(
        self,
        ip: IpAddr
        | Ipv4Addr
        | Ipv6Addr
        | ipaddress.IPv4Address
        | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddr) -&gt; bool: ...
    def __le__(self, other: SocketAddr) -&gt; bool: ...
    def __gt__(self, other: SocketAddr) -&gt; bool: ...
    def __ge__(self, other: SocketAddr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    @staticmethod
    def parse(s: str) -&gt; SocketAddr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    @property
    def is_ipv4(self) -&gt; bool: ...
    @property
    def is_ipv6(self) -&gt; bool: ...
    @property
    def ip(self) -&gt; IpAddr: ...
    @property
    def port(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._std_constants"><a class="header" href="#ry.ryo3._std_constants"><code>ry.ryo3._std_constants</code></a></h2>
<pre><code class="language-python">from typing import Literal

# ruff: noqa: PYI054
# u8
U8_BITS: Literal[8]
U8_MAX: Literal[255]
U8_MIN: Literal[0]
# i8
I8_BITS: Literal[8]
I8_MAX: Literal[127]
I8_MIN: Literal[-128]
# i16
I16_BITS: Literal[16]
I16_MAX: Literal[32_767]
I16_MIN: Literal[-32_768]
# u16
U16_BITS: Literal[16]
U16_MAX: Literal[65_535]
U16_MIN: Literal[0]

# u32
U32_BITS: Literal[32]
U32_MAX: Literal[4_294_967_295]
U32_MIN: Literal[0]

# i32
I32_BITS: Literal[32]
I32_MAX: Literal[2_147_483_647]
I32_MIN: Literal[-2_147_483_648]

# u64
U64_BITS: Literal[64]
U64_MAX: Literal[18_446_744_073_709_551_615]
U64_MIN: Literal[0]

# i64
I64_BITS: Literal[64]
I64_MAX: Literal[9_223_372_036_854_775_807]
I64_MIN: Literal[-9_223_372_036_854_775_808]

# u128
U128_BITS: Literal[128]
U128_MAX: Literal[340_282_366_920_938_463_463_374_607_431_768_211_455]
U128_MIN: Literal[0]

# i128
I128_BITS: Literal[128]
I128_MAX: Literal[170_141_183_460_469_231_731_687_303_715_884_105_727]
I128_MIN: Literal[-170_141_183_460_469_231_731_687_303_715_884_105_727]

# usize
USIZE_BITS: Literal[32, 64]
USIZE_MAX: Literal[4_294_967_295, 18_446_744_073_709_551_615]
USIZE_MIN: Literal[0]
# isize
ISIZE_BITS: Literal[32, 64]
ISIZE_MAX: Literal[2_147_483_647, 9_223_372_036_854_775_807]
ISIZE_MIN: Literal[-2_147_483_648, -9_223_372_036_854_775_808]
</code></pre>
<h2 id="ry.ryo3._tokio"><a class="header" href="#ry.ryo3._tokio"><code>ry.ryo3._tokio</code></a></h2>
<pre><code class="language-python">"""ryo4-tokio types"""

import pathlib
import typing as t
from collections.abc import Generator
from types import TracebackType

from ry import Bytes
from ry._types import Buffer, FsPathLike, OpenBinaryMode
from ry.ryo3._std import FileType, Metadata


# =============================================================================
# FS
# =============================================================================
async def canonicalize_async(path: FsPathLike) -&gt; FsPathLike: ...
async def copy_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def create_dir_async(path: FsPathLike) -&gt; None: ...
async def create_dir_all_async(path: FsPathLike) -&gt; None: ...
async def hard_link_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def metadata_async(path: FsPathLike) -&gt; None: ...
async def read_async(path: FsPathLike) -&gt; Bytes: ...
async def remove_dir_async(path: FsPathLike) -&gt; None: ...
async def remove_dir_all_async(path: FsPathLike) -&gt; None: ...
async def remove_file_async(path: FsPathLike) -&gt; None: ...
async def read_link_async(path: FsPathLike) -&gt; FsPathLike: ...
async def read_to_string_async(path: FsPathLike) -&gt; str: ...
async def rename_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def write_async(path: FsPathLike, data: Buffer) -&gt; None: ...
async def try_exists_async(path: FsPathLike) -&gt; bool: ...
async def exists_async(path: FsPathLike) -&gt; bool: ...


@t.final
class DirEntryAsync:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def basename(self) -&gt; str: ...
    @property
    async def metadata(self) -&gt; Metadata: ...
    @property
    async def file_type(self) -&gt; FileType: ...


@t.final
class ReadDirAsync:
    """Async iterator for read_dir_async"""

    async def collect(self) -&gt; list[DirEntryAsync]: ...
    async def take(self, n: int) -&gt; list[DirEntryAsync]: ...
    def __aiter__(self) -&gt; ReadDirAsync: ...
    async def __anext__(self) -&gt; DirEntryAsync: ...


async def read_dir_async(path: FsPathLike) -&gt; ReadDirAsync: ...


# =============================================================================
# SLEEP
# =============================================================================
async def sleep_async(seconds: float) -&gt; float: ...
async def asleep(seconds: float) -&gt; float:
    """Alias for sleep_async"""


# =============================================================================
# ASYNC-FILE
# =============================================================================
@t.final
class AsyncFile:
    def __init__(
        self, path: FsPathLike, mode: OpenBinaryMode = "rb", buffering: int = -1
    ) -&gt; None: ...
    async def close(self) -&gt; None: ...
    async def flush(self) -&gt; None: ...
    async def isatty(self) -&gt; t.NoReturn: ...
    async def open(self) -&gt; None: ...
    async def peek(self, size: int = ..., /) -&gt; Bytes: ...
    async def read(self, size: int = ..., /) -&gt; Bytes: ...
    async def readable(self) -&gt; bool: ...
    async def readall(self) -&gt; Bytes: ...
    async def readline(self, size: int | None = ..., /) -&gt; Bytes: ...
    async def readlines(self, hint: int = ..., /) -&gt; list[Bytes]: ...
    async def seek(self, offset: int, whence: int = ..., /) -&gt; int: ...
    async def seekable(self) -&gt; bool: ...
    async def tell(self) -&gt; int: ...
    async def truncate(self, size: int | None = ..., /) -&gt; int: ...
    async def writable(self) -&gt; bool: ...
    async def write(self, b: Buffer, /) -&gt; int: ...
    @property
    def closed(self) -&gt; bool: ...
    def __await__(self) -&gt; Generator[t.Any, t.Any, t.Self]: ...
    def __aiter__(self) -&gt; t.Self: ...
    async def __anext__(self) -&gt; Bytes: ...
    async def __aenter__(self) -&gt; t.Self: ...
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -&gt; None: ...


def aiopen(
    path: FsPathLike, mode: OpenBinaryMode | str = "rb", buffering: int = -1
) -&gt; AsyncFile: ...
</code></pre>
<h2 id="ry.ryo3._unindent"><a class="header" href="#ry.ryo3._unindent"><code>ry.ryo3._unindent</code></a></h2>
<pre><code class="language-python">"""ryo3-unindent types"""


def unindent(string: str) -&gt; str: ...
def unindent_bytes(string: bytes) -&gt; bytes: ...
</code></pre>
<h2 id="ry.ryo3._url"><a class="header" href="#ry.ryo3._url"><code>ry.ryo3._url</code></a></h2>
<pre><code class="language-python">import typing as t
from ipaddress import IPv4Address, IPv6Address

from ry._types import FromStr, FsPathLike
from ry.ryo3._std import SocketAddr


@t.final
class URL(FromStr):
    def __init__(
        self, url: str | URL, *, params: dict[str, str] | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, url: str) -&gt; URL: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse_with_params(cls, url: str, params: dict[str, str]) -&gt; URL: ...
    @classmethod
    def from_directory_path(cls, path: FsPathLike) -&gt; URL: ...
    @classmethod
    def from_filepath(cls, path: FsPathLike) -&gt; URL: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __fspath__(self) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def domain(self) -&gt; str | None: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None: ...
    @property
    def port_or_known_default(self) -&gt; int | None: ...
    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_pairs(self) -&gt; tuple[tuple[str, str], ...]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def username(self) -&gt; str: ...
    @property
    def origin(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def make_relative(self, u: URL) -&gt; URL: ...
    def to_filepath(self) -&gt; str: ...
    def replace_fragment(self, fragment: str | None = None) -&gt; URL: ...
    def replace_host(self, host: str | None = None) -&gt; URL: ...
    def replace_ip_host(self, host: IPv4Address | IPv6Address) -&gt; URL: ...
    def replace_password(self, password: str | None = None) -&gt; URL: ...
    def replace_path(self, path: str) -&gt; URL: ...
    def replace_port(self, port: int | None = None) -&gt; URL: ...
    def replace_query(self, query: str | None = None) -&gt; URL: ...
    def replace_scheme(self, scheme: str) -&gt; URL: ...
    def replace_username(self, username: str) -&gt; URL: ...
    def socket_addrs(self) -&gt; list[SocketAddr]: ...
    def replace(
        self,
        *,
        fragment: str | None = None,
        host: str | None = None,
        ip_host: IPv4Address | IPv6Address | None = None,
        password: str | None = None,
        path: str | None = None,
        port: int | None = None,
        query: str | None = None,
        scheme: str | None = None,
        username: str | None = None,
    ) -&gt; URL: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __truediv__(self, relative: str) -&gt; URL: ...
    def __rtruediv__(self, relative: str) -&gt; URL: ...
    def __lt__(self, other: URL) -&gt; bool: ...
    def __le__(self, other: URL) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: URL) -&gt; bool: ...
    def __ge__(self, other: URL) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._walkdir"><a class="header" href="#ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></a></h2>
<pre><code class="language-python">"""ryo3-walkdir types"""

import typing as t
from os import PathLike

from ry import FileType, FsPath, Glob, GlobSet, Globster


@t.final
class WalkDirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; FsPath: ...
    @property
    def file_name(self) -&gt; str: ...
    @property
    def depth(self) -&gt; int: ...
    @property
    def path_is_symlink(self) -&gt; bool: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def len(self) -&gt; int: ...


_T_walkdir = t.TypeVar(
    "_T_walkdir",
    bound=WalkDirEntry | str,
)


@t.final
class WalkdirGen(t.Generic[_T_walkdir]):
    """walkdir::Walkdir iterable wrapper"""

    def __init__(
        self,
    ) -&gt; t.NoReturn: ...
    def __next__(self) -&gt; _T_walkdir: ...
    def collect(self) -&gt; list[_T_walkdir]: ...
    def take(self, n: int = 1) -&gt; list[_T_walkdir]: ...
    def __iter__(self) -&gt; t.Iterator[_T_walkdir]: ...


@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    *,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
    objects: t.Literal[True],
) -&gt; WalkdirGen[WalkDirEntry]: ...
@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    *,
    objects: t.Literal[False] = False,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
) -&gt; WalkdirGen[str]: ...
</code></pre>
<h2 id="ry.ryo3._which"><a class="header" href="#ry.ryo3._which"><code>ry.ryo3._which</code></a></h2>
<pre><code class="language-python">"""ryo3-which types"""

from pathlib import Path

from ry.ryo3._regex import Regex


def which(cmd: str, path: None | str = None) -&gt; Path | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[Path]: ...
def which_re(regex: str | Regex, path: None | str = None) -&gt; list[Path]: ...
</code></pre>
<h2 id="ry.ryo3._zstd"><a class="header" href="#ry.ryo3._zstd"><code>ry.ryo3._zstd</code></a></h2>
<pre><code class="language-python">"""ry.ryo3 root level zstd exports"""

from ry.ryo3.zstd import compress as zstd_compress
from ry.ryo3.zstd import decode as zstd_decode
from ry.ryo3.zstd import decompress as zstd_decompress
from ry.ryo3.zstd import encode as zstd_encode
from ry.ryo3.zstd import is_zstd as is_zstd

__all__ = (
    "is_zstd",
    "zstd_compress",
    "zstd_decode",
    "zstd_decompress",
    "zstd_encode",
)
</code></pre>
<h2 id="ry.ryo3.dirs"><a class="header" href="#ry.ryo3.dirs"><code>ry.ryo3.dirs</code></a></h2>
<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...
</code></pre>
<h2 id="ry.ryo3.errors"><a class="header" href="#ry.ryo3.errors"><code>ry.ryo3.errors</code></a></h2>
<pre><code class="language-python">class FeatureNotEnabledError(RuntimeError):
    """Raised when a feature is not enabled in the current build."""
</code></pre>
<h2 id="ry.ryo3.JSON"><a class="header" href="#ry.ryo3.JSON"><code>ry.ryo3.JSON</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.JSON"""

import typing as t

from ry._types import Buffer, Unpack
from ry.ryo3._bytes import Bytes
from ry.ryo3._jiter import JsonParseKwargs, JsonValue


def minify(data: Buffer) -&gt; Bytes:
    """Return minified json data (remove whitespace, newlines)

    Args:
        data: The JSON data to minify.

    Returns:
        Minified JSON data as a `Bytes` object.

    Examples:
        &gt;&gt;&gt; import json as pyjson
        &gt;&gt;&gt; from ry.ryo3 import JSON
        &gt;&gt;&gt; data = {"key": "value", "number": 123, "bool": True}
        &gt;&gt;&gt; json_str = pyjson.dumps(data, indent=2)
        &gt;&gt;&gt; print(json_str)
        {
          "key": "value",
          "number": 123,
          "bool": true
        }
        &gt;&gt;&gt; bytes(JSON.minify(json_str))
        b'{"key":"value","number":123,"bool":true}'

    """


def fmt(data: Buffer) -&gt; Bytes:
    """Return minified json data (remove whitespace, newlines)

    Args:
        data: The JSON data to minify.

    Returns:
        Minified JSON data as a `Bytes` object.

    Examples:
        &gt;&gt;&gt; import json as pyjson
        &gt;&gt;&gt; from ry.ryo3 import JSON
        &gt;&gt;&gt; data = {"key": "value", "number": 123, "bool": True}
        &gt;&gt;&gt; json_str = pyjson.dumps(data, indent=2)
        &gt;&gt;&gt; print(json_str)
        {
          "key": "value",
          "number": 123,
          "bool": true
        }
        &gt;&gt;&gt; bytes(JSON.fmt(json_str)).decode()
        '{\n  "key": "value",\n  "number": 123,\n  "bool": true\n}'
        &gt;&gt;&gt; print(bytes(JSON.fmt(json_str)).decode())
        {
          "key": "value",
          "number": 123,
          "bool": true
        }

    """


@t.overload
def stringify(
    data: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[True],
) -&gt; bytes: ...
@t.overload
def stringify(
    data: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[False] = False,
) -&gt; Bytes: ...
@t.overload
def dumps(
    data: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[True],
) -&gt; bytes: ...
@t.overload
def dumps(
    data: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[False] = False,
) -&gt; Bytes: ...
def loads(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def cache_clear() -&gt; None: ...
def cache_usage() -&gt; int: ...


# under construction
def stringify_unsafe(data: t.Any) -&gt; Bytes: ...
</code></pre>
<h2 id="ry.ryo3.orjson"><a class="header" href="#ry.ryo3.orjson"><code>ry.ryo3.orjson</code></a></h2>
<pre><code class="language-python">"""orjson + ry types

orjson-types: https://github.com/ijl/orjson/blob/master/pysrc/orjson/__init__.pyi
"""

import typing as t

import orjson


def orjson_default(obj: t.Any) -&gt; orjson.Fragment:
    """Fn to be used with `orjson.dumps` to serialize ry-compatible types

    Example:
        &gt;&gt;&gt; import orjson
        &gt;&gt;&gt; from ry import orjson_default, Date
        &gt;&gt;&gt; data = {"key": "value", "date": Date(2023, 10, 1)}
        &gt;&gt;&gt; orjson.dumps(data, default=orjson_default)
        b'{"key":"value","date":"2023-10-01"}'

    """
</code></pre>
<h2 id="ry.ryo3.sh"><a class="header" href="#ry.ryo3.sh"><code>ry.ryo3.sh</code></a></h2>
<pre><code class="language-python">import typing as t
from os import PathLike

from ry.ryo3._fspath import FsPath


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: str | PathLike[str]) -&gt; None: ...
@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[False] = False,
) -&gt; list[str]:
    """List directory contents - returns list of strings"""


@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[True],
) -&gt; list[FsPath]:
    """List directory contents - returns list of FsPath objects"""


def mkdir(path: str | PathLike[str]) -&gt; None: ...
</code></pre>
<h2 id="ry.ryo3.ulid"><a class="header" href="#ry.ryo3.ulid"><code>ry.ryo3.ulid</code></a></h2>
<pre><code class="language-python">import builtins
import datetime as pydt
import uuid
from collections.abc import Callable as Callable
from typing import Any

from pydantic import GetCoreSchemaHandler as GetCoreSchemaHandler
from pydantic import (
    ValidatorFunctionWrapHandler as ValidatorFunctionWrapHandler,
)
from pydantic_core import CoreSchema as CoreSchema


class ULID:
    def __init__(self, value: builtins.bytes | str | None = None) -&gt; None: ...

    # ----------------
    # INSTANCE METHODS
    # ----------------
    def to_uuid(self) -&gt; uuid.UUID: ...
    def to_uuid4(self) -&gt; uuid.UUID: ...

    # ----------
    # PROPERTIES
    # ----------
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def timestamp(self) -&gt; float: ...
    @property
    def datetime(self) -&gt; pydt.datetime: ...
    @property
    def hex(self) -&gt; str: ...

    # -------------
    # CLASS METHODS
    # -------------
    @classmethod
    def from_datetime(cls, value: pydt.datetime) -&gt; ULID: ...
    @classmethod
    def from_timestamp(cls, value: float) -&gt; ULID: ...
    @classmethod
    def from_uuid(cls, value: uuid.UUID) -&gt; ULID: ...
    @classmethod
    def from_bytes(cls, bytes_: builtins.bytes) -&gt; ULID: ...
    @classmethod
    def from_hex(cls, value: str) -&gt; ULID: ...
    @classmethod
    def from_str(cls, string: str) -&gt; ULID: ...
    @classmethod
    def from_int(cls, value: int) -&gt; ULID: ...
    @classmethod
    def parse(cls, value: Any) -&gt; ULID: ...

    # --------
    # PYDANTIC
    # --------
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source: Any, handler: GetCoreSchemaHandler
    ) -&gt; CoreSchema: ...
    def __lt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __le__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __ge__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __int__(self) -&gt; int: ...

    # -------
    # DUNDERS
    # -------
    def __bytes__(self) -&gt; builtins.bytes: ...
</code></pre>
<h2 id="ry.ryo3.uuid"><a class="header" href="#ry.ryo3.uuid"><code>ry.ryo3.uuid</code></a></h2>
<pre><code class="language-python">"""ryo3-uuid types

based on typeshed types for python's builtin uuid module

REF: https://github.com/python/typeshed/blob/main/stdlib/uuid.pyi
"""

import builtins
import uuid as pyuuid
from enum import Enum
from typing import Any, TypeAlias

from ry._types import Buffer

_FieldsType: TypeAlias = tuple[int, int, int, int, int, int]


class SafeUUID(Enum):
    safe = 0
    unsafe = -1
    unknown = None


class UUID:
    NAMESPACE_DNS: UUID
    NAMESPACE_URL: UUID
    NAMESPACE_OID: UUID
    NAMESPACE_X500: UUID

    def __init__(
        self,
        hex: str | None = None,  # noqa: A002
        bytes: builtins.bytes | None = None,  # noqa: A002
        bytes_le: builtins.bytes | None = None,
        fields: _FieldsType | None = None,
        int: builtins.int | None = None,  # noqa: A002
        version: builtins.int | None = None,
        *,
        is_safe: SafeUUID = ...,
    ) -&gt; None: ...
    @property
    def is_safe(self) -&gt; SafeUUID: ...
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def bytes_le(self) -&gt; builtins.bytes: ...
    @property
    def clock_seq(self) -&gt; builtins.int: ...
    @property
    def clock_seq_hi_variant(self) -&gt; builtins.int: ...
    @property
    def clock_seq_low(self) -&gt; builtins.int: ...
    @property
    def fields(self) -&gt; _FieldsType: ...
    @property
    def hex(self) -&gt; str: ...
    @property
    def int(self) -&gt; builtins.int: ...
    @property
    def node(self) -&gt; builtins.int: ...
    @property
    def time(self) -&gt; builtins.int: ...
    @property
    def time_hi_version(self) -&gt; builtins.int: ...
    @property
    def time_low(self) -&gt; builtins.int: ...
    @property
    def time_mid(self) -&gt; builtins.int: ...
    @property
    def urn(self) -&gt; str: ...
    @property
    def variant(self) -&gt; str: ...
    @property
    def version(self) -&gt; builtins.int | None: ...
    def to_py(self) -&gt; pyuuid.UUID: ...
    def __lt__(self, other: UUID) -&gt; bool: ...
    def __le__(self, other: UUID) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: UUID) -&gt; bool: ...
    def __ge__(self, other: UUID) -&gt; bool: ...
    def __hash__(self) -&gt; builtins.int: ...
    def __int__(self) -&gt; builtins.int: ...


def getnode() -&gt; builtins.int: ...
def uuid1(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid2(*args: Any, **kwargs: Any) -&gt; UUID: ...
def uuid3(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid4() -&gt; UUID: ...
def uuid5(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid6(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid7(timestamp: int | None = None) -&gt; UUID: ...
def uuid8(data: Buffer) -&gt; UUID: ...


NAMESPACE_DNS: UUID
NAMESPACE_URL: UUID
NAMESPACE_OID: UUID
NAMESPACE_X500: UUID
RESERVED_NCS: str
RFC_4122: str
RESERVED_MICROSOFT: str
RESERVED_FUTURE: str
</code></pre>
<h2 id="ry.ryo3.xxhash"><a class="header" href="#ry.ryo3.xxhash"><code>ry.ryo3.xxhash</code></a></h2>
<pre><code class="language-python">import typing as t

from ry._types import Buffer


@t.final
class xxh32:  # noqa: N801
    name: t.Literal["xxh32"]
    digest_size: t.Literal[4]
    block_size: t.Literal[16]

    def __init__(
        self, data: Buffer = ..., *, seed: int | None = ...
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...
    @staticmethod
    def oneshot(data: Buffer, *, seed: int = 0) -&gt; int: ...


@t.final
class xxh64:  # noqa: N801
    name: t.Literal["xxh64"]
    digest_size: t.Literal[8]
    block_size: t.Literal[32]

    def __init__(
        self, data: Buffer | None = None, *, seed: int | None = ...
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...
    @staticmethod
    def oneshot(data: Buffer, *, seed: int = 0) -&gt; int: ...


@t.final
class xxh3_64:  # noqa: N801
    name: t.Literal["xxh3_64"]
    digest_size: t.Literal[8]
    block_size: t.Literal[32]

    def __init__(
        self,
        data: Buffer = ...,
        *,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def digest128(self) -&gt; bytes: ...
    def hexdigest128(self) -&gt; str: ...
    def intdigest128(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self) -&gt; None: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, seed: int = 0, secret: bytes | None = None
    ) -&gt; int: ...


@t.final
class xxh3_128:  # noqa: N801
    name: t.Literal["xxh3_128"]
    digest_size: t.Literal[16]
    block_size: t.Literal[64]

    def __init__(
        self,
        data: Buffer = ...,
        *,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def digest128(self) -&gt; bytes: ...
    def hexdigest128(self) -&gt; str: ...
    def intdigest128(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self) -&gt; None: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, seed: int = 0, secret: bytes | None = None
    ) -&gt; int: ...


xxh128 = xxh3_128

# -----------------------------------------------------------------------------
# ONE-SHOT FUNCTIONS
# -----------------------------------------------------------------------------


# xxh32
def xxh32_digest(data: Buffer, *, seed: int | None = None) -&gt; bytes: ...
def xxh32_hexdigest(data: Buffer, *, seed: int | None = None) -&gt; str: ...
def xxh32_intdigest(data: Buffer, *, seed: int | None = None) -&gt; int: ...


# xxh64
def xxh64_digest(data: Buffer, *, seed: int | None = None) -&gt; bytes: ...
def xxh64_hexdigest(data: Buffer, *, seed: int | None = None) -&gt; str: ...
def xxh64_intdigest(data: Buffer, *, seed: int | None = None) -&gt; int: ...


# xxh128
def xxh128_digest(data: Buffer, *, seed: int | None = None) -&gt; bytes: ...
def xxh128_hexdigest(data: Buffer, *, seed: int | None = None) -&gt; str: ...
def xxh128_intdigest(data: Buffer, *, seed: int | None = None) -&gt; int: ...


# xxh3
def xxh3_64_digest(data: Buffer, *, seed: int | None = None) -&gt; bytes: ...
def xxh3_64_intdigest(data: Buffer, *, seed: int | None = None) -&gt; int: ...
def xxh3_64_hexdigest(data: Buffer, *, seed: int | None = None) -&gt; str: ...


# xxh128
def xxh3_128_digest(data: Buffer, *, seed: int | None = None) -&gt; bytes: ...
def xxh3_128_intdigest(data: Buffer, *, seed: int | None = None) -&gt; int: ...
def xxh3_128_hexdigest(data: Buffer, *, seed: int | None = None) -&gt; str: ...
</code></pre>
<h2 id="ry.ryo3.zstd"><a class="header" href="#ry.ryo3.zstd"><code>ry.ryo3.zstd</code></a></h2>
<pre><code class="language-python">from ry import Bytes
from ry._types import Buffer

__zstd_version__: str  # zstd version string ("1.5.7" as of 2025-03-14)
BLOCKSIZELOG_MAX: int
BLOCKSIZE_MAX: int
CLEVEL_DEFAULT: int  # default=3 (as of 2025-03-14)
CONTENTSIZE_ERROR: int
CONTENTSIZE_UNKNOWN: int
MAGICNUMBER: int
MAGIC_DICTIONARY: int
MAGIC_SKIPPABLE_MASK: int
MAGIC_SKIPPABLE_START: int
VERSION_MAJOR: int
VERSION_MINOR: int
VERSION_NUMBER: int
VERSION_RELEASE: int


# =============================================================================
# PYFUNCTIONS
# =============================================================================
# __COMPRESSION__
def compress(data: Buffer, level: int = 3) -&gt; Bytes: ...
def encode(data: Buffer, level: int = 3) -&gt; Bytes: ...
def zstd(data: Buffer, level: int = 3) -&gt; Bytes: ...


# __DECOMPRESSION__
def decode(data: Buffer) -&gt; Bytes: ...
def decompress(data: Buffer) -&gt; Bytes: ...
def unzstd(data: Buffer) -&gt; Bytes: ...


# __MAGIC__
def is_zstd(data: Buffer) -&gt; bool: ...
</code></pre>
<h2 id="ry.dirs"><a class="header" href="#ry.dirs"><code>ry.dirs</code></a></h2>
<pre><code class="language-python">from ry.ryo3.dirs import audio as audio
from ry.ryo3.dirs import audio_dir as audio_dir
from ry.ryo3.dirs import cache as cache
from ry.ryo3.dirs import cache_dir as cache_dir
from ry.ryo3.dirs import config as config
from ry.ryo3.dirs import config_dir as config_dir
from ry.ryo3.dirs import config_local as config_local
from ry.ryo3.dirs import config_local_dir as config_local_dir
from ry.ryo3.dirs import data as data
from ry.ryo3.dirs import data_dir as data_dir
from ry.ryo3.dirs import data_local as data_local
from ry.ryo3.dirs import data_local_dir as data_local_dir
from ry.ryo3.dirs import desktop as desktop
from ry.ryo3.dirs import desktop_dir as desktop_dir
from ry.ryo3.dirs import document as document
from ry.ryo3.dirs import document_dir as document_dir
from ry.ryo3.dirs import download as download
from ry.ryo3.dirs import download_dir as download_dir
from ry.ryo3.dirs import executable as executable
from ry.ryo3.dirs import executable_dir as executable_dir
from ry.ryo3.dirs import font as font
from ry.ryo3.dirs import font_dir as font_dir
from ry.ryo3.dirs import home as home
from ry.ryo3.dirs import home_dir as home_dir
from ry.ryo3.dirs import picture as picture
from ry.ryo3.dirs import picture_dir as picture_dir
from ry.ryo3.dirs import preference as preference
from ry.ryo3.dirs import preference_dir as preference_dir
from ry.ryo3.dirs import public as public
from ry.ryo3.dirs import public_dir as public_dir
from ry.ryo3.dirs import runtime as runtime
from ry.ryo3.dirs import runtime_dir as runtime_dir
from ry.ryo3.dirs import state as state
from ry.ryo3.dirs import state_dir as state_dir
from ry.ryo3.dirs import template as template
from ry.ryo3.dirs import template_dir as template_dir
from ry.ryo3.dirs import video as video
from ry.ryo3.dirs import video_dir as video_dir

__all__ = (
    "audio",
    "audio_dir",
    "cache",
    "cache_dir",
    "config",
    "config_dir",
    "config_local",
    "config_local_dir",
    "data",
    "data_dir",
    "data_local",
    "data_local_dir",
    "desktop",
    "desktop_dir",
    "document",
    "document_dir",
    "download",
    "download_dir",
    "executable",
    "executable_dir",
    "font",
    "font_dir",
    "home",
    "home_dir",
    "picture",
    "picture_dir",
    "preference",
    "preference_dir",
    "public",
    "public_dir",
    "runtime",
    "runtime_dir",
    "state",
    "state_dir",
    "template",
    "template_dir",
    "video",
    "video_dir",
)
</code></pre>
<h2 id="ry.JSON"><a class="header" href="#ry.JSON"><code>ry.JSON</code></a></h2>
<pre><code class="language-python">"""ry.JSON"""

from ry.ryo3.JSON import cache_clear as cache_clear
from ry.ryo3.JSON import cache_usage as cache_usage
from ry.ryo3.JSON import dumps as dumps
from ry.ryo3.JSON import loads as loads
from ry.ryo3.JSON import parse as parse
from ry.ryo3.JSON import stringify as stringify

__all__ = (
    "cache_clear",
    "cache_usage",
    "dumps",
    "loads",
    "parse",
    "stringify",
)
</code></pre>
<h2 id="ry.ulid"><a class="header" href="#ry.ulid"><code>ry.ulid</code></a></h2>
<pre><code class="language-python">from ry.ryo3.ulid import ULID

__all__ = ("ULID",)
</code></pre>
<h2 id="ry.uuid"><a class="header" href="#ry.uuid"><code>ry.uuid</code></a></h2>
<pre><code class="language-python">from ry.ryo3.uuid import (
    NAMESPACE_DNS,
    NAMESPACE_OID,
    NAMESPACE_URL,
    NAMESPACE_X500,
    RESERVED_FUTURE,
    RESERVED_MICROSOFT,
    RESERVED_NCS,
    RFC_4122,
    UUID,
    getnode,
    uuid1,
    uuid2,
    uuid3,
    uuid4,
    uuid5,
    uuid6,
    uuid7,
    uuid8,
)

__all__ = (
    "NAMESPACE_DNS",
    "NAMESPACE_OID",
    "NAMESPACE_URL",
    "NAMESPACE_X500",
    "RESERVED_FUTURE",
    "RESERVED_MICROSOFT",
    "RESERVED_NCS",
    "RFC_4122",
    "UUID",
    "getnode",
    "uuid1",
    "uuid2",
    "uuid3",
    "uuid4",
    "uuid5",
    "uuid6",
    "uuid7",
    "uuid8",
)
</code></pre>
<h2 id="ry.xxhash"><a class="header" href="#ry.xxhash"><code>ry.xxhash</code></a></h2>
<pre><code class="language-python">from ry.ryo3.xxhash import xxh3_64 as xxh3_64
from ry.ryo3.xxhash import xxh3_64_digest as xxh3_64_digest
from ry.ryo3.xxhash import xxh3_64_hexdigest as xxh3_64_hexdigest
from ry.ryo3.xxhash import xxh3_64_intdigest as xxh3_64_intdigest
from ry.ryo3.xxhash import xxh3_128 as xxh3_128
from ry.ryo3.xxhash import xxh3_128_digest as xxh3_128_digest
from ry.ryo3.xxhash import xxh3_128_hexdigest as xxh3_128_hexdigest
from ry.ryo3.xxhash import xxh3_128_intdigest as xxh3_128_intdigest
from ry.ryo3.xxhash import xxh32 as xxh32
from ry.ryo3.xxhash import xxh32_digest as xxh32_digest
from ry.ryo3.xxhash import xxh32_hexdigest as xxh32_hexdigest
from ry.ryo3.xxhash import xxh32_intdigest as xxh32_intdigest
from ry.ryo3.xxhash import xxh64 as xxh64
from ry.ryo3.xxhash import xxh64_digest as xxh64_digest
from ry.ryo3.xxhash import xxh64_hexdigest as xxh64_hexdigest
from ry.ryo3.xxhash import xxh64_intdigest as xxh64_intdigest
from ry.ryo3.xxhash import xxh128 as xxh128
from ry.ryo3.xxhash import xxh128_digest as xxh128_digest
from ry.ryo3.xxhash import xxh128_hexdigest as xxh128_hexdigest
from ry.ryo3.xxhash import xxh128_intdigest as xxh128_intdigest

__all__ = (
    "xxh3_64",
    "xxh3_64_digest",
    "xxh3_64_hexdigest",
    "xxh3_64_intdigest",
    "xxh3_128",
    "xxh3_128_digest",
    "xxh3_128_hexdigest",
    "xxh3_128_intdigest",
    "xxh32",
    "xxh32_digest",
    "xxh32_hexdigest",
    "xxh32_intdigest",
    "xxh64",
    "xxh64_digest",
    "xxh64_hexdigest",
    "xxh64_intdigest",
    "xxh128",
    "xxh128_digest",
    "xxh128_hexdigest",
    "xxh128_intdigest",
)
</code></pre>
<h2 id="ry.zstd"><a class="header" href="#ry.zstd"><code>ry.zstd</code></a></h2>
<pre><code class="language-python">from ry.ryo3.zstd import BLOCKSIZE_MAX as BLOCKSIZE_MAX
from ry.ryo3.zstd import BLOCKSIZELOG_MAX as BLOCKSIZELOG_MAX
from ry.ryo3.zstd import CLEVEL_DEFAULT as CLEVEL_DEFAULT
from ry.ryo3.zstd import CONTENTSIZE_ERROR as CONTENTSIZE_ERROR
from ry.ryo3.zstd import CONTENTSIZE_UNKNOWN as CONTENTSIZE_UNKNOWN
from ry.ryo3.zstd import MAGIC_DICTIONARY as MAGIC_DICTIONARY
from ry.ryo3.zstd import MAGIC_SKIPPABLE_MASK as MAGIC_SKIPPABLE_MASK
from ry.ryo3.zstd import MAGIC_SKIPPABLE_START as MAGIC_SKIPPABLE_START
from ry.ryo3.zstd import MAGICNUMBER as MAGICNUMBER
from ry.ryo3.zstd import VERSION_MAJOR as VERSION_MAJOR
from ry.ryo3.zstd import VERSION_MINOR as VERSION_MINOR
from ry.ryo3.zstd import VERSION_NUMBER as VERSION_NUMBER
from ry.ryo3.zstd import VERSION_RELEASE as VERSION_RELEASE
from ry.ryo3.zstd import __zstd_version__ as __zstd_version__
from ry.ryo3.zstd import compress as compress
from ry.ryo3.zstd import decode as decode
from ry.ryo3.zstd import decompress as decompress
from ry.ryo3.zstd import is_zstd as is_zstd
from ry.ryo3.zstd import unzstd as unzstd

__all__ = (
    "BLOCKSIZELOG_MAX",
    "BLOCKSIZE_MAX",
    "CLEVEL_DEFAULT",
    "CONTENTSIZE_ERROR",
    "CONTENTSIZE_UNKNOWN",
    "MAGICNUMBER",
    "MAGIC_DICTIONARY",
    "MAGIC_SKIPPABLE_MASK",
    "MAGIC_SKIPPABLE_START",
    "VERSION_MAJOR",
    "VERSION_MINOR",
    "VERSION_NUMBER",
    "VERSION_RELEASE",
    "__zstd_version__",
    "compress",
    "decode",
    "decompress",
    "is_zstd",
    "unzstd",
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="food-4-thought"><a class="header" href="#food-4-thought">food-4-thought</a></h1>
<p>thinking out loud…</p>
<h2 id="staticmethod-vs-classmethod-2025-08-28"><a class="header" href="#staticmethod-vs-classmethod-2025-08-28">staticmethod vs classmethod [2025-08-28]</a></h2>
<p>Nowhere in ry are any of the <code>classmethod</code> functions actually used as classmethods, they are effectively staticmethods; they don’t access the class or instance in any way.
Classes in <code>ry</code> do not (for the most part) support being subclassed.
Benchmarking shows that <code>staticmethod</code> is slightly faster than <code>classmethod</code>,
sooooo all classmethods will be removed, but added back in if needed later…</p>
<p>Benchmarking code:</p>
<pre><code class="language-python">from __future__ import annotations

import json
from pathlib import Path
from typing import TYPE_CHECKING

import pytest

import ry as ry

if TYPE_CHECKING:
    from pytest_benchmark.fixture import BenchmarkFixture


def test_classmethod(benchmark: BenchmarkFixture):
    # this is the current (as of 2025-08-28) `#[staticmethod]` parse function
    benchmark(ry.Date.parse, "2023-03-15")


def test_staticmethod(benchmark: BenchmarkFixture):
    # This is a crudely copy-pasted version using `#[staticmethod]` instead
    benchmark(ry.Date.parse2, "2023-03-15")
</code></pre>
<p>Benchmark results:</p>
<pre><code>---------------------------------------------------------------------------------------- benchmark: 2 tests ---------------------------------------------------------------------------------------
Name (time in ns)         Min                    Max                Mean              StdDev              Median               IQR             Outliers  OPS (Mops/s)            Rounds  Iterations
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_staticmethod     57.5000 (1.0)       2,290.0000 (1.0)       63.4931 (1.0)       16.2941 (1.0)       62.0000 (1.0)      1.5000 (824.63)  1048;11454       15.7497 (1.0)      100000         200
test_classmethod      99.9989 (1.74)     29,200.0004 (12.75)    128.8420 (2.03)     146.9563 (9.02)     100.0008 (1.61)     0.0018 (1.0)      911;24504        7.7614 (0.49)     100000           1
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Legend:
  Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.
  OPS: Operations Per Second, computed as 1 / Mean
</code></pre>
<hr />
<h2 id="fugue-state-jesse-2025-08-18"><a class="header" href="#fugue-state-jesse-2025-08-18">fugue-state-jesse [2025-08-18]</a></h2>
<p>The most sophisticated rust code in this repository was written by
<code>fugue-state-jesse</code> (aka FSJ), not me (<code>normal-jesse</code>) and not an AI/LLM.
<code>fugue-state-jesse</code> only shows up at random about 1-2 times a week and
seemingly has a vastly better understanding of rust and rust-macro-rules than I
do.</p>
<p>Throughout the repository I (normal-jesse) will sometimes leave notes to
<code>fugue-state-jesse</code> with the hope that he might do what I ask, but he tends to
do his own thing.</p>
<hr />
<h2 id="rydev"><a class="header" href="#rydev"><code>ry.dev</code></a></h2>
<p>For people who find <code>ry.dev</code> it is a module that exports all the things in ry as
well as can be used as a repl; <code>python -m ry.dev</code> will start a repl (with
ipython if installed else python-repl) with all of ry already imported. I
(jesse) use this super often for testing things out.</p>
<hr />
<h2 id="string-bridge"><a class="header" href="#string-bridge">string-bridge?</a></h2>
<p>The <code>jiter</code> crate uses a string-cache to store python-strings to avoid the
overhead of converting strings to python strings. A global string bridge and/or
caching setup for other types of structs that often convert to strings might be
worth considering?</p>
<hr />
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Coming up with names is hard… I (jesse) want to strike a balance between being
clear but also close to the wrapped libraries…</p>
<ul>
<li>Should jiff’s <code>Zoned</code> be <code>Zoned</code> in python? or <code>ZonedDateTime</code>? (currently
<code>ZonedDateTime</code>)</li>
<li>Should jiff’s <code>Span</code> be <code>Span</code> in python? or <code>TimeSpan</code>? (currently
<code>TimeSpan</code>)</li>
<li>Should reqwest’s <code>Client</code> be <code>Client</code> in python? or <code>HttpClient</code>? (currently
<code>HttpClient</code>)</li>
</ul>
<hr />
<h2 id="flat-nested-submodules"><a class="header" href="#flat-nested-submodules">Flat? Nested submodules?</a></h2>
<p>I like flat more, but nesting submodules might be preferable for some people and
would allow for more flexibility in naming…</p>
<p>pros &amp; cons:</p>
<ul>
<li>flat:
<ul>
<li>pros:
<ul>
<li>easier to import</li>
<li>easier to work on</li>
<li>no need to remember where things are</li>
<li>type annotations are easier to setup/dist</li>
</ul>
</li>
<li>cons:
<ul>
<li>name conflicts</li>
<li>type annotations are harder to read bc of huge file</li>
<li>harder to remember where things are</li>
</ul>
</li>
</ul>
</li>
<li>nested:
<ul>
<li>pros:
<ul>
<li>no name conflicts</li>
<li>easier to remember where things are</li>
<li>type annotations are easier to read</li>
<li>importing <code>ry.jiff</code> (or <code>ry.ryo3.jiff</code> tbd) is more explicitly the <code>jiff</code>
wrapper(s)</li>
</ul>
</li>
<li>cons:
<ul>
<li>Don’t know how type annotations should be laid out… if there is a
submodule called <code>ry.ryo3.reqwest</code>, do you import from <code>ry.ryo3.reqwest</code>
or do we reexport from <code>ry.reqwest</code>? Then were doe the type-annotations
live and how are they laid out without having to duplicate/shim them?</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="pypi-size-limit"><a class="header" href="#pypi-size-limit">pypi size limit</a></h2>
<p>The pypi project size limit of 10gb was reached. I (jesse) won’t request a limit
raise until the package is more stable and hits some sort of <code>v0.1.x</code>, SOOOOOO
for now I will be:</p>
<ul>
<li>deleting older versions of ry from pypi as needed</li>
<li>update the release gh-action to push the built wheels to the releases page so
they are not lost into the ether…</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jiff"><a class="header" href="#jiff">jiff</a></h1>
<p>docs.rs: <a href="https://docs.rs/jiff">https://docs.rs/jiff</a></p>
<p>crates: <a href="https://crates.io/crates/jiff">https://crates.io/crates/jiff</a></p>
<hr />
<p>The <code>jiff</code> crate has a super excellent API that is very ergonomic to use and
<code>ry</code> provides a nearly complete wrapper around it.</p>
<p>A good amount of time, and a greater amount of thought has gone into balancing
the <code>jiff</code> python api to be both ergonomic and performant.</p>
<h2 id="python-conversions"><a class="header" href="#python-conversions">python-conversions</a></h2>
<p>The structs under <code>ryo3-jiff</code> are convertible to/from python’s <code>datetime.*</code>
types and the conversions are pretty well tested (ty hypothesis).</p>
<h3 id="pyo3-v0240--jiff-02"><a class="header" href="#pyo3-v0240--jiff-02"><code>pyo3-v0.24.0</code> &amp; <code>jiff-02</code></a></h3>
<p>The conversions to/from python <code>datetime.*</code> types were originally hand rolled (
by me (jesse)) using the ‘new-type’ pattern, HOWEVER <code>pyo3-v0.24.0</code> provides
conversions via the <code>jiff-02</code> feature flag, which is what is used now.</p>
<p><code>ry-v0.0.37</code> will be the last version with the mostly hand rolled conversions.</p>
<p><code>ry-v0.0.38</code> will be the first version with the <code>jiff-02</code> feature flag.</p>
<p>As of 2025-03-12 <code>pyo3</code> does not seem to support converting <code>Span</code> -&gt;
<code>datetime.timedelta</code>, so that is still hand rolled.</p>
<hr />
<h2 id="ry-vs-whenever"><a class="header" href="#ry-vs-whenever"><code>ry</code> vs <code>whenever</code></a></h2>
<p>There is another library called
<a href="https://github.com/ariebovenberg/whenever"><code>whenever</code></a> that provides a similar
datetime library to that of <code>ryo3-jiff</code> (both <code>jiff</code> and <code>whenever</code> are based on
the <a href="https://tc39.es/proposal-temporal/docs/">temporal</a> API).</p>
<p>No formal benchmarks between <code>ry</code> and <code>whenever</code> have been done, but I have
copy-pasta-ed some of the benchmarks from the <code>whenever</code> repo and translated
them to <code>ry</code> and the results were pretty similar; <code>whenever</code> is faster for some
things, <code>ry</code> is faster for others, but both are wildly more performant than
python’s built in <code>datetime</code> module and <code>pendulum</code> – differences in performance
are almost all measured in nanoseconds.</p>
<p>Big shoutout to “Mr. Dutch Airlines” guy
(<a href="https://github.com/ariebovenberg">@ariebovenberg</a>) who wrote <code>whenever</code>! Love
the name of the library too!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
