<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ryo3</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ryo3</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jessekrubin/ry" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="readme"><a class="header" href="#readme">README</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">DEVELOPMENT</a></h1>
<p><strong>OPEN TO PRS!</strong></p>
<h2 id="style-guide"><a class="header" href="#style-guide">style guide</a></h2>
<ul>
<li><strong>NO UNWRAPPING</strong></li>
<li><strong>NO PANICS</strong></li>
<li><strong>USE CLIPPY</strong> <code>just clippy</code> or <code>just ci</code></li>
<li><strong>USE RUSTFMT AND RUFF</strong> <code>just fmt</code></li>
<li>avoid using macros as they are not as easy to reason about and/or debug, but feel free to say ‘yolo’</li>
<li>library style guide:
<ul>
<li>python objects/structs/classes defined in the library should be named either <code>Py&lt;CLASSNAME&gt;</code> or <code>Ry&lt;CLASSNAME&gt;</code> and
the prefix should be consistent throughout the library (eg <code>ryo3-jiff</code> uses <code>Ry</code> as the internal prefix to not
conflict with the <code>Py&lt;CLASSNAME&gt;</code> structs provided by <code>pyo3</code>)</li>
<li>if a <code>pyclass</code> or <code>pyfunction</code> is not mirroring a rust function prefer names that are puns but also
semi-descriptive (eg <code>Globsters</code> in <code>ryo3-globset</code>)</li>
<li>attempt to mirror the structure of the og library as much as possible</li>
<li>wrapper libraries should be of the form <code>ryo3-&lt;LIB_NAME&gt;</code> where <code>&lt;LIB_NAME&gt;</code> is the name of the library they</li>
<li>library directories should be <code>kebab-case</code> and should be <code>ryo3-&lt;LIB_NAME&gt;</code></li>
<li>MUST PROVIDE TYPE ANNOTATIONS</li>
</ul>
</li>
</ul>
<h2 id="creating-a-new-librarywrapper-thing"><a class="header" href="#creating-a-new-librarywrapper-thing">Creating a new library/wrapper-thing</a></h2>
<ul>
<li>copy the template library  <code>ryo3-quick-maths</code> library to your new library name</li>
<li>refer to the above style guide for naming conventions</li>
</ul>
<h2 id="tools"><a class="header" href="#tools">tools</a></h2>
<h3 id="python"><a class="header" href="#python">python</a></h3>
<ul>
<li>we use <code>maturin</code> for building the python wheels</li>
<li>we support <code>python-3.9+</code></li>
<li>we use <code>pytest</code> for testing as well as the following plugins:
<ul>
<li><code>pytest-benchmark</code></li>
<li><code>pytest-asyncio</code> (may switch to <code>anyio</code> in the future)</li>
<li><code>hypothesis</code></li>
</ul>
</li>
</ul>
<h3 id="just"><a class="header" href="#just">just</a></h3>
<p><strong><code>cargo install just</code></strong></p>
<ul>
<li>we use <code>just</code> for task running</li>
<li>to see all tasks run <code>just</code> or <code>just --list</code> (our default task echos the list of tasks)</li>
</ul>
<p>tasks as of 2024-12-03:</p>
<pre><code class="language-aiignore">Available recipes:
    dev            # dev run build + tests
    develop        # maturin develop
    cargo-test     # cargo test
    build          # build
    build-release  # build release
    dev-rel        # maturin develop release
    pytest         # run pytest
    pytestv        # run pytest (printing captured output)
    test           # run all test
    test-release   # test ry package
    bench          # benchmark ry python package
    ci             # ci rust checks
    cargo-fmt      # cargo format
    cargo-fmtc     # cargo format check
    sort-all-check # ruff check sorting of '__all__'
    sort-all       # ruff sort '__all__'
    ruff-fmt       # ruff format
    ruff-fmtc      # ruff format check
    black          # python format black
    fmtpy          # python format
    fmtcpy         # python format check
    justfilefmt    # justfile format
    justfilefmtc   # justfile format check
    fmt            # format
    fmtc           # format check
    ruff           # run ruff linter
    ruffix         # run ruff + fix
    clippy         # run clippy
    lint           # lint python and rust
    mypy           # run mypy type checker
    pyright        # run pyright
    pip-compile    # pip compile requirements
    gen            # generate code tasks
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<pre><code class="language-python">"""ry api ~ type annotations"""

import datetime as pydt
import typing as t
from os import PathLike

from ry._types.jiff import (
  JIFF_ROUND_MODE_STRING,
  JIFF_UNIT_STRING,
  DateTimeTypedDict,
  DateTypedDict,
  TimeSpanTypedDict,
  TimeTypedDict,
)

__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str

# ==============================================================================
# TYPE ALIASES
# ==============================================================================
JsonPrimitive = None | bool | int | float | str
JsonValue = (
  JsonPrimitive | dict[str, JsonPrimitive | JsonValue] | list[JsonPrimitive | JsonValue]
)

# ==============================================================================
# STD
# ==============================================================================


class Duration:
  def __init__(self, seconds: int, nanoseconds: int) -&gt; None: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def __ne__(self, other: object) -&gt; bool: ...
  def __lt__(self, other: object) -&gt; bool: ...
  def __le__(self, other: object) -&gt; bool: ...
  def __gt__(self, other: object) -&gt; bool: ...
  def __ge__(self, other: object) -&gt; bool: ...
  def __richcmp__(self, other: Duration | pydt.timedelta, op: int) -&gt; bool: ...
  def __str__(self) -&gt; str: ...
  @classmethod
  def from_pytimedelta(cls: type[Duration], td: pydt.timedelta) -&gt; Duration: ...
  def to_pytimedelta(self) -&gt; pydt.timedelta: ...
  @property
  def days(self) -&gt; int: ...
  @property
  def seconds(self) -&gt; int: ...
  @property
  def microseconds(self) -&gt; int: ...


# ==============================================================================
# RY03-CORE
# ==============================================================================


class FsPath:
  def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
  def __fspath__(self) -&gt; str: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def __ne__(self, other: object) -&gt; bool: ...
  def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
  def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
  def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
  def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
  def __truediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
  def __rtruediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
  def read_text(self) -&gt; str: ...
  def read_bytes(self) -&gt; bytes: ...
  def absolute(self) -&gt; FsPath: ...
  @property
  def parent(self) -&gt; FsPath: ...
  def write_text(self, data: str) -&gt; None: ...
  def write_bytes(self, data: bytes) -&gt; None: ...
  def joinpath(self, *paths: str) -&gt; FsPath: ...
  def is_dir(self) -&gt; bool: ...
  def is_file(self) -&gt; bool: ...
  def exists(self) -&gt; bool: ...
  def with_name(self, name: str) -&gt; FsPath: ...
  def with_suffix(self, suffix: str) -&gt; FsPath: ...
  @property
  def suffix(self) -&gt; str: ...
  @property
  def suffixes(self) -&gt; list[str]: ...
  def iterdir(self) -&gt; t.Iterator[FsPath]: ...
  def relative_to(self, other: PathLike[str] | str | FsPath) -&gt; FsPath: ...
  def as_posix(self) -&gt; str: ...

  # TODO
  @property
  def parents(self) -&gt; t.Sequence[t.Self]: ...
  @property
  def root(self) -&gt; str: ...
  def __bytes__(self) -&gt; bytes: ...
  def as_uri(self) -&gt; str: ...
  @property
  def parts(self) -&gt; tuple[str, ...]: ...
  @property
  def drive(self) -&gt; str: ...
  @property
  def anchor(self) -&gt; str: ...
  @property
  def name(self) -&gt; str: ...
  @property
  def stem(self) -&gt; str: ...


FsPathLike = str | FsPath | PathLike[str]


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: FsPathLike) -&gt; None: ...
def ls(path: FsPathLike | None = None) -&gt; list[FsPath]: ...
def quick_maths() -&gt; t.Literal[3]:
  """Performs quick-maths

  Implements the algorithm for performing "quick-maths" as described by
  Big Shaq in his PHD thesis, 2017, in which he states:

  &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

  Reference:
      https://youtu.be/3M_5oYU-IsU?t=60

  Example:
      &gt;&gt;&gt; result = quick_maths()
      &gt;&gt;&gt; assert result == 3

  NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
  """


# ==============================================================================
# SLEEP
# ==============================================================================
def sleep(seconds: float) -&gt; float: ...
async def sleep_async(seconds: float) -&gt; float: ...


# ==============================================================================
# FILESYSTEM
# ==============================================================================
def read_text(path: FsPathLike) -&gt; str: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def write_text(path: FsPathLike, data: str) -&gt; None: ...
def write_bytes(path: FsPathLike, data: bytes) -&gt; None: ...


# ==============================================================================
# SUBPROCESS (VERY MUCH WIP)
# ==============================================================================
def run(
  *args: str | list[str],
  capture_output: bool = True,
  input: bytes | None = None,
) -&gt; t.Any: ...


# ==============================================================================
# DEV
# ==============================================================================


def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...


# ------------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# ------------------------------------------------------------------------------
# ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~ LIBS ~
# ------------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# ------------------------------------------------------------------------------


# ==============================================================================
# WHICH
# ==============================================================================
def which(cmd: str, path: None | str = None) -&gt; str | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[str]: ...
def whicha(cmd: str, path: None | str = None) -&gt; list[str]:
  """Alias for which_all (may go away in the future)"""


# ==============================================================================
# HECK
# ==============================================================================


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...


# ==============================================================================
# GLOBSET
# ==============================================================================
class Glob:
  """globset::Glob wrapper"""

  def __init__(
    self,
    pattern: str,
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
  ) -&gt; None: ...
  def regex(self) -&gt; str: ...
  def is_match(self, path: str) -&gt; bool: ...
  def __call__(self, path: str) -&gt; bool: ...
  def __invert__(self) -&gt; Glob: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...


class GlobSet:
  """globset::GlobSet wrapper"""

  def __init__(
    self,
    patterns: list[str],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
  ) -&gt; None: ...
  def is_empty(self) -&gt; bool: ...
  def is_match(self, path: str) -&gt; bool: ...
  def matches(self, path: str) -&gt; list[int]: ...
  def __call__(self, path: str) -&gt; bool: ...
  def __invert__(self) -&gt; GlobSet: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...


class Globster:
  """Globster is a matcher with claws!

  Note: The north american `Globster` is similar to the european `Globset`
        but allows for negative patterns (prefixed with '!')

  """

  def __init__(
    self,
    patterns: list[str],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
  ) -&gt; None: ...
  def is_empty(self) -&gt; bool: ...
  def is_match(self, path: str) -&gt; bool: ...
  def __call__(self, path: str) -&gt; bool: ...
  def __invert__(self) -&gt; GlobSet: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...


def glob(
  pattern: str,
  /,
  *,
  case_insensitive: bool | None = None,
  literal_separator: bool | None = None,
  backslash_escape: bool | None = None,
) -&gt; Glob: ...
def globs(
  patterns: list[str],
  /,
  *,
  case_insensitive: bool | None = None,
  literal_separator: bool | None = None,
  backslash_escape: bool | None = None,
) -&gt; Globster: ...


# ==============================================================================
# WALKDIR
# ==============================================================================


class WalkdirGen:
  """walkdir::Walkdir iterable wrapper"""

  files: bool
  dirs: bool

  def __next__(self) -&gt; str: ...
  def __iter__(self) -&gt; t.Iterator[str]: ...


class FspathsGen:
  """walkdir iterable that yields FsPath objects"""

  files: bool
  dirs: bool

  def __next__(self) -&gt; FsPath: ...
  def __iter__(self) -&gt; t.Iterator[FsPath]: ...


def walkdir(
  path: FsPathLike | None = None,
  files: bool = True,
  dirs: bool = True,
  contents_first: bool = False,
  min_depth: int = 0,
  max_depth: int | None = None,
  follow_links: bool = False,
  same_file_system: bool = False,
) -&gt; WalkdirGen: ...
def fspaths(
  path: FsPathLike | None = None,
  files: bool = True,
  dirs: bool = True,
  contents_first: bool = False,
  min_depth: int = 0,
  max_depth: int | None = None,
  follow_links: bool = False,
  same_file_system: bool = False,
) -&gt; WalkdirGen: ...


# ==============================================================================
# SHLEX
# ==============================================================================
def shplit(s: str) -&gt; list[str]:
  """shlex::split wrapper much like python's stdlib shlex.split but faster"""
  ...


# ==============================================================================
# JSON
# ==============================================================================
def parse_json(
  data: bytes | str,
  /,
  *,
  allow_inf_nan: bool = True,
  cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
  partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"] = False,
  catch_duplicate_keys: bool = False,
  float_mode: t.Literal["float", "decimal", "lossless-float"] = "float",
) -&gt; JsonValue: ...
def parse_json_bytes(
  data: bytes,
  /,
  *,
  allow_inf_nan: bool = True,
  cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
  partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"] = False,
  catch_duplicate_keys: bool = False,
  float_mode: t.Literal["float", "decimal", "lossless-float"] = "float",
) -&gt; JsonValue: ...
def parse_json_str(
  data: str,
  /,
  *,
  allow_inf_nan: bool = True,
  cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
  partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"] = False,
  catch_duplicate_keys: bool = False,
  float_mode: t.Literal["float", "decimal", "lossless-float"] = "float",
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...


# ==============================================================================
# FORMATTING
# ==============================================================================
def fmt_nbytes(nbytes: int) -&gt; str: ...


# ==============================================================================
# FNV
# ==============================================================================
class FnvHasher:
  name: t.Literal["fnv1a"]

  def __init__(self, input: bytes | None = None) -&gt; None: ...
  def update(self, input: bytes) -&gt; None: ...
  def digest(self) -&gt; int: ...
  def hexdigest(self) -&gt; str: ...
  def copy(self) -&gt; FnvHasher: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...


def fnv1a(input: bytes) -&gt; FnvHasher: ...


# ==============================================================================
# DEV
# ==============================================================================
def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...


# ==============================================================================
# BROTLI
# ==============================================================================
def brotli_encode(
  input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(input: bytes) -&gt; bytes: ...
def brotli(input: bytes, quality: int = 11, magic_number: bool = False) -&gt; bytes:
  """Alias for brotli_encode"""


# ==============================================================================
# BZIP2
# ==============================================================================
def bzip2_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def bzip2_decode(input: bytes) -&gt; bytes: ...
def bzip2(input: bytes, quality: int = 9) -&gt; bytes:
  """Alias for bzip2_encode"""


# ==============================================================================
# GZIP
# ==============================================================================
def gzip_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def gzip_decode(input: bytes) -&gt; bytes: ...
def gzip(input: bytes, quality: int = 9) -&gt; bytes:
  """Alias for gzip_encode"""


def gunzip(input: bytes) -&gt; bytes:
  """Alias for gzip_decode"""


# ==============================================================================
# ZSTD
# ==============================================================================
def zstd_encode(input: bytes, level: int = 3) -&gt; bytes: ...
def zstd(input: bytes, level: int = 3) -&gt; bytes:
  """Alias for zstd_encode"""


def zstd_decode(input: bytes) -&gt; bytes: ...


# ==============================================================================
# XXHASH
# ==============================================================================
@t.final
class Xxh32:
  name: t.Literal["xxh32"]

  def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
  def update(self, input: bytes) -&gt; None: ...
  def digest(self) -&gt; bytes: ...
  def hexdigest(self) -&gt; str: ...
  def intdigest(self) -&gt; int: ...
  def copy(self) -&gt; Xxh32: ...
  def reset(self, seed: int | None = ...) -&gt; None: ...
  @property
  def seed(self) -&gt; int: ...


@t.final
class Xxh64:
  name: t.Literal["xxh64"]

  def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
  def update(self, input: bytes) -&gt; None: ...
  def digest(self) -&gt; bytes: ...
  def hexdigest(self) -&gt; str: ...
  def intdigest(self) -&gt; int: ...
  def copy(self) -&gt; Xxh32: ...
  def reset(self, seed: int | None = ...) -&gt; None: ...
  @property
  def seed(self) -&gt; int: ...


@t.final
class Xxh3:
  name: t.Literal["xxh3"]

  def __init__(
    self, input: bytes = ..., seed: int | None = ..., secret: bytes | None = ...
  ) -&gt; None: ...
  def update(self, input: bytes) -&gt; None: ...
  def digest(self) -&gt; bytes: ...
  def hexdigest(self) -&gt; str: ...
  def intdigest(self) -&gt; int: ...
  @property
  def seed(self) -&gt; int: ...
  def digest128(self) -&gt; bytes: ...
  def hexdigest128(self) -&gt; str: ...
  def intdigest128(self) -&gt; int: ...
  def copy(self) -&gt; Xxh3: ...
  def reset(self) -&gt; None: ...


def xxh32(input: bytes | None = None, seed: int | None = None) -&gt; Xxh32: ...
def xxh64(input: bytes | None = None, seed: int | None = None) -&gt; Xxh64: ...
def xxh3(
  input: bytes | None = None, seed: int | None = None, secret: bytes | None = None
) -&gt; Xxh3: ...


# xxh32
def xxh32_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh32_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh32_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh64
def xxh64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh128
def xxh128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh3
def xxh3_64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh3_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...


# xxh128
def xxh3_128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...


# ==============================================================================
# SQLFORMAT
# ==============================================================================
SqlfmtParamValue = str | int | float | bool
TSqlfmtParamValue_co = t.TypeVar(
  "TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike = (
  dict[str, TSqlfmtParamValue_co]
  | t.Sequence[tuple[str, TSqlfmtParamValue_co]]
  | t.Sequence[TSqlfmtParamValue_co]
)


class SqlfmtQueryParams:
  def __init__(self, params: SqlfmtParamsLike[TSqlfmtParamValue_co]) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...


def sqlfmt_params(
  params: SqlfmtParamsLike[TSqlfmtParamValue_co] | SqlfmtQueryParams,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
  sql: str,
  params: SqlfmtParamsLike[TSqlfmtParamValue_co] | SqlfmtQueryParams | None = None,
  *,
  indent: int = 2,  # -1 or any negative value will use tabs
  uppercase: bool | None = True,
  lines_between_statements: int = 1,
) -&gt; str: ...


# ==============================================================================
# URL
# ==============================================================================


class Url:
  def __init__(self, url: str) -&gt; None: ...
  @classmethod
  def parse(cls, url: str) -&gt; Url: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def __hash__(self) -&gt; int: ...
  def join(self, *parts: str) -&gt; Url: ...
  def __truediv__(self, relative: str) -&gt; Url: ...
  def __rtruediv__(self, relative: str) -&gt; Url: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def __lt__(self, other: object) -&gt; bool: ...
  def __le__(self, other: object) -&gt; bool: ...
  def __gt__(self, other: object) -&gt; bool: ...
  def __ge__(self, other: object) -&gt; bool: ...
  @property
  def scheme(self) -&gt; str: ...
  @property
  def host(self) -&gt; str | None: ...
  @property
  def host_str(self) -&gt; str | None: ...
  @property
  def port(self) -&gt; int | None: ...
  @property
  def path(self) -&gt; str: ...
  @property
  def path_segments(self) -&gt; tuple[str, ...]: ...
  @property
  def query(self) -&gt; str | None: ...
  @property
  def query_pairs(self) -&gt; list[tuple[str, str]]: ...
  @property
  def fragment(self) -&gt; str | None: ...
  @property
  def username(self) -&gt; str: ...
  @property
  def password(self) -&gt; str | None: ...
  @property
  def port_or_known_default(self) -&gt; int | None: ...
  @property
  def authority(self) -&gt; str: ...
  def has_authority(self) -&gt; bool: ...
  def has_host(self) -&gt; bool: ...
  def is_special(self) -&gt; bool: ...
  @classmethod
  def from_directory_path(cls, path: str) -&gt; Url: ...
  def to_filepath(self) -&gt; str: ...
  def set_fragment(self, fragment: str) -&gt; None: ...
  def set_host(self, host: str) -&gt; None: ...
  def set_ip_host(self, host: str) -&gt; None: ...
  def set_password(self, password: str) -&gt; None: ...
  def set_path(self, path: str) -&gt; None: ...
  def set_port(self, port: int) -&gt; None: ...
  def set_query(self, query: str) -&gt; None: ...
  def set_scheme(self, scheme: str) -&gt; None: ...
  def set_username(self, username: str) -&gt; None: ...
  def socket_addrs(self) -&gt; None: ...


# ==============================================================================
# JIFF
# ==============================================================================


class Date:
  MIN: Date
  MAX: Date
  ZERO: Date

  def __init__(self, year: int, month: int, day: int) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def at(self, hour: int, minute: int, second: int, nanosecond: int) -&gt; DateTime: ...
  @property
  def year(self) -&gt; int: ...
  @property
  def month(self) -&gt; int: ...
  @property
  def day(self) -&gt; int: ...
  def to_pydate(self) -&gt; pydt.date: ...
  @classmethod
  def from_pydate(cls: type[Date], date: pydt.date) -&gt; Date: ...
  def astuple(self) -&gt; tuple[int, int, int]: ...
  def asdict(self) -&gt; DateTypedDict: ...
  def intz(self, tz: str) -&gt; ZonedDateTime: ...
  def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
  def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
  @t.overload
  def __sub__(self, other: Date) -&gt; TimeSpan: ...
  @t.overload
  def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
  @t.overload
  def __isub__(self, other: Date) -&gt; TimeSpan: ...
  @t.overload
  def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...


class Time:
  MIN: Time
  MAX: Time

  def __init__(
    self, hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
  ) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
  def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
  @t.overload
  def __sub__(self, other: Time) -&gt; TimeSpan: ...
  @t.overload
  def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
  @t.overload
  def __isub__(self, other: Time) -&gt; TimeSpan: ...
  @t.overload
  def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
  @classmethod
  def strptime(cls: type[Time], format: str, string: str) -&gt; Time: ...
  def strftime(self, format: str) -&gt; str: ...
  @property
  def hour(self) -&gt; int: ...
  @property
  def minute(self) -&gt; int: ...
  @property
  def second(self) -&gt; int: ...
  @property
  def millisecond(self) -&gt; int: ...
  @property
  def microsecond(self) -&gt; int: ...
  @property
  def nanosecond(self) -&gt; int: ...
  def to_pytime(self) -&gt; pydt.time: ...
  @classmethod
  def from_pytime(cls: type[Time], time: pydt.time) -&gt; Time: ...
  def astuple(self) -&gt; tuple[int, int, int, int]: ...
  def asdict(self) -&gt; TimeTypedDict: ...
  def series(self, span: TimeSpan) -&gt; TimeSeries: ...
  def until(self, other: Time) -&gt; TimeSpan: ...


class TimeSeries:
  def __iter__(self) -&gt; t.Iterator[Time]: ...
  def __next__(self) -&gt; Time: ...


class DateTime:
  MIN: DateTime
  MAX: DateTime
  ZERO: DateTime

  def __init__(
    self,
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
  ) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def string(self) -&gt; str: ...
  @classmethod
  def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...
  def __repr__(self) -&gt; str: ...
  def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; DateTime: ...
  def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; DateTime: ...
  @t.overload
  def __sub__(self, other: DateTime) -&gt; TimeSpan: ...
  @t.overload
  def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; DateTime: ...
  @t.overload
  def __isub__(self, other: DateTime) -&gt; TimeSpan: ...
  @t.overload
  def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; DateTime: ...
  def intz(self, tz: str) -&gt; ZonedDateTime: ...
  def date(self) -&gt; Date: ...
  def time(self) -&gt; Time: ...
  @property
  def year(self) -&gt; int: ...
  @property
  def month(self) -&gt; int: ...
  @property
  def day(self) -&gt; int: ...
  @property
  def hour(self) -&gt; int: ...
  @property
  def minute(self) -&gt; int: ...
  @property
  def second(self) -&gt; int: ...
  @property
  def nanosecond(self) -&gt; int: ...
  @property
  def subsec_nanosecond(self) -&gt; int: ...
  @classmethod
  def from_pydatetime(cls: type[DateTime], dt: pydt.datetime) -&gt; DateTime: ...
  def to_pydatetime(self) -&gt; pydt.datetime: ...
  def series(self, span: TimeSpan) -&gt; DateTimeSeries: ...
  def asdict(self) -&gt; DateTimeTypedDict: ...
  def round(self, options: JIFF_UNIT_STRING | DateTimeRound) -&gt; t.Self: ...


class DateTimeSeries:
  def __iter__(self) -&gt; t.Iterator[DateTime]: ...
  def __next__(self) -&gt; DateTime: ...


class TimeZone:
  def __init__(self, name: str) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
  @classmethod
  def from_pytzinfo(cls: type[TimeZone], tz: pydt.tzinfo) -&gt; TimeZone: ...
  @classmethod
  def utc(cls: type[TimeZone]) -&gt; TimeZone: ...


class SignedDuration:
  MIN: SignedDuration
  MAX: SignedDuration
  ZERO: SignedDuration

  def __init__(self, secs: int, nanos: int) -&gt; None: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def __ne__(self, other: object) -&gt; bool: ...
  def __lt__(self, other: object) -&gt; bool: ...
  def __le__(self, other: object) -&gt; bool: ...
  def __gt__(self, other: object) -&gt; bool: ...
  def __ge__(self, other: object) -&gt; bool: ...
  def __neg__(self) -&gt; t.Self: ...
  def __add__(self, other: t.Self) -&gt; t.Self: ...
  def __richcmp__(self, other: SignedDuration | pydt.timedelta, op: int) -&gt; bool: ...
  def __str__(self) -&gt; str: ...
  def string(self) -&gt; str: ...
  def is_negative(self) -&gt; bool: ...
  def is_zero(self) -&gt; bool: ...
  @classmethod
  def from_pytimedelta(
    cls: type[SignedDuration], td: pydt.timedelta
  ) -&gt; SignedDuration: ...
  def to_pytimedelta(self) -&gt; pydt.timedelta: ...
  @property
  def secs(self) -&gt; int: ...
  @property
  def nanos(self) -&gt; int: ...
  @property
  def days(self) -&gt; int: ...
  @property
  def seconds(self) -&gt; int: ...
  @property
  def microseconds(self) -&gt; int: ...


class TimeSpan:
  def __init__(
    self,
  ) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def string(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def __neg__(self) -&gt; t.Self: ...
  def negate(self) -&gt; t.Self: ...
  def __abs__(self) -&gt; t.Self: ...
  def __invert__(self) -&gt; t.Self: ...
  @classmethod
  def from_pytimedelta(cls: type[t.Self], td: pydt.timedelta) -&gt; t.Self: ...
  def to_pytimedelta(self) -&gt; pydt.timedelta: ...
  @classmethod
  def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...
  def years(self, years: int) -&gt; t.Self: ...
  def months(self, months: int) -&gt; t.Self: ...
  def weeks(self, weeks: int) -&gt; t.Self: ...
  def days(self, days: int) -&gt; t.Self: ...
  def hours(self, hours: int) -&gt; t.Self: ...
  def minutes(self, minutes: int) -&gt; t.Self: ...
  def seconds(self, seconds: int) -&gt; t.Self: ...
  def to_jiff_duration(
    self, relative: ZonedDateTime | Date | DateTime
  ) -&gt; SignedDuration: ...
  def repr_full(self) -&gt; str: ...
  def asdict(self) -&gt; TimeSpanTypedDict: ...


class Timestamp:
  """
  A representation of a timestamp with second and nanosecond precision.
  """

  def __init__(
    self, second: int | None = None, nanosecond: int | None = None
  ) -&gt; None: ...
  @classmethod
  def now(cls: type[t.Self]) -&gt; t.Self: ...
  @classmethod
  def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...
  @classmethod
  def from_millisecond(cls: type[t.Self], millisecond: int) -&gt; t.Self: ...
  def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...
  def string(self) -&gt; str: ...
  def as_second(self) -&gt; int: ...
  def as_microsecond(self) -&gt; int: ...
  def as_millisecond(self) -&gt; int: ...
  def as_nanosecond(self) -&gt; int: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def __ne__(self, other: object) -&gt; bool: ...
  def __lt__(self, other: object) -&gt; bool: ...
  def __le__(self, other: object) -&gt; bool: ...
  def __gt__(self, other: object) -&gt; bool: ...
  def __ge__(self, other: object) -&gt; bool: ...
  def __richcmp__(self, other: Timestamp, op: int) -&gt; bool: ...
  def series(self, span: TimeSpan) -&gt; TimestampSeries: ...
  def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...
  def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...
  @t.overload
  def __sub__(self, other: Timestamp) -&gt; TimeSpan: ...
  @t.overload
  def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...
  @t.overload
  def __isub__(self, other: Timestamp) -&gt; TimeSpan: ...
  @t.overload
  def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...


class TimestampSeries:
  def __iter__(self) -&gt; t.Iterator[Timestamp]: ...
  def __next__(self) -&gt; Timestamp: ...


class ZonedDateTime:
  def __init__(self, timestamp: Timestamp, time_zone: TimeZone) -&gt; None: ...
  @classmethod
  def now(cls: type[ZonedDateTime]) -&gt; ZonedDateTime: ...
  @classmethod
  def parse(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
  def __str__(self) -&gt; str: ...
  def string(self) -&gt; str: ...
  @classmethod
  def from_pydatetime(cls: type[ZonedDateTime], dt: pydt.datetime) -&gt; ZonedDateTime: ...
  def to_pydatetime(self) -&gt; pydt.datetime: ...
  @classmethod
  def strptime(cls: type[ZonedDateTime], format: str, input: str) -&gt; ZonedDateTime: ...
  def strftime(self, format: str) -&gt; str: ...
  def __richcmp__(self, other: ZonedDateTime, op: int) -&gt; bool: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def __ne__(self, other: object) -&gt; bool: ...
  def __lt__(self, other: object) -&gt; bool: ...
  def __le__(self, other: object) -&gt; bool: ...
  def __gt__(self, other: object) -&gt; bool: ...
  def __ge__(self, other: object) -&gt; bool: ...
  def __hash__(self) -&gt; int: ...
  def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...
  def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...
  @t.overload
  def __sub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
  @t.overload
  def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...
  @t.overload
  def __isub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
  @t.overload
  def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; t.Self: ...
  def intz(self, tz: str) -&gt; t.Self: ...
  def checked_add(self, span: TimeSpan) -&gt; t.Self: ...
  def round(self, options: JIFF_UNIT_STRING | DateTimeRound) -&gt; t.Self: ...
  @property
  def year(self) -&gt; int: ...
  @property
  def month(self) -&gt; int: ...
  @property
  def day(self) -&gt; int: ...
  @property
  def hour(self) -&gt; int: ...
  @property
  def minute(self) -&gt; int: ...
  @property
  def second(self) -&gt; int: ...
  @property
  def nanosecond(self) -&gt; int: ...
  @property
  def subsec_nanosecond(self) -&gt; int: ...
  def timezone(self) -&gt; TimeZone: ...
  def timestamp(self) -&gt; Timestamp: ...
  def time(self) -&gt; Time: ...
  def datetime(self) -&gt; DateTime: ...


class DateTimeRound:
  def __init__(
    self,
    smallest: JIFF_UNIT_STRING | None = None,
    mode: JIFF_ROUND_MODE_STRING | None = None,
    increment: int = 1,
  ) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...
  def __eq__(self, other: object) -&gt; bool: ...
  def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; DateTimeRound: ...
  def smallest(self, smallest: JIFF_UNIT_STRING) -&gt; DateTimeRound: ...
  def increment(self, increment: int) -&gt; DateTimeRound: ...
  def _smallest(self) -&gt; JIFF_UNIT_STRING: ...
  def _mode(self) -&gt; JIFF_ROUND_MODE_STRING: ...
  def _increment(self) -&gt; int: ...
  def replace(
    self,
    smallest: JIFF_UNIT_STRING | None,
    mode: JIFF_ROUND_MODE_STRING | None,
    increment: int | None,
  ) -&gt; DateTimeRound: ...


class Offset:
  def __init__(self, hours: int) -&gt; None: ...
  def __str__(self) -&gt; str: ...
  def __repr__(self) -&gt; str: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
  hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
  year: int,
  month: int,
  day: int,
  hour: int = 0,
  minute: int = 0,
  second: int = 0,
  nanosecond: int = 0,
) -&gt; DateTime: ...
def timespan(
  *,
  years: int = 0,
  months: int = 0,
  weeks: int = 0,
  days: int = 0,
  hours: int = 0,
  minutes: int = 0,
  seconds: int = 0,
  milliseconds: int = 0,
  microseconds: int = 0,
  nanoseconds: int = 0,
) -&gt; TimeSpan: ...
def timespan_unchecked(
  *,
  years: int = 0,
  months: int = 0,
  weeks: int = 0,
  days: int = 0,
  hours: int = 0,
  minutes: int = 0,
  seconds: int = 0,
  milliseconds: int = 0,
  microseconds: int = 0,
  nanoseconds: int = 0,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
