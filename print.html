<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ry(o3) docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-6a101e14.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-1ed5fffe.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">ry(o3) docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/jessekrubin/ry" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <p><strong>updated:</strong> <code>2026-02-19T09:29:44.250592688-08:00[America/Los_Angeles]</code></p>
<hr>
<h1 id="readme"><a class="header" href="#readme">README</a></h1>
<h1 id="ry"><a class="header" href="#ry">ry</a></h1>
<p><a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/v/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI"></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/pyversions/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Python Version"></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/wheel/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Wheel"></a>
<a href="https://pypistats.org/packages/ry"><img src="https://img.shields.io/pypi/dm/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Downloads"></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/status/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Status"></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/l/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - License"></a></p>
<p>A growing collection of Python shims around Rust crates; fast, async-first, and
ergonomic.</p>
<p><strong>DOCS:</strong> <a href="https://ryo3.dev">ryo3.dev</a> (WIP)</p>
<p><strong>API:</strong> <a href="https://ryo3.dev/api">ryo3.dev/api</a></p>
<p><strong>This is a work in progress ~ feedback and PRs are welcome.</strong></p>
<h2 id="highlights"><a class="header" href="#highlights">Highlights</a></h2>
<ul>
<li><strong>Async-first client and blocking/sync client:</strong> Built on <code>reqwest</code>, with a
<code>fetch</code>-like API. Supports streaming, zero-copy IO via the buffer protocol,
timeouts, redirect-following, and native JSON (de)serialization via
<code>serde</code>/<code>jiter</code>.</li>
<li><strong><code>jiff</code> based datetime library:</strong> comprehensive datetime library based on
<code>jiff</code> (pydantic-compatible).</li>
<li><strong>Async file I/O:</strong> Built on <code>tokio</code>, with an <code>AsyncFile</code> API similar to
<code>aiofiles</code> and <code>anyio</code>’s async-file api. Supports buffered reads/writes,
truncation, streaming reads, and <code>anyio</code> compatibility.</li>
<li><strong>(de)compression:</strong> (de)compression tools for <code>zstd</code>, <code>brotli</code>, <code>gzip</code>, and
<code>bzip2</code>.</li>
<li><strong>Miscellaneous bindings:</strong> Includes crates like <code>globset</code>, <code>walkdir</code>,
<code>sqlformat</code>, <code>unindent</code>, <code>twox-hash</code>, and more.</li>
<li><strong>Designed for ergonomics:</strong> Async where it matters. Simple where possible.
Python-native behavior with minimal friction.</li>
<li><strong>Type Annotated:</strong> All public APIs are (painstakingly) type annotated.</li>
<li><strong>Performant:</strong> Speed without the words “blazingly fast.” <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></li>
<li><strong>Pydantic Integration:</strong> ry data types (mostly) work good w/ pydantic.</li>
<li><strong>Not slop:</strong> written by a human <sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup></li>
<li><strong>No emojis</strong></li>
</ul>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-bash">pip install ry
uv add ry

# check install
python -m ry
</code></pre>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Check out the <a href="https://github.com/jessekrubin/ry/tree/main/examples">examples</a>
directory for some quickstart examples.</p>
<hr>
<h2 id="what"><a class="header" href="#what">What?</a></h2>
<ul>
<li><code>ry</code> – the python package</li>
<li><code>ryo3-*</code> – the rust crates that are used by <code>ry</code> and possibly your own
<code>pyo3</code>-based python package</li>
</ul>
<h2 id="who"><a class="header" href="#who">Who?</a></h2>
<ul>
<li>jessekrubin <a href="mailto:jessekrubin@gmail.com">jessekrubin@gmail.com</a></li>
<li>possibly you!?</li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><em>(aka: questions that I have been asking myself)</em></p>
<ul>
<li><strong>Q:</strong> Why?
<ul>
<li><strong>A:</strong> I (jesse) needed several hashing functions for python and then kept
adding things as I needed them</li>
</ul>
</li>
<li><strong>Q:</strong> Does this have anything to do with the (excellent) package manager
<code>rye</code>?
<ul>
<li><strong>A:</strong> short answer: no. long answer: no, it does not.</li>
</ul>
</li>
<li><strong>Q:</strong> Why is the repo split into <code>ry</code> and <code>ryo3</code>?
<ul>
<li><strong>A:</strong> <code>ry</code> is the python package, <code>ryo3</code> is a rust crate setup to let you
“register” functions you may want if you were writing your own pyo3-python
bindings library; maybe someday the <code>ryo3::libs</code> module will be split up
into separate packages</li>
</ul>
</li>
</ul>
<h2 id="crate-bindings"><a class="header" href="#crate-bindings">Crate bindings</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>crate</strong></th><th><strong>ryo3-crate</strong></th></tr>
</thead>
<tbody>
<tr><td><code>std</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-std"><code>ryo3-std</code></a></td></tr>
<tr><td><code>bytes</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-bytes"><code>ryo3-bytes</code></a></td></tr>
<tr><td><code>bzip2</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-bzip2"><code>ryo3-bzip2</code></a></td></tr>
<tr><td><code>dirs</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-dirs"><code>ryo3-dirs</code></a></td></tr>
<tr><td><code>fspath</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-fspath"><code>ryo3-fspath</code></a></td></tr>
<tr><td><code>glob</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-glob"><code>ryo3-glob</code></a></td></tr>
<tr><td><code>heck</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-heck"><code>ryo3-heck</code></a></td></tr>
<tr><td><code>http</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-http"><code>ryo3-http</code></a></td></tr>
<tr><td><code>jiter</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-jiter"><code>ryo3-jiter</code></a></td></tr>
<tr><td><code>json</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-json"><code>ryo3-json</code></a></td></tr>
<tr><td><code>pydantic</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-pydantic"><code>ryo3-pydantic</code></a></td></tr>
<tr><td><code>reqwest</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-reqwest"><code>ryo3-reqwest</code></a></td></tr>
<tr><td><code>serde</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-serde"><code>ryo3-serde</code></a></td></tr>
<tr><td><code>shlex</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-shlex"><code>ryo3-shlex</code></a></td></tr>
<tr><td><code>size</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-size"><code>ryo3-size</code></a></td></tr>
<tr><td><code>sqlformat</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-sqlformat"><code>ryo3-sqlformat</code></a></td></tr>
<tr><td><code>tokio</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-tokio"><code>ryo3-tokio</code></a></td></tr>
<tr><td><code>ulid</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-ulid"><code>ryo3-ulid</code></a></td></tr>
<tr><td><code>unindent</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-unindent"><code>ryo3-unindent</code></a></td></tr>
<tr><td><code>url</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-url"><code>ryo3-url</code></a></td></tr>
<tr><td><code>uuid</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-uuid"><code>ryo3-uuid</code></a></td></tr>
<tr><td><code>which</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-which"><code>ryo3-which</code></a></td></tr>
<tr><td><strong>Compression</strong></td><td><strong>~</strong></td></tr>
<tr><td><code>brotli</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-brotli"><code>ryo3-brotli</code></a></td></tr>
<tr><td><code>flate2</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-flate2"><code>ryo3-flate2</code></a></td></tr>
<tr><td><code>zstd</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-zstd"><code>ryo3-zstd</code></a></td></tr>
<tr><td><strong>Hashing</strong></td><td><strong>~</strong></td></tr>
<tr><td><code>fnv</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-fnv"><code>ryo3-fnv</code></a></td></tr>
<tr><td><code>twox-hash</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-twox-hash"><code>ryo3-twox-hash</code></a></td></tr>
<tr><td><strong>@BurntSushi</strong></td><td><strong>~</strong></td></tr>
<tr><td><code>globset</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-globset"><code>ryo3-globset</code></a></td></tr>
<tr><td><code>jiff</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-jiff"><code>ryo3-jiff</code></a></td></tr>
<tr><td><code>memchr</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-memchr"><code>ryo3-memchr</code></a></td></tr>
<tr><td><code>regex</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-regex"><code>ryo3-regex</code></a></td></tr>
<tr><td><code>same-file</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-same-file"><code>ryo3-same-file</code></a></td></tr>
<tr><td><code>walkdir</code></td><td><a href="https://github.com/jessekrubin/ry/tree/main/crates/ryo3-walkdir"><code>ryo3-walkdir</code></a></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="dev"><a class="header" href="#dev">DEV</a></h2>
<ul>
<li><code>just</code> is used to run tasks</li>
<li>Do not use the phrase <code>blazing fast</code> or any emojis in any PRs or issues or
docs</li>
<li>type annotations are required</li>
<li><code>ruff</code> used for formatting and linting</li>
</ul>
<hr>
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<ul>
<li><a href="https://github.com/jessekrubin/utiles">utiles</a>: web-map tile utils</li>
</ul>
<hr>
<ol class="footnote-definition">
<li id="footnote-1">
<p>Release‑version benchmarks of <code>ry</code> (via <code>pytest-benchmark</code>) showed no real
performance variance, regardless of whether “blazingly fast” appeared in the
README or docs. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Artisanal, hand-crafted, small-batch software. <a href="#fr-2-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="development"><a class="header" href="#development">DEVELOPMENT</a></h1>
<h2 id="goals"><a class="header" href="#goals">goals</a></h2>
<ol>
<li>Provide a really nice ergonomic API to work with (this is the highest
priority)</li>
<li>Get naming right (this is a hard one!)</li>
<li>Be fast</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">development-setup</a></h2>
<ul>
<li>clone repo</li>
<li>install <code>just</code> (<code>cargo install just</code>)</li>
<li>create a virtual env (using ye olde <code>venv</code> or <code>uv</code> or dare I say <code>conda</code>) – I
am still working out the kinks of using <code>uv</code> with maturin</li>
<li>install the dev-requirements (<code>pip install -r requirements.dev.txt</code>)</li>
<li>run <code>just dev</code> to build and test the library</li>
<li>run <code>just fmt</code> to format the python and rust code</li>
</ul>
<h2 id="style-guide"><a class="header" href="#style-guide">style guide</a></h2>
<ul>
<li>Naming conventions:
<ul>
<li>For python classes/structs/types prefer <code>AsyncXYZ</code> over <code>XYZAsync</code></li>
<li>use <code>snake_case</code> for functions and variables</li>
<li>use <code>CamelCase</code> for types and traits</li>
<li>use <code>SCREAMING_SNAKE_CASE</code> for constants and static-class-attributes</li>
</ul>
</li>
<li><strong>NO UNWRAPPING</strong> – use <code>expect</code> over <code>unwrap</code></li>
<li><strong>NO PANICS</strong> – don’t panic!</li>
<li><strong>NO <code>blazingly-fast</code></strong> – <code>ry</code> is fast and does not need an adverb</li>
<li><strong>USE CLIPPY</strong> <code>just clippy</code> or <code>just ci</code></li>
<li><strong>USE RUSTFMT AND RUFF</strong> <code>just fmt</code></li>
<li>library style guide:
<ul>
<li>python objects/structs/classes defined in the library should be named either
<code>Py&lt;CLASSNAME&gt;</code> or <code>Ry&lt;CLASSNAME&gt;</code> and the prefix should be consistent
throughout the library (eg <code>ryo3-jiff</code> uses <code>Ry</code> as the internal prefix to
not conflict with the <code>Py&lt;CLASSNAME&gt;</code> structs provided by <code>pyo3</code>)</li>
<li>For wrapper libraries, attempt to mirror the structure of the original
library as much as possible</li>
<li>wrapper library names should be of the form <code>ryo3-&lt;LIB_NAME&gt;</code> where
<code>&lt;LIB_NAME&gt;</code> is the name of the wrapped library</li>
<li>library directories should be <code>kebab-case</code> and should be <code>ryo3-&lt;LIB_NAME&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="creating-a-new-librarywrapper-thing"><a class="header" href="#creating-a-new-librarywrapper-thing">Creating a new library/wrapper-thing</a></h2>
<ul>
<li>copy the template library <code>ryo3-quick-maths</code> library to your new library name</li>
<li>refer to the above style guide for naming conventions</li>
</ul>
<hr>
<h2 id="tools"><a class="header" href="#tools">tools</a></h2>
<h3 id="python"><a class="header" href="#python">python</a></h3>
<ul>
<li>we use <code>maturin</code> for building the python wheels</li>
<li>we support <code>python-3.11+</code></li>
<li>we use <code>pytest</code> for testing as well as the following plugins:
<ul>
<li><code>anyio</code> (which I am increasingly thinking is actually a bit of a turd)</li>
<li><code>hypothesis</code></li>
<li><code>pytest-benchmark</code></li>
<li><code>pytest-cov</code></li>
</ul>
</li>
</ul>
<h3 id="just"><a class="header" href="#just">just</a></h3>
<p><strong><code>cargo install just</code></strong></p>
<ul>
<li>we use <code>just</code> for task running</li>
<li>to see all tasks run <code>just</code> or <code>just --list</code> (our default task echos the list
of tasks)</li>
</ul>
<p>tasks as of 2025-09-26:</p>
<pre><code class="language-txt">Available recipes:
    repl            # run ry.dev python repl
    repl-uv         # run ry.dev python repl (if using uv)
    dev             # dev run build + tests
    dev-uv          # dev run build + tests (with uv)
    sync            # uv sync
    develop         # maturin develop
    develop-uv      # maturin develop (with uv)
    mat             # maturin develop (shorthand)
    cargo-test      # cargo test
    build           # build
    build-release   # build release
    dev-rel         # maturin develop release
    doctest         # run pytest
    pytest          # run pytest
    pytest-uv       # run pytest
    pytestv         # run pytest (printing captured output)
    test            # run all test
    test-release    # test ry package
    bench           # benchmark ry python package
    ci              # ci rust checks
    cargo-fmt       # cargo format
    cargo-fmtc      # cargo format check
    sort-all-check  # ruff check sorting of '__all__'
    sort-all        # ruff sort '__all__'
    ruff-fmt        # ruff format
    ruff-fmtc       # ruff format check
    fmtpy           # python format
    fmtcpy          # python format check
    justfilefmt     # justfile format
    justfilefmtc    # justfile format check
    mdfmt           # format markdown
    pyprojectfmt    # pyproject-fmt
    fmt             # format
    fmtc            # format check
    ruff            # run ruff linter
    ruffix          # run ruff + fix
    clippy          # run clippy
    clippy-features # run clippy with feature-powerset via cargo-hack
    lint            # lint python and rust
    mypy            # run mypy type checker
    pyright         # run pyright
    pip-compile     # pip compile requirements
    gen             # generate code tasks
    cargo-doc       # generate cargo docs for all crates (in workspace)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="acknowledgements"><a class="header" href="#acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>This project would not be possible without the incredible work of many others.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">THANK YOU</a></h2>
<ul>
<li><a href="https://github.com/PyO3/pyo3">pyo3</a> developers (a.k.a.
<a href="https://github.com/davidhewitt">@davidhewitt</a>, et al.)</li>
<li>All authors and maintainers of the countless libraries this project builds
upon</li>
<li>Andrew Gallant (<a href="https://github.com/BurntSushi">@BurntSushi</a>) for the
exceptional ecosystem of rust libraries wrapped here (<code>jiff</code>, <code>globset</code>,
<code>memchr</code>, <code>walkdir</code>, and <code>same-file</code>) and for patiently answering my many
random questions</li>
<li>Kyle Barron (<a href="https://github.com/kylebarron">@kylebarron</a>) for his work on
<code>pyo3-bytes</code> and letting me contribute</li>
<li>Dan Costello (<a href="https://github.com/dan-costello">@dan-costello</a>), Charlie
Imhoff (<a href="https://github.com/cpimhoff">@cpimhoff</a>) and Josh Coats
(<a href="https://github.com/rhwlo">@rhwlo</a>) for entertaining my endless
naming-convention and style related questions/debates</li>
<li>The Academy and the Hollywood Foreign Press</li>
</ul>
<hr>
<p>If you want to be added to this list, please open an issue or PR! Happy to add
you if you’ve helped in any way!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ry-dist-archives"><a class="header" href="#ry-dist-archives">ry-dist-archives</a></h1>
<p><strong>TLDR: If you are using an older version of <code>ry</code> and it is not longer on PyPI,
you can find it either on primary ry-repo’s
<a href="https://github.com/jessekrubin/ry/releases">releases</a> page, or in the
<a href="https://github.com/jessekrubin/ry-dist-archives">ry-dist-archives</a>
repository.</strong></p>
<p>PyPI imposes a 10 GB limit on the total size of all files in a given project.
Once that limit is reached, you must either delete old files or request a size
increase. As of now (<code>2025-07-22T08:34:51.3412157-07:00[America/Los_Angeles]</code>),
the <code>ry</code> package is still very much in beta, and I (jesse) am not going to
request a size increase while the project remains pre-<code>0.1.0</code>.</p>
<p><code>ry</code> builds are performed with github cicd, and published builds for versions
<code>0.44.0</code> are uploaded to github
<a href="https://github.com/jessekrubin/ry/releases">releases</a>, <strong>but</strong> publishing
releases was not previously a part of the cicd workflow.</p>
<p>The script for downloading wheels is located at
<a href="https://github.com/jessekrubin/ry-dist-archives/blob/main/scripts/dl_versions.py">ry-dist-archives/scripts/dl_versions.py</a>.
It serves as a good example of how to use <code>ry</code>’s HTTP client, JSON parsing and
dumping, and async file I/O tools.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog"><a class="header" href="#changelog">CHANGELOG</a></h1>
<h2 id="v0085-unreleased"><a class="header" href="#v0085-unreleased">v0.0.85 [unreleased]</a></h2>
<ul>
<li><code>ryo3-fnv</code>
<ul>
<li>drop <code>fnv</code> crate dependency</li>
<li>internal refactoring and cleanup to use <code>ryo3-core</code> utils</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>text_with_charset</code> response methods</li>
<li><code>text</code> now takes <code>encoding="utf-8"</code> kw-only-arg</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0084-2026-02-16"><a class="header" href="#v0084-2026-02-16">v0.0.84 [2026-02-16]</a></h2>
<ul>
<li>bump <code>jiff</code> version to <code>0.2.20</code></li>
<li><code>ryo3-aws-lc</code>
<ul>
<li>new crate! yay</li>
<li>implemented digest wrappers!</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0083-2026-02-05"><a class="header" href="#v0083-2026-02-05">v0.0.83 [2026-02-05]</a></h2>
<ul>
<li>pyo3: updated <code>pyo3</code> to <code>0.28.x</code></li>
<li><code>ryo3-jiff</code>
<ul>
<li>more timestamp testing</li>
<li>pendulum/whenever/arrow style <code>add</code> and <code>sub</code> apis for jiff types</li>
</ul>
</li>
<li>misc
<ul>
<li>add clippy <code>derive_partial_eq_without_eq</code> lint</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>Renamed <code>Pattern</code> to <code>GlobPattern</code> for clarity. People using
<code>ry.GlobPattern</code> probably prefer using <code>ry.Glob</code> over <code>ry.GlobPattern</code>
(formerly <code>ry.Pattern</code>) as it is more performant and more configurable.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0082-2026-01-27"><a class="header" href="#v0082-2026-01-27">v0.0.82 [2026-01-27]</a></h2>
<ul>
<li><code>ryo3-http</code>
<ul>
<li>renamed several http types to have <code>Py</code> prefix to avoid confusion with
<code>http</code> crate types and be clear that they are wrapper types for
extracting/into-ing w/ <code>pyo3</code>:
<ul>
<li><code>HttpMethod</code> -&gt; <code>PyHttpMethod</code></li>
<li><code>HttpVersion</code> -&gt; <code>PyHttpVersion</code></li>
<li><code>HttpHeaderName</code> -&gt; <code>PyHttpHeaderName</code></li>
<li><code>HttpHeaderNameRef</code> -&gt; <code>PyHttpHeaderNameRef</code></li>
<li><code>HttpHeaderValue</code> -&gt; <code>PyHttpHeaderValue</code></li>
<li><code>HttpHeaderMap</code> -&gt; <code>PyHttpHeaderMap</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>connection_verbose</code> kwarg for <code>ry.HttpClient</code>, <code>ry.Client</code> and
<code>ry.BlockingClient</code> for debugging</li>
<li>internal refactoring of client kwargs extraction</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0081-2026-01-23"><a class="header" href="#v0081-2026-01-23">v0.0.81 [2026-01-23]</a></h2>
<ul>
<li><code>ryo3-jiter</code>
<ul>
<li>restore big-int json parsing support. jiter <code>feature: num-bigint</code> was
removed when I turned off all default features :/</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0080-2026-01-22--the-wild-80s"><a class="header" href="#v0080-2026-01-22--the-wild-80s">v0.0.80 [2026-01-22] ~ the wild 80’s</a></h2>
<ul>
<li><code>ryo3-http</code>
<ul>
<li>remove <code>parking_lot</code> from http</li>
<li>cache status <code>ry.HttpStatus</code> code struct instances. the classattrs go
through the same mechanism so <code>ry.HttpStatus.OK is ry.HttpStatus(200)</code> is
<code>True</code>. Statuses are only cached for codes in the 100-599 range even tho
<code>::http::StatusCode</code> allows <code>u16</code> from <code>100..=999</code> (which idk why they did
that)</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>the internal <code>DirEntry</code> struct getters were changed to be methods instead of
properties to match the <code>async</code> version in <code>ryo3-tokio</code></li>
<li><code>FileType</code> finally supporting <code>FileTypeExt</code> and internally reworked</li>
<li>removed <code>FileType.to_dict()</code> and associated <code>FileTypeDict</code> typed-dict</li>
<li>sync-file-stream kwarg <code>chunk_size</code> renamed to <code>read_size</code> to be more clear</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>async-file-stream kwarg <code>chunk_size</code> renamed to <code>read_size</code> to be more clear</li>
<li>Experiments with using tokio runtime to spawn instead of
pyo3-async-runtimes + py-futures</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0079-2026-01-15"><a class="header" href="#v0079-2026-01-15">v0.0.79 [2026-01-15]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>rejigger <code>__add__</code> to be commutative for span/signed_duration</li>
</ul>
</li>
<li><code>default-features = false</code> everywere and manually fine-grain control feats</li>
<li><code>ryo3-serde</code>
<ul>
<li>internal refactoring and some unsafe-ness where it is straight-forward</li>
<li>removed <code>Dataclass</code> from pointer lookup table and put dataclass serialzation
under the new <code>PyUnknownSerializer</code></li>
</ul>
</li>
<li><code>type-annotations</code>
<ul>
<li>removed generic <code>ry.Proxy</code> as it was more confusing than helpful</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0078-2026-01-12"><a class="header" href="#v0078-2026-01-12">v0.0.78 [2026-01-12]</a></h2>
<ul>
<li>internal
<ul>
<li>use uv publishing</li>
<li>update pre-commit stuff</li>
<li>update dev/testing deps</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>added new <code>tls_crls_only</code> kwarg</li>
<li>added <code>ry.CertificateRevocationList</code></li>
<li>added <code>ry.Identity</code></li>
<li>added <code>resolve</code> mapping support for clients</li>
<li>renames/deprecations:
<ul>
<li><code>root_certificates</code> -&gt; <code>tls_certs_merge</code> and <code>tls_certs_only</code></li>
<li><code>danger_accept_invalid_certs</code> -&gt; <code>tls_danger_accept_invalid_certs</code></li>
<li><code>danger_accept_invalid_hostnames</code> -&gt; <code>tls_danger_accept_invalid_hostnames</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0077-2026-01-07"><a class="header" href="#v0077-2026-01-07">v0.0.77 [2026-01-07]</a></h2>
<ul>
<li><code>ryo3-reqwest</code>
<ul>
<li>Allow
<code>Generator[Buffer] | AsyncGenerator[Buffer] | Iterable[Buffer] | AsyncIterable[Buffer]</code>
as body input</li>
<li>Renamed tls version kwargs to match reqwest naming:
<ul>
<li><code>tls_max_version</code> -&gt; <code>tls_version_max</code></li>
<li><code>tls_min_version</code> -&gt; <code>tls_version_min</code></li>
</ul>
</li>
<li><code>Response.stream()</code> now takes a <code>min_read_size</code> kwarg; must be positive int,
and <code>default=0</code> meaning no buffering</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0076-2026-01-05"><a class="header" href="#v0076-2026-01-05">v0.0.76 [2026-01-05]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>Custom extractors for enums to avoid clones</li>
<li>Cleaner <code>SpanRelativeTo</code> impl that does not involve cloning</li>
<li>bump jiff version:wq</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>Update to reqwest <code>v0.13.1+</code></li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>Custom faster string extraction w/ orjson as the inspiration</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0075-2025-12-22"><a class="header" href="#v0075-2025-12-22">v0.0.75 [2025-12-22]</a></h2>
<ul>
<li><code>ryo3-serde</code>
<ul>
<li>Renamed all <code>SerializePy*</code> structs to <code>Py*Serializer</code> w/ this one-liner:
<ul>
<li><code>find . -type f -name "*.rs" -print0 | xargs -0 sed -i -E 's/SerializePy([A-Z][A-Za-z0-9_]*)/Py\1Serializer/g'</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Consolidate <code>map_py_err_*</code> functions into <code>ryo3_core</code></li>
<li><code>ry.TimeZone.preceding</code> &amp; <code>ry.TimeZone.following</code> for timezone transitions</li>
</ul>
</li>
<li><code>ryo3-core</code>
<ul>
<li>renamed <code>PyMutex</code> to <code>RyMutex</code> to avoid confusion with <code>pyo3</code>’s <code>PyMutex</code></li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>Removed richcmp between non <code>FsPath</code> objects and <code>ry.FsPath</code> (can use
<code>equiv</code>) to check for equality</li>
<li>Use <code>RyMutex</code> instead of <code>parking_lot::Mutex</code></li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>Use <code>RyMutex</code> instead of <code>parking_lot::Mutex</code></li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>Remove mutex wrapping global client</li>
<li>Experimental new <code>ry.Client</code> that uses <code>pyo3</code>’s <code>experimental-async</code> feat</li>
</ul>
</li>
<li><code>ryo3-uuid</code>
<ul>
<li>made <code>__hash__</code> equiv to python’s <code>__hash__</code> impl so that rich comparisons
between <code>ry.UUID</code> and <code>uuid.UUID</code> work as expected in hashed collections</li>
</ul>
</li>
<li><code>ryo3-url</code>
<ul>
<li>Added <code>equiv</code> method for comparing <code>ry.URL</code> with other <code>ry.URL</code> instances or
python <code>str</code> objects</li>
<li>Removed richcmp between non <code>URL</code> objects and <code>ry.URL</code> (can use <code>equiv</code>) to
check for equality</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0074-2025-12-16"><a class="header" href="#v0074-2025-12-16">v0.0.74 [2025-12-16]</a></h2>
<ul>
<li>updating pyo3 to use <code>skip_from_py_object</code> where applicable (this will be a
staged effort)</li>
<li><code>ryo3-serde</code>
<ul>
<li>move to using <code>borrowed</code> over <code>&amp;bound</code>; benchmarks show 10-20% perf in
serializing</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Removed equality with <code>datetime.timedelta</code> can use <code>ry.SignedDuration.equiv</code>
to compare to <code>datetime.timedelta</code>, <code>ry.SignedDuration</code>, or <code>ry.Duration</code>.</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>Fix race condition when creating error from reqwest-client-wrapper</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0073-2025-12-12"><a class="header" href="#v0073-2025-12-12">v0.0.73 [2025-12-12]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>offset
<ul>
<li>pydantic integration</li>
<li>Changed signature of constructor to be
<code>ry.Offset(hours=0, minutes=0, seconds=0)</code></li>
</ul>
</li>
<li>use defaults for all round/difference objects/function calls</li>
<li>fixed f-str formatting when emptry fmt string given</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0072-2025-12-10"><a class="header" href="#v0072-2025-12-10">v0.0.72 [2025-12-10]</a></h2>
<ul>
<li>RENAMES:
<ul>
<li><code>ry.URL.replace_*</code> -&gt; <code>ry.URL.with_*</code>: the <code>replace_*</code> methods are
deprecated in favor of <code>with_*</code> methods. The <code>ry.URL.replace</code> still exists
as a way to replace multiple parts at once.</li>
<li><code>ry.aiopen</code> -&gt; <code>ry.aopen</code>: it was supposed to be “asyncio-open”, but it
could be easily confused with “artificial-intellegence-open”/“llm-open”</li>
<li><code>ryo3-fnv</code>
<ul>
<li><code>FnvHasher</code> -&gt; <code>fnv1a</code></li>
<li><code>fnv1a</code> function removed as it was just a stupid proxy for <code>fnv1a</code> class
constructor</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>Added <code>AsyncFileReadStream</code> pyclass for async file read streams</li>
<li>Helper function <code>read_str_async</code> for creating an <code>AsyncFileReadStream</code></li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>use <code>PyMutex</code> and get rid of <code>parking_lot::Mutex</code> for jiff series iterators</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0071-2025-12-03"><a class="header" href="#v0071-2025-12-03">v0.0.71 [2025-12-03]</a></h2>
<ul>
<li><code>ryo3-serde</code>
<ul>
<li>crude string subclass support</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>use <code>py_parse</code> and <code>py_from_str</code> for jiff types so that str/bytes are
allowed <code>def parse(cls, s: str | bytes) -&gt; t.Self:</code></li>
<li>Fix pydantic paring problems caused by lazy copy-pasta-ing w/o using
eyeballs to read what I had copy-pasta-ed</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0070-2025-12-02-30-is-the-new-70"><a class="header" href="#v0070-2025-12-02-30-is-the-new-70">v0.0.70 [2025-12-02] (30 is the new 70)</a></h2>
<ul>
<li>type annotations
<ul>
<li>Fixing type annotations and starting to use <code>stubtest</code></li>
</ul>
</li>
<li><code>ryo3-http</code>
<ul>
<li>Bump version to 1.4.0 which adds <code>103 Early Hints</code> status code among other
things</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>Removed <code>client</code> kwarg from <code>fetch</code> function as it is kinda stupid</li>
<li><code>BlockingClient</code> and <code>BlockingResponse</code> for sync/blocking reqs… This makes
the <code>HttpClient</code> name awkward and may rename it to just <code>Client</code>… TBD</li>
<li>added <code>fetch_sync</code> function for blocking/sync http requests</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li><code>offset_conflict</code> and <code>disambiguation</code> type annotation fixes</li>
<li><code>collect()</code> methods for jiff series</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0069-2025-11-21"><a class="header" href="#v0069-2025-11-21">v0.0.69 [2025-11-21]</a></h2>
<ul>
<li>added <code>immutable_type</code> attr to pyclasses bc many of the things in this crate
are practically primitives</li>
<li><code>ryo3-fnv</code>
<ul>
<li>Add <code>py.detach</code> where it makes sense</li>
<li>Return python <code>builtins.bytes</code> from digest not <code>ry.Bytes</code></li>
</ul>
</li>
<li><code>ryo3-url</code>
<ul>
<li><code>URL.host</code> property returns <code>None | str | ry.Ipv4Addr | ry.Ipv6ddr</code> if
<code>ryo3-std</code> feature enabled</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>pydantic support for <code>ry.Ipv4Addr</code>, <code>ry.Ipv6addr</code>, and <code>ry.Ipaddr</code></li>
</ul>
</li>
<li><code>ryo3-brotli</code>
<ul>
<li>Internal refactoring &amp; type-annotation updates</li>
</ul>
</li>
<li><code>ryo3-bzip2</code>
<ul>
<li>Internal refactoring &amp; type-annotation updates</li>
</ul>
</li>
<li><code>ryo3-flate2</code>
<ul>
<li>Internal refactoring &amp; type-annotation updates</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0068-2025-11-14"><a class="header" href="#v0068-2025-11-14">v0.0.68 [2025-11-14]</a></h2>
<ul>
<li><code>ryo3-glob</code>
<ul>
<li>fix error on <code>take</code></li>
</ul>
</li>
<li><code>ryo3-core</code>
<ul>
<li><code>PyMutex</code> that lets ya pick to throw or not via const generic (very fancy
look at me)</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Update jiff to <code>0.2.16</code></li>
<li>Add <code>ZonedSeries</code></li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>Use jiff for duration formatting</li>
<li><code>ry.Duration.seconds</code> now returns total seconds in duration</li>
<li><code>ry.Duration.seconds_remainder</code> returns seconds % days (self.seconds
% 86400)</li>
<li>Remove <code>datetime.timedelta</code> support for <code>ry.Duration.__richcmp__</code> as there
is not a one-2-uno direct mapping between timedeltas and durations (bc
durations are unsigned)</li>
<li>pydantic support for <code>ry.Duration</code></li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>Use jiff unsigned-duration serialization for <code>ry.Duration</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0067-2025-11-07"><a class="header" href="#v0067-2025-11-07">v0.0.67 [2025-11-07]</a></h2>
<ul>
<li><code>ryo3-std</code>
<ul>
<li><code>read_str</code> as <code>read_text</code> alias</li>
</ul>
</li>
<li>fix musl builds</li>
<li><code>ryo3-url</code>
<ul>
<li>pydantic support</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0066-2025-10-31"><a class="header" href="#v0066-2025-10-31">v0.0.66 [2025-10-31]</a></h2>
<ul>
<li>fix typos in python tests</li>
<li>windows arm64 builds</li>
<li>use <code>py.detach</code> where beneficial:
<ul>
<li><code>ryo3-brotli</code></li>
<li><code>ryo3-fspath</code></li>
<li><code>ryo3-same-file</code></li>
<li><code>ryo3-std</code></li>
<li><code>ryo3-walkdir</code></li>
<li><code>ryo3-which</code></li>
</ul>
</li>
<li><code>ryo3-bytes</code>
<ul>
<li>optimized extraction of <code>builtins.bytes</code>, <code>ry.Bytes</code></li>
</ul>
</li>
<li><code>ryo3-http</code>
<ul>
<li>switch from <code>parking_lot::Mutex</code> to <code>parking_lot::RwLock</code> for <code>PyHeaders</code>:wq</li>
</ul>
</li>
<li>global-allocator
<ul>
<li><code>mimalloc</code> feature added to use <code>mimalloc</code> over the system allocator</li>
<li>added top level <code>__allocator__</code> constant</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0065-2025-10-24"><a class="header" href="#v0065-2025-10-24">v0.0.65 [2025-10-24]</a></h2>
<ul>
<li><code>ryo3-reqwest</code>
<ul>
<li>Manually implement <code>ClientConfig::default</code> as global fetch was failing</li>
</ul>
</li>
<li><code>ryo3-uuid</code>
<ul>
<li>Fixed features problems as pointed out by clippy + cargo-hack</li>
<li>Removed unused <code>uuid2</code> function as it is not implemented in the underlying
<code>uuid</code> crate</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0064-2025-10-20"><a class="header" href="#v0064-2025-10-20">v0.0.64 [2025-10-20]</a></h2>
<ul>
<li><code>ryo3-reqwest</code>
<ul>
<li>Turn on hickory-dns by default</li>
<li>Use `rustls-tls-webpki-roots</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0063-2025-10-20"><a class="header" href="#v0063-2025-10-20">v0.0.63 [2025-10-20]</a></h2>
<ul>
<li>pyo3
<ul>
<li>Upgrade pyo3 version to <code>0.27.x</code></li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>Missing <code>std::fs</code> function wrappers:
<ul>
<li><code>std::fs::hard_link</code> -&gt;
<code>ry.hard_link(src: FsPathLike, dst: FsPathLike) -&gt; None</code></li>
<li><code>std::fs::read_link</code> -&gt; <code>ry.read_link(path: FsPathLike) -&gt; FsPathLike</code></li>
<li><code>std::fs::read_to_string</code> -&gt; <code>ry.read_to_string(path: FsPathLike) -&gt; str</code></li>
<li><code>std::fs::set_permissions</code> -&gt;
<code>ry.set_permissions(path: FsPathLike, permissions: ry.Permissions) -&gt; None</code></li>
<li><code>std::fs::soft_link</code> -&gt;
<code>ry.soft_link(from_path: FsPathLike, to_path: FsPathLike) -&gt; None</code></li>
<li><code>std::fs::symlink_metadata</code> -&gt;
<code>ry.symlink_metadata(path: FsPathLike) -&gt; ry.Metadata</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>Detach implementation of <code>take</code> and <code>collect</code> (which is cleaner and probably
a wee bit faster)</li>
</ul>
</li>
<li><code>_future</code>
<ul>
<li><code>ryo3-ignore</code> wrapper placeholder</li>
<li><code>ryo3-tokio-websockets</code> crate placeholder</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>ry.Certificate</code> for <code>HttpClient</code> added</li>
<li><code>root_certificates</code> added to <code>ry.HttpClient</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0062-2025-10-15"><a class="header" href="#v0062-2025-10-15">v0.0.62 [2025-10-15]</a></h2>
<ul>
<li>python3.14 builds</li>
<li><code>ryo3-uuid</code>
<ul>
<li>Fixed uuid <code>.time</code> property on python 3.14+</li>
</ul>
</li>
<li><code>ryo3-sqlformat</code>
<ul>
<li>Internal refactoring</li>
<li>Fixed type annotations</li>
<li>Starting to think that the <code>QueryParams</code> wrapper is totally stupid and
useless and may remove/deprecate</li>
<li>Upgrade sqlformat to <code>0.5.0</code> which adds the kwarg
<code>dialect: t.Literal["generic", "postgresql", "sqlserver"] = "generic"</code></li>
<li>Added <code>SqlFormatter</code> object for storing a “config”/set-o-opts and for reuse
(which I was in need of)</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>Added <code>basic_auth</code> and <code>bearer_auth</code> kwargs to fetch functions (<code>get</code>,
<code>post</code>, <code>put</code>, <code>delete</code>, <code>head</code>, <code>patch</code>, and of course <code>fetch</code>)</li>
<li>Internal refactoring of body/form/json/multipart parsing.</li>
<li>Added more client kwargs from <code>reqwest::ClientBuilder</code>:
<ul>
<li><code>redirect: int | None = 10</code></li>
<li><code>referer: bool = True</code></li>
<li><code>zstd: bool = True</code></li>
<li><code>hickory_dns: bool = True</code></li>
<li><code>http1_only: bool = False</code></li>
<li><code>https_only: bool = False</code></li>
<li><code>http1_title_case_headers: bool = False</code></li>
<li><code>http1_allow_obsolete_multiline_headers_in_responses: bool = False</code></li>
<li><code>http1_allow_spaces_after_header_name_in_responses: bool = False</code></li>
<li><code>http1_ignore_invalid_headers_in_responses: bool = False</code></li>
<li><code>http2_prior_knowledge: bool = False</code></li>
<li><code>http2_initial_stream_window_size: int | None = None</code></li>
<li><code>http2_initial_connection_window_size: int | None = None</code></li>
<li><code>http2_adaptive_window: bool = False</code></li>
<li><code>http2_max_frame_size: int | None = None</code></li>
<li><code>http2_max_header_list_size: int | None = None</code></li>
<li><code>http2_keep_alive_interval: Duration | None = None</code></li>
<li><code>http2_keep_alive_timeout: Duration | None = None</code></li>
<li><code>http2_keep_alive_while_idle: bool = False</code></li>
<li><code>pool_idle_timeout: Duration | None = ...,  # 90 second</code></li>
<li><code>pool_max_idle_per_host: int | None = ...,  # usize::MA</code></li>
<li><code>tcp_keepalive: Duration | None = ...,  # 15 second</code></li>
<li><code>tcp_keepalive_interval: Duration | None = ...,  # 15 second</code></li>
<li><code>tcp_keepalive_retries: int | None = 3</code></li>
<li><code>tcp_nodelay: bool = True</code></li>
<li><code>tls_min_version: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None</code></li>
<li><code>tls_max_version: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None</code></li>
<li><code>tls_info: bool = False</code></li>
<li><code>tls_sni: bool = True</code></li>
<li><code>danger_accept_invalid_certs: bool = False</code></li>
<li><code>danger_accept_invalid_hostnames: bool = False</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0061-2025-10-08"><a class="header" href="#v0061-2025-10-08">v0.0.61 [2025-10-08]</a></h2>
<ul>
<li><code>ryo3-std</code>
<ul>
<li>added <code>to_dict</code>/<code>from_dict</code> to <code>ry.Duration</code></li>
</ul>
</li>
<li>use <code>jessekrubin/pyo3-async-runtimes</code> (branch ‘unpaid-interns’) git repo (for
now):
<ul>
<li><a href="https://github.com/PyO3/pyo3-async-runtimes/pull/60">PyO3/pyo3-async-runtimes#60</a></li>
<li><a href="https://github.com/PyO3/pyo3-async-runtimes/pull/62">PyO3/pyo3-async-runtimes#62</a></li>
</ul>
</li>
<li><code>ryo3-uuid</code>
<ul>
<li>supa speedy pydantic support added to <code>ry.uuid.UUID</code> (bc I need it now)</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>ry.Cookie</code> class/struct and <code>cookies</code>/<code>set_cookies</code> properties on the
<code>ry.Response</code> class/struct</li>
</ul>
</li>
<li>removed deprecated <code>.string()</code> methods from several structs/classes:
<ul>
<li><code>ry.FsPath</code></li>
<li><code>ry.UUID</code></li>
<li><code>ry.DateTime</code></li>
<li><code>ry.Date</code></li>
<li><code>ry.SignedDuration</code></li>
<li><code>ry.TimeSpan</code></li>
<li><code>ry.Time</code></li>
<li><code>ry.Timestamp</code></li>
<li><code>ry.ZonedDateTime</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0060-2025-09-26"><a class="header" href="#v0060-2025-09-26">v0.0.60 [2025-09-26]</a></h2>
<ul>
<li>deprecations
<ul>
<li>bump out <code>.string()</code> method deprecation removals to <code>0.0.61</code></li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>ry.FileType</code> struct now has inner faux type/real type</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li><code>strftime</code>/<code>__format__</code> changed to use <code>BrokenDownTime</code> to not panic</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>renamed:
<ul>
<li><code>DirEntryAsync</code> -&gt; <code>AsyncDirEntry</code></li>
<li><code>ReadDirAsync</code> -&gt; <code>AsyncReadDir</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0059-2025-09-24"><a class="header" href="#v0059-2025-09-24">v0.0.59 [2025-09-24]</a></h2>
<ul>
<li><code>ryo3-request</code>
<ul>
<li>switched query/form kwargs to accept anything that can be serde-d via
<code>ryo3-serde</code> which is basically anything that is json-serializable via
<code>ry.stringify</code></li>
</ul>
</li>
<li><code>ry.protocols</code>
<ul>
<li>moved all protocols to <code>ry.protocols</code></li>
</ul>
</li>
<li>deprecations
<ul>
<li>deprecate all <code>obj.string()</code> methods in favor of <code>obj.to_string()</code> tho I
still dont love it in the first place</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>added <code>isoformat</code> and <code>from_isoformat</code> methods to <code>ry.TimeSpan</code> and
<code>ry.SignedDuration</code> structs</li>
</ul>
</li>
<li><code>ryo3-sqlformat</code>
<ul>
<li>Updated to version 0.4.0 of <code>sqlformat</code> crate</li>
<li>Added sqlformat version 0.4.0 new options:
<ul>
<li><code>ignore_case_convert: list[str] | None = None</code></li>
<li><code>inline: bool = False</code></li>
<li><code>max_inline_block: int = 50</code></li>
<li><code>max_inline_arguments: int | None = None</code></li>
<li><code>max_inline_top_level: int | None = None</code></li>
<li><code>joins_as_top_level: bool = False</code></li>
</ul>
</li>
<li>Changed <code>indent</code> arg/kwarg to accept either:
<ul>
<li><code>int</code> (positive integer for number of spaces)</li>
<li><code>str</code> (“tabs”, “\t” or “spaces”)</li>
</ul>
</li>
<li>Changed <code>uppercase</code> arg/kwarg to default to <code>False</code> instead of <code>True</code> to be
more inline with the default behaviour of <code>sqlformat</code> crate</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0058-2025-09-18"><a class="header" href="#v0058-2025-09-18">v0.0.58 [2025-09-18]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>added <code>.__format__()</code> methods to several jiff structs to allow custom
f-string formatting</li>
<li>Fixed <code>SignedDuration.__truediv__</code> operator</li>
</ul>
</li>
<li>internal
<ul>
<li>migrated all <code>downcast*</code> usages to <code>cast*</code></li>
</ul>
</li>
<li>Min python version for ry is now 3.11+</li>
</ul>
<hr>
<h2 id="v0057-2025-09-12"><a class="header" href="#v0057-2025-09-12">v0.0.57 [2025-09-12]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>Added <code>TimeRound</code> python struct</li>
<li>Fixed types for all <code>*Round</code> operations limiting max “smallest” arg literal
types.</li>
<li>Round-api changes
<ul>
<li>builder-y functions and getter functions have been flip-flopped:
<ul>
<li>Switched “builder”-y apis to start with prefix for all <code>*Round</code> structs:
<ul>
<li><code>increment(n: int) -&gt; Self</code> -&gt; <code>_increment(n: int) -&gt; Self</code></li>
<li><code>mode(m: str) -&gt; Self</code> -&gt; <code>_mode(m: str) -&gt; Self</code></li>
<li><code>smallest(unit: str) -&gt; Self</code> -&gt; <code>_smallest(unit: str) -&gt; Self</code></li>
</ul>
</li>
<li>Switched all getter functions to be properties:
<ul>
<li><code>round_obj._increment() -&gt; int</code> -&gt; <code>round_obj.increment -&gt; int</code></li>
<li><code>round_obj._mode() -&gt; str</code> -&gt; <code>round_obj.mode -&gt; str</code></li>
<li><code>round_obj._smallest() -&gt; str</code> -&gt; <code>round_obj.smallest -&gt; str</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>to_dict()</code>
<ul>
<li><code>.asdict()</code> renamed to <code>.to_dict()</code> all structs</li>
<li>renames structs:
<ul>
<li><code>ry.DateTime.asdict()</code> -&gt; <code>ry.DateTime.to_dict()</code></li>
<li><code>ry.Date.asdict()</code> -&gt; <code>ry.Date.to_dict()</code></li>
<li><code>ry.TimeSpan.asdict()</code> -&gt; <code>ry.TimeSpan.to_dict()</code></li>
<li><code>ry.Time.asdict()</code> -&gt; <code>ry.Time.to_dict()</code></li>
<li><code>ry.Headers.asdict()</code> -&gt; <code>ry.Headers.to_dict()</code></li>
</ul>
</li>
<li>Added <code>.to_dict()</code> to:</li>
</ul>
</li>
<li>migrated from <code>xxhash-rust</code> to <code>twox-hash</code> ~ retiring <code>ryo3-xxhash</code> :( - the
<code>xxhash-rust</code> hashers liked to sometimes crash, whereas the <code>twox-hash</code>
py-hashers dont</li>
</ul>
<hr>
<h2 id="v0056-2025-09-05"><a class="header" href="#v0056-2025-09-05">v0.0.56 [2025-09-05]</a></h2>
<ul>
<li><code>ryo3-serde</code>
<ul>
<li>refactoring and testing recursion and stitch</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>Fix: python open mode parsing for <code>aiopen</code> function</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>Add <code>jiter</code> parsing options to <code>Response.json()</code></li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>use <code>#[pyo3(warn(...))]</code> for deprecation warnings instead of doing it
manually</li>
<li>fixed utc methods to use <code>.with_time_zone(TimeZone::UTC)</code> instead of
<code>.in_tz("UTC")</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0055-2025-09-03"><a class="header" href="#v0055-2025-09-03">v0.0.55 [2025-09-03]</a></h2>
<ul>
<li>upgrade pyo3 v0.26.x</li>
<li><code>ryo3-bytes</code>
<ul>
<li>Update buffer usage based on kyle barron <code>pyo3-bytes</code>
<a href="https://github.com/developmentseed/obstore/commit/2ca22a8c3949ae51fbf750ef5a08e3a76f583819">changes</a></li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>Make each sub-module a feature flag <code>std-net</code>, <code>std-fs</code>, <code>std-time</code>, etc…</li>
</ul>
</li>
<li>internal changes
<ul>
<li>Implemented <code>Display</code> for several types for use in their <code>__repr__</code> methods</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0054-2025-08-28"><a class="header" href="#v0054-2025-08-28">v0.0.54 [2025-08-28]</a></h2>
<ul>
<li><code>ryo3-std</code>
<ul>
<li>Serialization for std types</li>
<li>Speed run of socketaddr types (WIP); needs more testing and the socket types
could be cleaner…</li>
</ul>
</li>
<li><code>ryo3-memchr</code>
<ul>
<li>Basic functionality for <code>memchr</code> and <code>memrchr</code> operations</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Changed <code>human</code> arg/kwarg in <code>ry.TimeSpan</code> and <code>ry.SignedDuration</code> to
<code>friendly</code> and also make keyword only</li>
<li>Changed <code>strptime</code> and <code>strftime</code> functions to be more inline with python’s
<code>datetime</code> module by changing the order of args to be <code>(string, format)</code>
instead of <code>(format, string)</code>; the strptime signature is
<code>strptime(s: str, /, fmt: str) -&gt; Self</code></li>
<li>Added to <code>ry.TimeSpan</code> and <code>ry.SignedDuration</code> the <code>friendly</code> method for
more natural string representations</li>
<li>Many internal refactors and cleanup</li>
<li>Converted all <code>__repr__</code> methods to use struct <code>Display</code> impls</li>
<li>Fixed rounding object repr function(s) and added pickling and tests for
round objects</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>Missing <code>lstrip</code>/<code>rstrip</code> method types for <code>ry.Bytes</code></li>
<li>Updated types for <code>ry.TimeSpan</code> and <code>ry.SignedDuration</code> w/ correct
<code>friendly</code> kwarg and <code>friendly()</code> methods</li>
</ul>
</li>
<li>Added ruff <code>A002</code> lint</li>
<li>Added ruff <code>FBT</code> lints</li>
</ul>
<hr>
<h2 id="v0053-2025-08-18"><a class="header" href="#v0053-2025-08-18">v0.0.53 [2025-08-18]</a></h2>
<ul>
<li><code>ry</code>
<ul>
<li>Bump min python version 3.10 – this is a breaking change, but ry is still
very much a WIP/in-beta, so the versioning schema is “yolo-versioning”</li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>internal refactoring and cleanup</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0052-2025-07-30"><a class="header" href="#v0052-2025-07-30">v0.0.52 [2025-07-30]</a></h2>
<ul>
<li><code>ryo3-bytes</code>
<ul>
<li>internal refactoring</li>
<li>added
<ul>
<li><code>ry.Bytes.__rmul__</code></li>
<li><code>ry.Bytes.lstrip</code></li>
<li><code>ry.Bytes.rstrip</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-xxhash</code>
<ul>
<li>all xxhash-ing classes are now <code>frozen</code> pyclasses
<a href="https://github.com/jessekrubin/ry/issues/259">#259</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0051-2025-07-25"><a class="header" href="#v0051-2025-07-25">v0.0.51 [2025-07-25]</a></h2>
<ul>
<li><code>ryo3-bytes</code>
<ul>
<li>Separated <code>pyo3-bytes</code> and <code>ryo3-bytes</code>
<ul>
<li><code>pyo3-bytes</code> mirrors the official <code>pyo3-bytes</code> crate + extra methods, BUT
it requires the <code>multiple-pymethods</code> feature to be enabled</li>
<li><code>ryo3-bytes</code> is a crammed together version of the <code>pyo3-bytes</code>
implementation and extra methods and does NOT require the
<code>multiple-pymethods</code> feature to be enabled</li>
</ul>
</li>
<li>Made <code>PythonBytesMethods</code> trait for the methods that are shared between
<code>pyo3-bytes</code> and <code>ryo3-bytes</code></li>
</ul>
</li>
<li><code>ryo3-ulid</code>
<ul>
<li>strict + lax ulid parsing for pydantic</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Renamed <code>checked_add</code> and <code>checked_sub</code> to <code>add</code> and <code>sub</code> where the
checked_version can error; did not remove where the checked version returns
an <code>Option</code> type (<code>ry.SignedDuration</code>). <code>.checked_add</code> may return later as a
method that returns an <code>Option</code> type for all types (tbd). This is also meant
to pave the way for <code>add</code>/<code>sub</code> functions with a more familiar api akin to
<code>whenever</code>, <code>pendulum</code>, <code>arrow</code>, <code>insert-other-datetime-lib-here</code></li>
<li>Added <code>replace</code> methods to <code>Date</code>, <code>DateTime</code> and <code>Time</code> structs that use
the underlying jiff <code>with</code> functions</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0050-2025-07-14"><a class="header" href="#v0050-2025-07-14">v0.0.50 [2025-07-14]</a></h2>
<ul>
<li>internal
<ul>
<li>clippy lint fixes <code>unused_self</code> (all but <code>ryo3-bytes</code> which needs its own
cleanup)</li>
</ul>
</li>
<li><code>ryo3-bytes</code>
<ul>
<li>Added (bc I need them) more python compat methods:
<ul>
<li><code>title()</code></li>
<li><code>swapcase()</code></li>
<li><code>expandtabs()</code></li>
<li><code>strip()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>Added <code>open</code> method that forwards to <code>open</code> method of <code>pathlib.Path</code></li>
<li>Added <code>mkdir</code> method that mimics <code>mkdir</code> method of <code>pathlib.Path</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0049-2025-07-04-fourth-o-july"><a class="header" href="#v0049-2025-07-04-fourth-o-july">v0.0.49 [2025-07-04] (fourth o july)</a></h2>
<ul>
<li>workspace
<ul>
<li>set rust edition to 2024</li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>Fixed recursive serialization w/ max depth of 255 (aligning with <code>orjson</code>)</li>
<li>support <code>PyEllipsis</code> for <code>None</code> values in serialization</li>
</ul>
</li>
<li><code>ryo3-json</code>
<ul>
<li><code>minify</code> function to remove whitespace/newlines from json-string/bytes</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>internal refactoring</li>
<li><code>isoformat</code> methods aligned with python’s <code>datetime</code> library methods</li>
<li>Freeze (make pyclass frozen) for all jiff types (changed <code>*Series</code>
iterables)</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li><code>which</code> feature allowing <code>FsPath.which</code> and <code>FsPath.which_all</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0048-2025-06-24"><a class="header" href="#v0048-2025-06-24">v0.0.48 [2025-06-24]</a></h2>
<ul>
<li><code>ryo3-json</code>
<ul>
<li><code>pybytes</code> bool kwargs to return <code>builtins.bytes</code> if <code>True</code> and <code>ry.Bytes</code> if
<code>False</code>; default is <code>False</code></li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>support for types defined in <code>ryo3-http</code></li>
<li>support for <code>default</code> kwarg that is passed to the serde serializer; like w/
the stdlib-json and orjson serializers, this allows for serializing types
that are not natively supported by ry/serde and if failure should occur, it
should raise a <code>TypeError</code> or <code>ValueError</code> instead of returning <code>None</code> by
default</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>json</code> kwarg added to request builders that auto-serializes via
<code>ryo3-serde</code>; also because it uses the <code>reqwest::RequestBuilder</code> it auto
sets the <code>Content-Type</code> header to <code>application/json</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0047-2025-06-17"><a class="header" href="#v0047-2025-06-17">v0.0.47 [2025-06-17]</a></h2>
<ul>
<li>pyo3 v0.25.1</li>
<li><code>ryo3-serde</code> (wip)
<ul>
<li>serializers for <code>PyAny</code> and more</li>
<li>this should theoretically allow for serializing any python object that is
<code>serde</code> serializable with almost any <code>serde</code> serializer… that is the goal</li>
</ul>
</li>
<li><code>ryo3-json</code>
<ul>
<li>Where json stuff + ry is going to live in the near future (may consolidate
<code>ryo3-jiter</code> into this newer crate)</li>
<li><code>ry.stringify()</code> uses <code>ryo3-serde</code> + <code>serde_json</code> to write json bytes/bufs
and it is pretty fast, faster than ujson and rapidjson (not tested yyjson),
BUT orjson is still fastest (read a bunch of their code and it is remarkably
advanced and optimized)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0046-2025-06-06"><a class="header" href="#v0046-2025-06-06">v0.0.46 [2025-06-06]</a></h2>
<ul>
<li>version 0.0.46</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>ResponseStream</code>
<ul>
<li>Added <code>__repr__</code> method</li>
<li>Added <code>async def take(self, n: int=1): ...</code> method returns n chunks as a
list</li>
<li>Added <code>async def collect(self: join = False) -&gt; ...:</code> method that collects
the stream into a single <code>ry.Bytes</code> object if <code>join=True</code> or a list of
<code>ry.Bytes</code> objects if <code>join=False</code></li>
<li>Added <code>async def take(self, n: int=1): ...</code> which returns n chunks as a
list</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>add <code>dtype</code> kwarg that takes either <code>dtype=str | ry.FsPath | pathlib.Path</code>
as type of obj yielded by the iterable; something about this feels really
icky, the default may be changed to <code>str</code> (from <code>pathlib.Path</code>)</li>
</ul>
</li>
<li><code>ryo3-ulid</code>
<ul>
<li>Added mostly as a way to test how much pydantic + ry integration would be</li>
</ul>
</li>
<li><code>ryo3-which</code>
<ul>
<li>upgrade which to version 8</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0045-2025-05-30"><a class="header" href="#v0045-2025-05-30">v0.0.45 [2025-05-30]</a></h2>
<ul>
<li>added <code>__target__</code> to python package metadata in <code>ry.__about__</code> with the
target triple of the current build</li>
<li><code>ryo3-std</code>
<ul>
<li>Buffering for <code>FileReadStream</code></li>
</ul>
</li>
<li><code>ryo3-jiter</code>
<ul>
<li>Add function <code>parse_jsonl</code> for parsing json lines</li>
<li>Add <code>lines</code> kwarg to <code>read_json</code> for parsing/reading json lines</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>
<p><code>ZonedDateTime.__new__</code> takes more python-datetime like args/kwargs, old
version of constructor moved to classmethod
<code>ZonedDateTime.from_parts(timestamp: ry.Timestamp, tz: ry.TimeZone) -&gt; ZonedDateTime</code></p>
</li>
<li>
<p><code>zoned</code> top level function</p>
<ul>
<li>if <code>tz</code> is <code>None</code> then it uses the system timezone</li>
<li>SIGNATURE</li>
</ul>
<pre><code class="language-python">def zoned(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
    tz: str | None = None,
) -&gt; ZonedDateTime: ...
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0044-2025-05-23"><a class="header" href="#v0044-2025-05-23">v0.0.44 [2025-05-23]</a></h2>
<ul>
<li>internal:
<ul>
<li>renamed <code>ryo3-macros</code> to <code>ryo3-macro-rules</code></li>
</ul>
</li>
<li>docs
<ul>
<li>Cleaned up <code>./README.md</code></li>
<li>Removed type-annotations from <code>./README.md</code></li>
</ul>
</li>
<li>pyo3-v0.25.0</li>
<li>py-types
<ul>
<li>reqwest-request functions use <code>TypedDict</code> and <code>Unpack</code></li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>serde serialization features/support</li>
<li><code>ry.ZonedDateTime.replace</code> method mirroring <code>ZonedWith</code> – <code>with</code> is a
python keyword, so used <code>replace</code> instead</li>
<li>example script based on jiff-docs examples</li>
<li><code>test_jiff_examples_v2.py</code> test script (basis for example script)
<ul>
<li>Was tired/fried so I copy-pasta-ed the <code>ry/ryo3/_jiff.pyi</code> type
annotations, the jiff-v2-docs-examples, and the jiff-v1-hand-translated
<code>test_jiff_examples_v1.py</code> file into Chad-Gippity who was able to do most
of the translation from <code>rust</code> to <code>ry</code>…</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-xxhash</code>
<ul>
<li>Align with <code>xxhash</code> pypi library w/ respect to naming conventions</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0043-2025-05-17"><a class="header" href="#v0043-2025-05-17">v0.0.43 [2025-05-17]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>panic-able functions to create new/altered (time)spans moved to use <code>try_*</code></li>
</ul>
</li>
<li>fix: anyio marker flat issue in pytests for cicd</li>
<li><code>ryo3-uuid</code>
<ul>
<li>added <code>uuid</code> wrapper for <code>uuid</code> crate; ty to the maintainers of <code>uuid-utils</code>
and <code>fastuuid</code> for helping figure out some of the nitty gritty bits and bobs</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>AsyncFile</code> and <code>aiopen</code> experiment(s) added for async file reading/writing
etc</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0042-2025-05-12"><a class="header" href="#v0042-2025-05-12">v0.0.42 [2025-05-12]</a></h2>
<ul>
<li>panic=abort
<ul>
<li>panic is now (maybe will go back) <code>abort</code> for release builds</li>
<li>means smaller binaries and faster error handling (in theory)</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>more type fixes to response</li>
<li>Got response type more inline with other python http-client libraries</li>
<li>try <code>parking_lot</code> for default <code>reqwest</code> client mutex</li>
<li>include missing kwargs for fetch functions</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>freeze struct(s) to be frozen</li>
</ul>
</li>
<li><code>ryo3-http</code>
<ul>
<li>http version python conversions to/from string/int</li>
<li>crude-ish serde implementation for <code>HeadersMap</code> for json
encoding/decoding… was a lot of googling</li>
<li>status code reason(s) interned</li>
<li>intern all standard http header-names</li>
</ul>
</li>
<li><code>ryo3-fnv</code>
<ul>
<li>align with hashlib style hashing</li>
</ul>
</li>
<li>deps-up
<ul>
<li>pyo3 version 0.24.2</li>
<li>brotli 8</li>
<li>jiff patch</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0041-2025-04-18"><a class="header" href="#v0041-2025-04-18">v0.0.41 [2025-04-18]</a></h2>
<ul>
<li><code>ryo3-jiter</code>
<ul>
<li>added <code>read_json</code> function to read from path-like obj</li>
</ul>
</li>
<li><code>ryo3-bytes</code>
<ul>
<li>misc small improvements and tests</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>ry.IpAddr</code> added to handle both ipv4/ipv6</li>
<li><code>ry.read_dir</code> implemented</li>
</ul>
</li>
<li><code>ryo3-walkdir</code>
<ul>
<li>added <code>objects</code> impl and example script</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>ry.read_dir_async</code> implemented; also contains fancy async take/collect</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0040-2025-04-11"><a class="header" href="#v0040-2025-04-11">v0.0.40 [2025-04-11]</a></h2>
<ul>
<li>scripts
<ul>
<li><code>dl_versions.py</code> script to download all versions of ry while ry is still
pre-1-point-oh and old version(s) are being nuked from pypi as needed</li>
</ul>
</li>
<li>types
<ul>
<li>fix types for few packages</li>
</ul>
</li>
<li>Updated several dependencies ~ most notably <code>pyo3</code> to <code>0.24.1</code></li>
<li>Fixed several new clippy lints that appear in CI stable rust builds</li>
<li><code>ryo3-std</code>
<ul>
<li><code>std::net</code> ipv4/ipv6 wrappers speed run impl</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0039-2025-03-14"><a class="header" href="#v0039-2025-03-14">v0.0.39 [2025-03-14]</a></h2>
<ul>
<li>internal
<ul>
<li>cleaned up several dependencies and features</li>
</ul>
</li>
<li><code>ryo3-zstd</code>
<ul>
<li>actually changed to use py buffer protocol this time… I dont know how it
got missed before…</li>
<li>re-factored a decent bit and made submodule with future plans to expand
encoding/decoding dictionary support</li>
<li>submodule is <code>ry.zstd</code> and/or <code>ry.ryo3.zstd</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0038-2025-03-13"><a class="header" href="#v0038-2025-03-13">v0.0.38 [2025-03-13]</a></h2>
<ul>
<li><code>ryo3-reqwest</code>
<ul>
<li>client configuration for pickling</li>
<li>allow buffer-protocol for <code>body</code> fetching methods (should add string maybe?)</li>
</ul>
</li>
<li><code>ryo3-walkdir</code>
<ul>
<li>Few more options added</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>new wrapper around <code>glob</code> crate</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Switched to use conversions from <code>jiff</code> feature of <code>pyo3-v24</code> as opposed to
hand-rolled conversions we had before</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0037-2025-03-11"><a class="header" href="#v0037-2025-03-11">v0.0.37 [2025-03-11]</a></h2>
<ul>
<li>pyo3 version <code>0.24.0</code></li>
<li><code>ryo3-which</code> functions return <code>pathlib.Path</code> now due to changes in pyo3-v24;
this may change in the near future…</li>
</ul>
<hr>
<h2 id="v0036-2025-03-11"><a class="header" href="#v0036-2025-03-11">v0.0.36 [2025-03-11]</a></h2>
<ul>
<li>dependencies updated</li>
<li>pickling support and tests for several types</li>
<li>bytes/buffer-protocol support for several sub-packages/packages:
<ul>
<li><code>ryo3-brotli</code></li>
<li><code>ryo3-bzip2</code></li>
<li><code>ryo3-flate2</code></li>
<li><code>ryo3-fnv</code></li>
<li><code>ryo3-xxhash</code></li>
<li><code>ryo3-zstd</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0035-2025-03-06"><a class="header" href="#v0035-2025-03-06">v0.0.35 [2025-03-06]</a></h2>
<ul>
<li>internal
<ul>
<li>types split up and cleaned up</li>
</ul>
</li>
<li><code>ryo3-size</code>
<ul>
<li><code>ry.Size</code> object</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li><code>series</code> iterators have <code>take</code> function that takes a <code>usize</code> returns a list
of size <code>usize</code></li>
<li>updated series types to be <code>JiffSeries</code> class</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0034-2025-02-28"><a class="header" href="#v0034-2025-02-28">v0.0.34 [2025-02-28]</a></h2>
<ul>
<li><code>ryo3-std</code>
<ul>
<li><code>fs</code>:
<ul>
<li><code>read_stream</code> function that returns an iterator of <code>ry.Bytes</code> objects from
a <code>PathLike</code> object</li>
<li>Several more fs functions added</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>Several more tokio fs functions added</li>
</ul>
</li>
<li>internal
<ul>
<li>reorganized type annotations to be not a HUGE file…</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0033-2025-02-26"><a class="header" href="#v0033-2025-02-26">v0.0.33 [2025-02-26]</a></h2>
<ul>
<li>update to pyo3 v0.23.5</li>
</ul>
<hr>
<h2 id="v0032-2025-02-25"><a class="header" href="#v0032-2025-02-25">v0.0.32 [2025-02-25]</a></h2>
<ul>
<li><code>ryo3-jiter</code>
<ul>
<li>Allow <code>PyBytes</code> wrapper/buffer protocol to be given</li>
<li>renamed <code>jiter_cache_clear</code> to <code>json_cache_clear</code> and <code>jiter_cache_usage</code> to
<code>json_cache_usage</code></li>
<li>Removed <code>parse_json_str</code> just use <code>parse_json</code> with <code>str</code> input</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>Allow read/write to take <code>ry.Bytes</code> or <code>Bytes</code> objects</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0031-2025-02-21"><a class="header" href="#v0031-2025-02-21">v0.0.31 [2025-02-21]</a></h2>
<ul>
<li><code>ryo3-core</code>
<ul>
<li>got rid of <code>ryo3-types</code> and moved into <code>ryo3-core</code></li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>read_async</code> and <code>write_async</code> async functions</li>
</ul>
</li>
<li><code>ryo3-which</code>
<ul>
<li><code>which_re</code> functions accepts <code>ry.Regex</code> or <code>str</code> now</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>read</code> and <code>write</code> functions which take/return <code>ry.Bytes</code> objects</li>
</ul>
</li>
<li><code>internal</code>
<ul>
<li>Changed many many many of the structs/classes to be pyo3 <code>frozen</code> behaviour
should not be different</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0030-2025-02-18"><a class="header" href="#v0030-2025-02-18">v0.0.30 [2025-02-18]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Upgraded jiff to version 2</li>
</ul>
</li>
<li>internal
<ul>
<li>Switch all lints from <code>#[allow(...)]</code>/<code>#![allow(...)]</code> to
<code>#[expect(...)]</code>/<code>#![expect(...)]</code></li>
<li>Removed a bunch o commented out code</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>added several <code>std::fs</code> structs</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>conversion to <code>pathlib.Path</code> by way of <code>FsPath.to_pathlib()</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0029-2025-02-03"><a class="header" href="#v0029-2025-02-03">v0.0.29 [2025-02-03]</a></h2>
<ul>
<li>internal
<ul>
<li>Made sure each <code>ryo3-*</code> crate has a <code>README.md</code></li>
</ul>
</li>
<li><code>ryo3-bytes</code> &amp; <code>ryo3-fspath</code>
<ul>
<li>added <code>__hash__</code> dunders to both <code>Bytes</code> and <code>FsPath</code> structs</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0028-2025-01-31"><a class="header" href="#v0028-2025-01-31">v0.0.28 [2025-01-31]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Per Mr. Sushi’s thoughts changed all <code>until</code>/<code>since</code> methods to use kwargs
instead of the rust-like tuples that impl <code>From</code>/<code>Into</code> as it does not
translate well to python</li>
<li>Gets rid of the following inane types:</li>
</ul>
</li>
</ul>
<pre><code class="language-python">IntoDateDifference = (
    DateDifference
    | Date
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimeDifference = (
    TimeDifference
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoDateTimeDifference = (
    DateTimeDifference
    | Date
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimestampDifference = (
    TimestampDifference
    | Timestamp
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Timestamp]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
</code></pre>
<hr>
<h2 id="v0027-2025-01-23"><a class="header" href="#v0027-2025-01-23">v0.0.27 [2025-01-23]</a></h2>
<ul>
<li><code>ry</code>
<ul>
<li>Warning on <code>debug</code> build</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>headers-property response returns <code>Headers</code> object instead of python dict</li>
</ul>
</li>
<li><code>same-file</code>
<ul>
<li>wrapper module added with <code>is_same_file</code> py-fn (yet another piece of burnt
sushi)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>jiff-version <code>0.1.25</code> ~ add <code>in_tz</code> methods and point old <code>intz</code> at new
<code>in_tz</code> methods and raise <code>DeprecationWarning</code> for old <code>intz</code> methods</li>
<li>Continued adding implementations that previously raised
<code>NotImplementedError</code>
<ul>
<li><code>Date.nth_weekday_of_month</code></li>
<li><code>Date.nth_weekday</code></li>
<li><code>DateTime.nth_weekday_of_month</code></li>
<li><code>DateTime.nth_weekday</code></li>
<li><code>TimeSpan.compare</code></li>
<li><code>TimeSpan.total</code></li>
<li><code>ZonedDateTime.nth_weekday_of_month</code></li>
<li><code>ZonedDateTime.nth_weekday</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0026-2025-01-13"><a class="header" href="#v0026-2025-01-13">v0.0.26 [2025-01-13]</a></h2>
<ul>
<li><code>reqwest</code>
<ul>
<li><code>AsyncClient</code> renamed to <code>HttpClient</code></li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>human timespan strings for <code>TimeSpan</code> and <code>SignedDuration</code> objects:
<ul>
<li><code>ry.TimeSpan.parse("P2M10DT2H30M").string(human=True) == "2mo 10d 2h 30m"</code></li>
<li><code>ry.SignedDuration.parse("PT2H30M").string(human=True) == "2h 30m"</code></li>
</ul>
</li>
</ul>
</li>
<li>internal
<ul>
<li>workspace-ified all the deps</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0025-2024-01-07-25-for-2025"><a class="header" href="#v0025-2024-01-07-25-for-2025">v0.0.25 [2024-01-07] (25 for 2025)</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Updated to <code>0.1.21</code> which has span and signed duration strings with capital
letters</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0024-2024-12-24-the-night-b4-xmas"><a class="header" href="#v0024-2024-12-24-the-night-b4-xmas">v0.0.24 [2024-12-24] (the night b4 xmas…)</a></h2>
<ul>
<li><code>http</code>
<ul>
<li>basic headers struct/obj – WIP</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>reqwest client (currently root-export)</li>
<li>default client + root <code>fetch</code> function likely needs work…</li>
<li>response <code>byte_stream</code>!</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0023-2024-12-19"><a class="header" href="#v0023-2024-12-19">v0.0.23 [2024-12-19]</a></h2>
<ul>
<li><code>python -m ry.dev</code> repl for ipython/python repl ~ handy nifty secret tool
makes it into repo</li>
<li>internal
<ul>
<li>in process of renaming all python-rust <code>#[new]</code> functions to be named
<code>fn py_new(...)</code></li>
</ul>
</li>
<li><code>unindent</code>
<ul>
<li>Added <code>unindent</code> module for unindenting strings will move to <code>ryo3-unindent</code></li>
</ul>
</li>
<li><code>FsPath</code>
<ul>
<li>creeping ever closer to being a full-fledged pathlib.Path replacement</li>
<li>Added bindings to all rust <code>std::path::Path(buf)</code> methods for <code>FsPath</code></li>
</ul>
</li>
<li>sub-packaging
<ul>
<li><code>xxhash</code> is own sub package now <code>ry.xxhash</code></li>
<li><code>JSON</code> is own subpackage right now – named <code>ry.JSON</code> to avoid conflict with
<code>json</code> module but maybe will change…</li>
<li>food-for-thought-ing how <code>ryo3</code> and <code>ry</code> should be organized w/ respsect to
sub-packages and where that organization should be</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>required to break up the type annotations due to migration to sub-packages</li>
<li>breaking up the type annotations file into smaller files under
<code>&lt;REPO&gt;/python/ry/ryo3/*.pyi</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0022-2024-12-16"><a class="header" href="#v0022-2024-12-16">v0.0.22 [2024-12-16]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Super simple regex wrapper (must to do here, but was added for
<code>ryo3-which::which_re</code>)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li><code>until</code>/<code>since</code>
<ul>
<li>Basic <code>until</code>/<code>since</code> implementation but I do not like them and they
confusingly named <code>*Difference</code> structs/py-objects, so I may change how
they work…</li>
</ul>
</li>
<li><code>jiff</code> seems to be about as performant as <code>whenever</code> ~ yay! also the
whenever dude appears to be watching this repo (as of 2024-12-16)</li>
</ul>
</li>
<li><code>walkdir</code>
<ul>
<li><code>collect</code> added to <code>WalkdirGen</code> to collect the results into a list</li>
</ul>
</li>
<li>deps
<ul>
<li><code>thiserror</code> version <code>2.0.7</code> -&gt; <code>2.0.8</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0021-2024-12-13-friday-the-13th-spoogidy-oogidity"><a class="header" href="#v0021-2024-12-13-friday-the-13th-spoogidy-oogidity">v0.0.21 [2024-12-13] (friday the 13th… spoogidy oogidity)</a></h2>
<ul>
<li><code>walkdir</code>
<ul>
<li>add <code>glob</code> kwarg that takes a <code>ry.Glob</code> or <code>ry.GlobSet</code> or <code>ry.Globster</code> obj
to filter the walk on</li>
</ul>
</li>
<li><code>globset</code>
<ul>
<li>Internal refactoring</li>
<li>added <code>globster()</code> method to <code>ry.Glob</code> and <code>ry.GlobSet</code> to return a
<code>ry.Globster</code> obj</li>
<li>added <code>globset()</code> method to <code>ry.Glob</code> to return a <code>ry.GlobSet</code> obj from a
<code>ry.Glob</code> obj</li>
</ul>
</li>
<li><code>url</code>
<ul>
<li>python <code>Url</code> changed name <code>URL</code>; aligns with jawascript and other python
libs</li>
</ul>
</li>
<li><code>bzip2</code>
<ul>
<li>update to v5</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>conversions for jiff-round-mode/unit/weekday</li>
<li>not-implemented placeholders and new impls
<ul>
<li><input disabled="" type="checkbox" checked=""> <code>RyDateTime</code></li>
<li><input disabled="" type="checkbox" checked=""> <code>RyDate</code></li>
<li><input disabled="" type="checkbox" checked=""> <code>RyOffset</code></li>
<li><input disabled="" type="checkbox" checked=""> <code>RySignedDuration</code></li>
<li><input disabled="" type="checkbox" checked=""> <code>RySpan</code></li>
<li><input disabled="" type="checkbox" checked=""> <code>RyTimeZone</code></li>
<li><input disabled="" type="checkbox" checked=""> <code>RyTime</code></li>
<li><input disabled="" type="checkbox" checked=""> <code>RyZoned</code></li>
</ul>
</li>
<li>span builder functions use form <code>s._hours(1)</code> for panic-inducing building,
and <code>s.try_hours(1)</code> for non-panic-inducing building</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>fixes and updates and a hacky script I wrote to check for discrepancies</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0020-2024-12-10"><a class="header" href="#v0020-2024-12-10">v0.0.20 [2024-12-10]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Templated out regex package but nothing added</li>
</ul>
</li>
<li><code>ry</code>
<ul>
<li>python 3.13 yay!</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated jiter version thanks depbot!</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0019-2024-12-05"><a class="header" href="#v0019-2024-12-05">v0.0.19 [2024-12-05]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>py-conversions
<ul>
<li><input disabled="" type="checkbox" checked=""> <code>JiffDateTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""> <code>JiffDate</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""> <code>JiffOffset</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""> <code>JiffSignedDuration</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""> <code>JiffSpan</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""> <code>JiffTimeZone</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""> <code>JiffTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""> <code>JiffZoned</code>
<ul>
<li><input disabled="" type="checkbox" checked=""> FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""> IntoPyObject (REF)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0018-2024-12-03"><a class="header" href="#v0018-2024-12-03">v0.0.18 [2024-12-03]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Renamed <code>ry.Span</code> to <code>ry.TimeSpan</code></li>
<li>Renamed <code>ry.Zoned</code> to <code>ry.ZonedDateTime</code></li>
<li>Updated type stubs to reflect renames</li>
</ul>
</li>
<li>docs
<ul>
<li>init-ed the docs</li>
<li>style guide under <code>DEVELOPMENT.md</code> file</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0017-2024-12-02"><a class="header" href="#v0017-2024-12-02">v0.0.17 [2024-12-02]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li><code>ry.TimeZone</code> testing and to/from <code>datetime.tzinfo</code> conversions</li>
<li>Using nu-types for <code>jiff</code> intermediate types bc of the classic orphans
problem (aka batman) w/ traits</li>
<li>hypothesis tests</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated to <code>jiter</code> v0.8.1</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0016-2024-11-29"><a class="header" href="#v0016-2024-11-29">v0.0.16 [2024-11-29]</a></h2>
<ul>
<li>Moved walkdir to <code>ryo3-walkdir</code></li>
<li>added <code>ryo3-types</code> for custom and shared types</li>
<li><code>heck</code> wrapper(s)</li>
<li>jiff
<ul>
<li>Added operators <code>+</code>/<code>+=</code>/<code>-</code>/<code>-=</code> to date/time/datetime/etc</li>
<li>TODO: figure out how to take refs in the union enum for the operators</li>
</ul>
</li>
<li>fspath
<ul>
<li>further beefing out as well as testing</li>
</ul>
</li>
</ul>
<hr>
<h2 id="v0015-2024-11-20"><a class="header" href="#v0015-2024-11-20">v0.0.15 [2024-11-20]</a></h2>
<ul>
<li><code>from __future__ import annotations</code> added to all modules</li>
<li>cicd updated to include more targets</li>
</ul>
<hr>
<h2 id="v0014-2024-11-20"><a class="header" href="#v0014-2024-11-20">v0.0.14 [2024-11-20]</a></h2>
<ul>
<li>Primitive/crude wrappers around Mr. Sushi’s <code>jiff</code> library</li>
<li>Updated to use pyo3 (had to use jiter git repo dep)</li>
<li><code>ry.FsPath</code> beefed out</li>
<li>Added iterdir gen wrapper</li>
<li>(todo undo when jiter + pyo3 23 is public)</li>
</ul>
<hr>
<h2 id="v0013-2024-11-20"><a class="header" href="#v0013-2024-11-20">v0.0.13 [2024-11-20]</a></h2>
<ul>
<li><strong>VERSION SKIPPED DUE TO <code>13</code> BEING SPOOKY AND ME BEING MODERATELY-STITCHOUS
(AKA fully ‘superstitchous’)</strong></li>
</ul>
<hr>
<h2 id="v0012-2024-11-14"><a class="header" href="#v0012-2024-11-14">v0.0.12 [2024-11-14]</a></h2>
<ul>
<li>sqlformat wrapper(s) (this is the first <code>ryo3-*</code> sub-crate)</li>
</ul>
<hr>
<h2 id="v0011-2024-09-22"><a class="header" href="#v0011-2024-09-22">v0.0.11 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
<li>prepare for python 3.13</li>
</ul>
<hr>
<h2 id="v0010-2024-09-22"><a class="header" href="#v0010-2024-09-22">v0.0.10 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
</ul>
<hr>
<h2 id="v009-2024-08-22"><a class="header" href="#v009-2024-08-22">v0.0.9 [2024-08-22]</a></h2>
<ul>
<li>Added <code>globset</code> wrapper(s)</li>
<li>Added <code>__init__.py</code> generator</li>
</ul>
<hr>
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<h2 id="v008-2024-06-25"><a class="header" href="#v008-2024-06-25">v0.0.8 [2024-06-25]</a></h2>
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<hr>
<h2 id="v007-2024-06-08"><a class="header" href="#v007-2024-06-08">v0.0.7 [2024-06-08]</a></h2>
<ul>
<li>internal refactoring</li>
</ul>
<hr>
<h2 id="v006-2024-06-05"><a class="header" href="#v006-2024-06-05">v0.0.6 [2024-06-05]</a></h2>
<ul>
<li>Added zstd (<code>zstd_encode</code>/<code>zstd</code> and <code>zstd_decode</code>)</li>
<li>Added gzip (<code>gzip_encode</code>/<code>gzip</code> and <code>gzip_decode</code>/<code>gunzip</code>)</li>
<li>Added bzip2 (<code>bzip2_encode</code>/<code>bzip2</code> and <code>bzip2_decode</code>)</li>
<li>Added walkdir</li>
<li>Reorg libs</li>
</ul>
<hr>
<h2 id="v005-2024-04-19"><a class="header" href="#v005-2024-04-19">v0.0.5 [2024-04-19]</a></h2>
<ul>
<li>Added brotli (<code>brotli_encode</code> and <code>brotli_decode</code>)</li>
<li>xxhash
<ul>
<li>const functions</li>
<li>hasher streaming objects</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_open"><a class="header" href="#async_open">async_open</a></h1>
<pre><code class="language-python">"""Async-file ops.

Demos:
- async file write/read
- async iteration o-lines
- async chunked reading (via read_stream_async)
- seeking/truncating

"""

import asyncio

import ry


async def main() -&gt; None:
    # write
    async with ry.aopen("stuff-async.txt", mode="wb") as f:
        await f.write(b"hello\n")
        await f.write(b"world\n")

    # read
    async with ry.aopen("stuff-async.txt", mode="rb") as f:
        content = await f.read()
        print(f"data: {content!r}")

    # reading lines
    print("Iterating over lines:")
    async with ry.aopen("stuff-async.txt", mode="rb") as f:
        async for line in f:
            print(f"&gt;&gt;&gt; line: {line!r}")

    # reading chunks (w/ read_size of 4 (bytes))
    stream = await ry.read_stream_async("stuff-async.txt", read_size=4)
    async for chunk in stream:
        print(f"&gt;&gt;&gt; chunk: {chunk!r}")

    # seeking/truncating
    async with ry.aopen("stuff-async.txt", mode="rb+") as f:
        await f.seek(6)
        word = await f.read(5)
        print(f"read (seek-6): {word!r}")

        # truncate
        await f.truncate(6)

    # we good?
    async with ry.aopen("stuff-async.txt", mode="rb") as f:
        final_content = await f.read()
        assert final_content == b"hello\n"
        print(f"final content after truncate: {final_content!r}")

    # housekeeping
    await ry.remove_file_async("stuff-async.txt")


if __name__ == "__main__":
    asyncio.run(main())
</code></pre>
<h1 id="fspath"><a class="header" href="#fspath">fspath</a></h1>
<pre><code class="language-python">import ry

# get current directory
current_dir = ry.FsPath.cwd()

# write file
(current_dir / "test.txt").write_text("data!")

# read file
data = (current_dir / "test.txt").read_text()
print(data)
</code></pre>
<h1 id="get"><a class="header" href="#get">get</a></h1>
<pre><code class="language-python">"""Example of `ry.fetch` (async) and `ry.fetch_sync` (blocking)"""

import asyncio

import ry

try:
    from rich import print as echo
except ImportError:
    echo = print  # type: ignore[assignment]


async def main_async() -&gt; None:
    response = await ry.fetch("https://httpbingo.org/anything")
    echo("Raw response:", response)
    echo("socket:", response.remote_addr)
    echo("url:", response.url)
    echo("status:", response.status)
    echo("headers:", response.headers)
    echo("http-version:", response.http_version)
    echo("content-length:", response.content_length)
    json_data = await response.json()
    echo("JSON data: ", json_data)
    echo("stringified: ", ry.stringify(json_data, fmt=True).decode())


def main_sync() -&gt; None:
    response = ry.fetch_sync("https://httpbingo.org/anything")
    echo("Raw response:", response)
    echo("socket:", response.remote_addr)
    echo("url:", response.url)
    echo("status:", response.status)
    echo("headers:", response.headers)
    echo("http-version:", response.http_version)
    echo("content-length:", response.content_length)
    json_data = response.json()
    echo("JSON data: ", json_data)
    echo("stringified: ", ry.stringify(json_data, fmt=True).decode())


if __name__ == "__main__":
    echo("_________________")
    echo("~ ~ ~ ASYNC ~ ~ ~\n")
    asyncio.run(main_async())
    echo("\n_________________")
    echo("~ ~ ~ SYNC ~ ~ ~\n")
    main_sync()
</code></pre>
<h1 id="http_fetch"><a class="header" href="#http_fetch">http_fetch</a></h1>
<pre><code class="language-python">"""Example of using the `ry.fetch` function to make http requests

The stuff at the top of this file is a simple http server for example purposes
"""

from __future__ import annotations

import asyncio
import json
from http.server import BaseHTTPRequestHandler, HTTPServer
from threading import Thread

# =============================================================================
import ry


def _print_break() -&gt; None:
    print("\n" + "=" * 79 + "\n")


async def main(server_url: str = "http://127.0.0.1:8000") -&gt; None:
    # -------------------------------------------------------------------------
    # GET
    # -------------------------------------------------------------------------
    _print_break()
    response = await ry.fetch(server_url)
    print("Raw response:", response)
    json_data = await response.json()
    print("JSON data:\n", json.dumps(json_data, indent=2))

    # **THE RESPONSE HAS BEEN CONSUMED**
    # No you cannot get the json again.... You are responsible for storing
    # The response has been consumed. This is how http requests really work.
    # Libraries like requests, httpx, aiohttp, etc. store the response data
    # in memory so you can access it multiple times, ry mirrors how fetch
    # works in reqwest which is also kinda how fetch works in
    # jawascript/interface-script.
    try:
        _json_data = await response.json()
    except ValueError as e:
        print("Error:", e)

    # -------------------------------------------------------------------------
    # POST
    # -------------------------------------------------------------------------
    _print_break()
    post_response = await ry.fetch(
        server_url, method="POST", body=b"post post post... dumb as a post"
    )
    print("Raw post response:", post_response)
    post_response_data = await post_response.json()
    print("JSON post response:\n", json.dumps(post_response_data, indent=2))

    # -------------------------------------------------------------------------
    # STREAMING
    # -------------------------------------------------------------------------
    _print_break()
    long_body = "\n".join([f"dingo{i}" for i in range(1000)]).encode()
    response = await ry.fetch(server_url, method="POST", body=long_body)

    async for chunk in response.bytes_stream():
        assert isinstance(chunk, ry.Bytes)  # tis a bytes
        py_bytes = bytes(chunk)
        assert isinstance(py_bytes, bytes)
        assert py_bytes == chunk
        print("chunk this! len =:", len(chunk))


# -----------------------------------------------------------------------------
# HTTP SERVER THAT DOES SUPER SIMPLE JSON RESPONSES
# -----------------------------------------------------------------------------
class HTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self) -&gt; None:
        self.send_response(200)
        self.send_header("Content-type", "application/json")
        self.end_headers()
        res_data = {
            "path": self.path,
            "method": "GET",
            "data": {
                "dog": "dingo",
                "oreo": "mcflurry",
            },
        }
        res_bytes = json.dumps(res_data).encode()
        self.wfile.write(res_bytes)

    def do_POST(self) -&gt; None:
        self.send_response(200)
        self.send_header("Content-type", "application/json")
        self.end_headers()
        body = self.rfile.read(int(self.headers["Content-Length"]))

        res_data = {
            "path": self.path,
            "method": "POST",
            "body": body.decode(),
            "data": {
                "dog": "dingo",
                "oreo": "mcflurry",
            },
        }
        res_bytes = json.dumps(res_data).encode()
        self.wfile.write(res_bytes)


def start_server(
    host: str = "127.0.0.1", port: int = 8888, logging: bool = False
) -&gt; HTTPServer:
    class HttpRequestHandlerNoLog(HTTPRequestHandler):
        def log_message(self, format, *args):  # type: ignore[no-untyped-def]
            ...

    server_address = (host, port)
    handler = HttpRequestHandlerNoLog if not logging else HTTPRequestHandler
    httpd = HTTPServer(server_address, handler)
    Thread(target=httpd.serve_forever, daemon=True).start()
    return httpd


if __name__ == "__main__":
    server = start_server(logging=True)
    try:
        asyncio.run(
            main(server_url=f"http://{server.server_name}:{server.server_port}")
        )
    except KeyboardInterrupt:
        print("KeyboardInterrupt")
    finally:
        server.shutdown()
</code></pre>
<h1 id="jiff_examples"><a class="header" href="#jiff_examples">jiff_examples</a></h1>
<pre><code class="language-python">"""Jiff examples (v2)

Translated jiff-examples from jiff-v2's docs

REF: https://docs.rs/jiff/latest/jiff/#examples
DATE: 2025-05-23
"""

from __future__ import annotations

import json
from dataclasses import dataclass

import ry


def test_get_current_time_in_system_tz() -&gt; None:
    now = ry.ZonedDateTime.now()
    assert isinstance(now, ry.ZonedDateTime)
    assert now.tz.name


def test_print_current_time_rounded_to_second() -&gt; None:
    rounded = ry.ZonedDateTime.now().round("second")
    # nanoseconds should be zero after rounding to second
    assert rounded.nanosecond == 0


def test_print_todays_date_at_specific_time() -&gt; None:
    zdt = ry.ZonedDateTime.now().replace(
        hour=14, minute=0, second=0, nanosecond=0
    )
    assert zdt.hour == 14 and zdt.minute == 0 and zdt.second == 0
    assert zdt.nanosecond == 0


def test_print_current_unix_timestamp() -&gt; None:
    ts = ry.Timestamp.now()
    sec = ts.as_second()
    ns = ts.as_nanosecond()
    assert isinstance(sec, int) and sec &gt; 1_600_000_000
    # nanosecond count divided by 1e9 should equal seconds
    assert ns // 1_000_000_000 == sec


def test_print_datetime_for_a_timestamp() -&gt; None:
    ts = ry.Timestamp.from_millisecond(1_720_646_365_567)
    zdt = ts.to_zoned(ry.TimeZone("America/New_York"))
    assert str(zdt) == "2024-07-10T17:19:25.567-04:00[America/New_York]"
    assert str(ts) == "2024-07-10T21:19:25.567Z"


def test_create_zoned_datetime_from_civil_time() -&gt; None:
    zdt = ry.date(2023, 12, 31).at(18, 30, 0, 0).in_tz("America/New_York")
    assert str(zdt) == "2023-12-31T18:30:00-05:00[America/New_York]"


def test_change_an_instant_from_one_timezone_to_another() -&gt; None:
    paris = ry.date(1918, 11, 11).at(11, 0, 0, 0).in_tz("Europe/Paris")
    nyc = paris.in_tz("America/New_York")
    assert str(nyc) == "1918-11-11T06:00:00-05:00[America/New_York]"


def test_find_duration_between_two_zoned_datetimes() -&gt; None:
    a = ry.date(2020, 8, 26).at(6, 27, 0, 0).in_tz("America/New_York")
    b = ry.date(2023, 12, 31).at(18, 30, 0, 0).in_tz("America/New_York")
    span = b - a
    assert str(span) == "PT29341H3M"
    # until: specify largest unit via helper
    span2 = a.until(b, largest="year")
    assert str(span2) == "P3Y4M5DT12H3M"


def test_add_duration_to_a_zoned_datetime() -&gt; None:
    start = ry.date(2020, 8, 26).at(6, 27, 0, 0).in_tz("America/New_York")
    span = ry.TimeSpan()._years(3)._months(4)._days(5)._hours(12)._minutes(3)
    finish = start.add(span)  # previously `checked_add`
    assert str(finish) == "2023-12-31T18:30:00-05:00[America/New_York]"


def test_dealing_with_ambiguity() -&gt; None:
    gap = ry.date(2024, 3, 10).at(2, 30, 0, 0).in_tz("America/New_York")
    assert str(gap) == "2024-03-10T03:30:00-04:00[America/New_York]"

    fold = ry.date(2024, 11, 3).at(1, 30, 0, 0).in_tz("America/New_York")
    assert str(fold) == "2024-11-03T01:30:00-04:00[America/New_York]"


def test_parsing_a_span() -&gt; None:
    iso = ry.TimeSpan.parse("P5y1w10dT5h59m")
    expected = (
        ry.TimeSpan()._years(5)._weeks(1)._days(10)._hours(5)._minutes(59)
    )
    assert iso == expected
    assert str(iso) == "P5Y1W10DT5H59M"

    from_friendly = ry.TimeSpan.parse(
        "5 years, 1 week, 10 days, 5 hours, 59 minutes"
    )
    assert iso == from_friendly
    assert from_friendly.to_string(friendly=True) == "5y 1w 10d 5h 59m"
    assert from_friendly.friendly() == "5y 1w 10d 5h 59m"
    assert str(from_friendly) == "P5Y1W10DT5H59M"


def test_parsing_an_rfc2822_datetime_string() -&gt; None:
    base = ry.ZonedDateTime.parse_rfc2822("Thu, 29 Feb 2024 05:34 -0500")
    tas = base.in_tz("Australia/Tasmania")
    kol = base.in_tz("Asia/Kolkata")
    assert tas.format_rfc2822() == "Thu, 29 Feb 2024 21:34:00 +1100"
    assert kol.format_rfc2822() == "Thu, 29 Feb 2024 16:04:00 +0530"


def test_using_strftime_and_strptime() -&gt; None:
    zdt = ry.ZonedDateTime.strptime(
        "Monday, July 15, 2024 at 5:30pm US/Eastern",
        "%A, %B %d, %Y at %I:%M%p %Q",
    )
    assert str(zdt) == "2024-07-15T17:30:00-04:00[US/Eastern]"

    tas = ry.date(2024, 7, 15).at(17, 30, 59, 0).in_tz("Australia/Tasmania")
    formatted = tas.strftime("%A, %B %d, %Y at %-I:%M%P %Q")
    assert formatted == "Monday, July 15, 2024 at 5:30pm Australia/Tasmania"


@dataclass
class Record:
    timestamp: ry.Timestamp

    def to_json(self) -&gt; str:
        return json.dumps({"timestamp": self.timestamp.as_second()})

    @classmethod
    def from_json(cls, raw: str) -&gt; Record:
        data = json.loads(raw)
        return cls(timestamp=ry.Timestamp.from_second(data["timestamp"]))


def test_serializing_and_deserializing_integer_timestamps() -&gt; None:
    src = Record(timestamp=ry.Timestamp.from_second(1_517_644_800))
    wire = src.to_json()
    got = Record.from_json(wire)
    assert got.timestamp == src.timestamp
    assert wire == '{"timestamp": 1517644800}'


def main() -&gt; None:
    test_get_current_time_in_system_tz()
    test_print_current_time_rounded_to_second()
    test_print_todays_date_at_specific_time()
    test_print_current_unix_timestamp()
    test_print_datetime_for_a_timestamp()
    test_create_zoned_datetime_from_civil_time()
    test_change_an_instant_from_one_timezone_to_another()
    test_find_duration_between_two_zoned_datetimes()
    test_add_duration_to_a_zoned_datetime()
    test_dealing_with_ambiguity()
    test_parsing_a_span()
    test_parsing_an_rfc2822_datetime_string()
    test_using_strftime_and_strptime()
    test_serializing_and_deserializing_integer_timestamps()


if __name__ == "__main__":
    main()
</code></pre>
<h1 id="sqlformat"><a class="header" href="#sqlformat">sqlformat</a></h1>
<pre><code class="language-python">import ry

QUERY_MBTILES_DUPLICATE_METADATA_ROWS = """
-- returns the rows that are duplicate (name, value) pairs
select name, value, count(*) as count from metadata group by name having count (*) &gt; 1 and count (distinct value) = 1;
"""

assert (
    ry.sqlfmt(QUERY_MBTILES_DUPLICATE_METADATA_ROWS)
    == """
-- returns the rows that are duplicate (name, value) pairs
select
  name,
  value,
  count(*) as count
from
  metadata
group by
  name
having
  count (*) &gt; 1
  and count (distinct value) = 1;
""".strip()
)


assert (
    ry.sqlfmt(QUERY_MBTILES_DUPLICATE_METADATA_ROWS, uppercase=True)
    == """
-- returns the rows that are duplicate (name, value) pairs
SELECT
  name,
  value,
  count(*) AS count
FROM
  metadata
GROUP BY
  name
HAVING
  count (*) &gt; 1
  AND count (DISTINCT value) = 1;
""".strip()
)
</code></pre>
<h1 id="walking"><a class="header" href="#walking">walking</a></h1>
<pre><code class="language-python">"""
ry.walkdir example
"""

from __future__ import annotations

import os

import ry

PWD = os.path.dirname(os.path.abspath(__file__))


def _print_br(s: str | None = None) -&gt; None:
    print("_" * 79)
    if s:
        print(s)


def main() -&gt; None:
    dir2walk = PWD

    _print_br("Walking the directory tree")
    # Walking the directory tree
    for filepath in ry.walkdir(dir2walk):
        print(filepath)

    _print_br("Walking the directory tree with entries")
    # Walking the directory tree
    for direntry in ry.walkdir(dir2walk, objects=True):
        print(direntry, type(direntry))

    _print_br("Walking the directory tree with depth 1")
    # walking only files
    for filepath in ry.walkdir(dir2walk, dirs=False):
        print(filepath)
        assert ry.FsPath(filepath).is_file()

    # walking only directories
    for filepath in ry.walkdir(dir2walk, files=False):
        print(filepath)
        assert ry.FsPath(filepath).is_dir()

    # globset/globster
    for filepath in ry.walkdir(
        dir2walk,
        glob=ry.globster([
            "*.py",
        ]),
    ):
        assert filepath.endswith(".py")


if __name__ == "__main__":
    main()
</code></pre>
<h1 id="xxhashing"><a class="header" href="#xxhashing">xxhashing</a></h1>
<pre><code class="language-python">"""Example o' xxhash-ing files in this directory both async/sync

Demonstrates:
  - files are read via `ry.read_stream`/`ry.read_stream_async` in chunks
  - xxhashing is done via `ry.xxhash.xxh64` hasher
  - files are found via `ry.glob`
  - timing is done via `ry.instant()` to compute `ry.Duration`
  - timing is friendly printed w/ `{duration:#}` (see `ry.Duration.__format__`)

"""

import asyncio

import ry
from ry.xxhash import xxh64

_PWD = ry.FsPath(__file__).resolve().parent


def hash_file_sync(path: ry.FsPath) -&gt; tuple[str, str]:
    hasher = xxh64()

    for chunk in ry.read_stream(path):
        hasher.update(chunk)
    return str(path), hasher.hexdigest()


def hash_examples_sync() -&gt; list[tuple[str, str]]:
    files = ry.glob(str(_PWD / "**" / "*.py"), dtype=ry.FsPath).collect()

    return [hash_file_sync(f) for f in files]


async def hash_file_async(path: ry.FsPath) -&gt; tuple[str, str]:
    hasher = xxh64()

    async for chunk in ry.read_stream_async(path):
        hasher.update(chunk)
    return str(path), hasher.hexdigest()


async def hash_examples_async() -&gt; list[tuple[str, str]]:
    files = ry.glob(str(_PWD / "**" / "*.py"), dtype=ry.FsPath).collect()

    return await asyncio.gather(*(hash_file_async(f) for f in files))


def main_sync() -&gt; tuple[list[tuple[str, str]], ry.Duration]:
    start = ry.instant()
    hahses_sync = hash_examples_sync()
    dt = start.elapsed()
    return hahses_sync, dt


async def main_async() -&gt; tuple[list[tuple[str, str]], ry.Duration]:
    start = ry.instant()
    hahses_async = await hash_examples_async()
    dt = start.elapsed()
    return hahses_async, dt


def main() -&gt; None:
    res_sync, dt_sync = main_sync()
    res_async, dt_async = asyncio.run(main_async())
    print(f"HASHING  (SYNC) TOOK: {dt_sync:#}")
    print(f"HASHING (ASYNC) TOOK: {dt_async:#}")
    assert sorted(res_sync) == sorted(res_async)
    print("SYNC/ASYNC RESULTS MATCH!")


if __name__ == "__main__":
    main_sync()

    asyncio.run(main_async())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#ry.ryo3.__init__"><code>ry.ryo3.__init__</code></a></li>
<li><a href="#ry.ryo3.__about__"><code>ry.ryo3.__about__</code></a></li>
<li><a href="#ry.ryo3._aws_lc"><code>ry.ryo3._aws_lc</code></a></li>
<li><a href="#ry.ryo3._brotli"><code>ry.ryo3._brotli</code></a></li>
<li><a href="#ry.ryo3._bytes"><code>ry.ryo3._bytes</code></a></li>
<li><a href="#ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></a></li>
<li><a href="#ry.ryo3._dev"><code>ry.ryo3._dev</code></a></li>
<li><a href="#ry.ryo3._encoding_rs"><code>ry.ryo3._encoding_rs</code></a></li>
<li><a href="#ry.ryo3._flate2"><code>ry.ryo3._flate2</code></a></li>
<li><a href="#ry.ryo3._fnv"><code>ry.ryo3._fnv</code></a></li>
<li><a href="#ry.ryo3._fspath"><code>ry.ryo3._fspath</code></a></li>
<li><a href="#ry.ryo3._glob"><code>ry.ryo3._glob</code></a></li>
<li><a href="#ry.ryo3._globset"><code>ry.ryo3._globset</code></a></li>
<li><a href="#ry.ryo3._heck"><code>ry.ryo3._heck</code></a></li>
<li><a href="#ry.ryo3._http"><code>ry.ryo3._http</code></a></li>
<li><a href="#ry.ryo3._jiff"><code>ry.ryo3._jiff</code></a></li>
<li><a href="#ry.ryo3._jiff_tz"><code>ry.ryo3._jiff_tz</code></a></li>
<li><a href="#ry.ryo3._jiter"><code>ry.ryo3._jiter</code></a></li>
<li><a href="#ry.ryo3._memchr"><code>ry.ryo3._memchr</code></a></li>
<li><a href="#ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></a></li>
<li><a href="#ry.ryo3._regex"><code>ry.ryo3._regex</code></a></li>
<li><a href="#ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></a></li>
<li><a href="#ry.ryo3._same_file"><code>ry.ryo3._same_file</code></a></li>
<li><a href="#ry.ryo3._shlex"><code>ry.ryo3._shlex</code></a></li>
<li><a href="#ry.ryo3._size"><code>ry.ryo3._size</code></a></li>
<li><a href="#ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></a></li>
<li><a href="#ry.ryo3._std"><code>ry.ryo3._std</code></a></li>
<li><a href="#ry.ryo3._std_constants"><code>ry.ryo3._std_constants</code></a></li>
<li><a href="#ry.ryo3._tokio"><code>ry.ryo3._tokio</code></a></li>
<li><a href="#ry.ryo3._unindent"><code>ry.ryo3._unindent</code></a></li>
<li><a href="#ry.ryo3._url"><code>ry.ryo3._url</code></a></li>
<li><a href="#ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></a></li>
<li><a href="#ry.ryo3._which"><code>ry.ryo3._which</code></a></li>
<li><a href="#ry.ryo3._zstd"><code>ry.ryo3._zstd</code></a></li>
<li><a href="#ry.ryo3.dirs"><code>ry.ryo3.dirs</code></a></li>
<li><a href="#ry.ryo3.errors"><code>ry.ryo3.errors</code></a></li>
<li><a href="#ry.ryo3.JSON"><code>ry.ryo3.JSON</code></a></li>
<li><a href="#ry.ryo3.orjson"><code>ry.ryo3.orjson</code></a></li>
<li><a href="#ry.ryo3.sh"><code>ry.ryo3.sh</code></a></li>
<li><a href="#ry.ryo3.ulid"><code>ry.ryo3.ulid</code></a></li>
<li><a href="#ry.ryo3.uuid"><code>ry.ryo3.uuid</code></a></li>
<li><a href="#ry.ryo3.xxhash"><code>ry.ryo3.xxhash</code></a></li>
<li><a href="#ry.ryo3.zstd"><code>ry.ryo3.zstd</code></a></li>
<li><a href="#ry._types"><code>ry._types</code></a></li>
<li><a href="#ry.dirs"><code>ry.dirs</code></a></li>
<li><a href="#ry.JSON"><code>ry.JSON</code></a></li>
<li><a href="#ry.protocols"><code>ry.protocols</code></a></li>
<li><a href="#ry.ulid"><code>ry.ulid</code></a></li>
<li><a href="#ry.uuid"><code>ry.uuid</code></a></li>
<li><a href="#ry.xxhash"><code>ry.xxhash</code></a></li>
<li><a href="#ry.zstd"><code>ry.zstd</code></a></li>
</ul>
<h2 id="ry.ryo3.__init__"><code>ry.ryo3.__init__</code></h2>

<pre><code class="language-python">"""ry api ~ type annotations"""

from ry.ryo3 import JSON as JSON
from ry.ryo3 import ulid as ulid
from ry.ryo3 import uuid as uuid
from ry.ryo3 import xxhash as xxhash
from ry.ryo3 import zstd as zstd
from ry.ryo3.__about__ import __allocator__ as __allocator__
from ry.ryo3.__about__ import __authors__ as __authors__
from ry.ryo3.__about__ import __build_profile__ as __build_profile__
from ry.ryo3.__about__ import __build_timestamp__ as __build_timestamp__
from ry.ryo3.__about__ import __crypto_provider__ as __crypto_provider__
from ry.ryo3.__about__ import __description__ as __description__
from ry.ryo3.__about__ import __opt_level__ as __opt_level__
from ry.ryo3.__about__ import __pkg_name__ as __pkg_name__
from ry.ryo3.__about__ import __target__ as __target__
from ry.ryo3.__about__ import __version__ as __version__
from ry.ryo3._aws_lc import sha1 as sha1
from ry.ryo3._aws_lc import sha3_256 as sha3_256
from ry.ryo3._aws_lc import sha3_384 as sha3_384
from ry.ryo3._aws_lc import sha3_512 as sha3_512
from ry.ryo3._aws_lc import sha224 as sha224
from ry.ryo3._aws_lc import sha256 as sha256
from ry.ryo3._aws_lc import sha384 as sha384
from ry.ryo3._aws_lc import sha512 as sha512
from ry.ryo3._aws_lc import sha512_256 as sha512_256
from ry.ryo3._brotli import brotli as brotli
from ry.ryo3._brotli import brotli_decode as brotli_decode
from ry.ryo3._brotli import brotli_encode as brotli_encode
from ry.ryo3._bytes import Bytes as Bytes
from ry.ryo3._bzip2 import bzip2 as bzip2
from ry.ryo3._bzip2 import bzip2_decode as bzip2_decode
from ry.ryo3._bzip2 import bzip2_encode as bzip2_encode
from ry.ryo3._flate2 import gunzip as gunzip
from ry.ryo3._flate2 import gzip as gzip
from ry.ryo3._flate2 import gzip_decode as gzip_decode
from ry.ryo3._flate2 import gzip_encode as gzip_encode
from ry.ryo3._flate2 import is_gzipped as is_gzipped
from ry.ryo3._fnv import fnv1a as fnv1a
from ry.ryo3._fspath import FsPath as FsPath
from ry.ryo3._glob import GlobPattern as GlobPattern
from ry.ryo3._glob import glob as glob
from ry.ryo3._globset import Glob as Glob
from ry.ryo3._globset import GlobSet as GlobSet
from ry.ryo3._globset import Globster as Globster
from ry.ryo3._globset import globster as globster
from ry.ryo3._heck import camel_case as camel_case
from ry.ryo3._heck import kebab_case as kebab_case
from ry.ryo3._heck import pascal_case as pascal_case
from ry.ryo3._heck import shouty_kebab_case as shouty_kebab_case
from ry.ryo3._heck import shouty_snake_case as shouty_snake_case
from ry.ryo3._heck import snake_case as snake_case
from ry.ryo3._heck import snek_case as snek_case
from ry.ryo3._heck import title_case as title_case
from ry.ryo3._heck import train_case as train_case
from ry.ryo3._http import Headers as Headers
from ry.ryo3._http import HttpStatus as HttpStatus
from ry.ryo3._jiff import Date as Date
from ry.ryo3._jiff import DateDifference as DateDifference
from ry.ryo3._jiff import DateTime as DateTime
from ry.ryo3._jiff import DateTimeDifference as DateTimeDifference
from ry.ryo3._jiff import DateTimeRound as DateTimeRound
from ry.ryo3._jiff import ISOWeekDate as ISOWeekDate
from ry.ryo3._jiff import JiffRoundMode as JiffRoundMode
from ry.ryo3._jiff import JiffUnit as JiffUnit
from ry.ryo3._jiff import Offset as Offset
from ry.ryo3._jiff import OffsetRound as OffsetRound
from ry.ryo3._jiff import SignedDuration as SignedDuration
from ry.ryo3._jiff import SignedDurationRound as SignedDurationRound
from ry.ryo3._jiff import Time as Time
from ry.ryo3._jiff import TimeDifference as TimeDifference
from ry.ryo3._jiff import TimeRound as TimeRound
from ry.ryo3._jiff import TimeSpan as TimeSpan
from ry.ryo3._jiff import Timestamp as Timestamp
from ry.ryo3._jiff import TimestampDifference as TimestampDifference
from ry.ryo3._jiff import TimestampRound as TimestampRound
from ry.ryo3._jiff import TimeZone as TimeZone
from ry.ryo3._jiff import TimeZoneDatabase as TimeZoneDatabase
from ry.ryo3._jiff import Weekday as Weekday
from ry.ryo3._jiff import WeekdayInt as WeekdayInt
from ry.ryo3._jiff import WeekdayStr as WeekdayStr
from ry.ryo3._jiff import ZonedDateTime as ZonedDateTime
from ry.ryo3._jiff import ZonedDateTimeDifference as ZonedDateTimeDifference
from ry.ryo3._jiff import ZonedDateTimeRound as ZonedDateTimeRound
from ry.ryo3._jiff import date as date
from ry.ryo3._jiff import datetime as datetime
from ry.ryo3._jiff import now as now
from ry.ryo3._jiff import offset as offset
from ry.ryo3._jiff import time as time
from ry.ryo3._jiff import timespan as timespan
from ry.ryo3._jiff import utcnow as utcnow
from ry.ryo3._jiff import zoned as zoned
from ry.ryo3._jiter import JsonParseKwargs as JsonParseKwargs
from ry.ryo3._jiter import JsonPrimitive as JsonPrimitive
from ry.ryo3._jiter import JsonValue as JsonValue
from ry.ryo3._jiter import json_cache_clear as json_cache_clear
from ry.ryo3._jiter import json_cache_usage as json_cache_usage
from ry.ryo3._jiter import parse_json as parse_json
from ry.ryo3._jiter import parse_jsonl as parse_jsonl
from ry.ryo3._jiter import read_json as read_json
from ry.ryo3._memchr import memchr as memchr
from ry.ryo3._memchr import memchr2 as memchr2
from ry.ryo3._memchr import memchr3 as memchr3
from ry.ryo3._memchr import memrchr as memrchr
from ry.ryo3._memchr import memrchr2 as memrchr2
from ry.ryo3._memchr import memrchr3 as memrchr3
from ry.ryo3._quick_maths import quick_maths as quick_maths
from ry.ryo3._regex import Regex as Regex
from ry.ryo3._reqwest import BlockingClient as BlockingClient
from ry.ryo3._reqwest import BlockingResponse as BlockingResponse
from ry.ryo3._reqwest import BlockingResponseStream as BlockingResponseStream
from ry.ryo3._reqwest import Certificate as Certificate
from ry.ryo3._reqwest import (
    CertificateRevocationList as CertificateRevocationList,
)
from ry.ryo3._reqwest import Client as Client
from ry.ryo3._reqwest import ClientConfig as ClientConfig
from ry.ryo3._reqwest import Cookie as Cookie
from ry.ryo3._reqwest import HttpClient as HttpClient
from ry.ryo3._reqwest import Identity as Identity
from ry.ryo3._reqwest import Proxy as Proxy
from ry.ryo3._reqwest import RequestKwargs as RequestKwargs
from ry.ryo3._reqwest import ReqwestError as ReqwestError
from ry.ryo3._reqwest import Response as Response
from ry.ryo3._reqwest import ResponseStream as ResponseStream
from ry.ryo3._reqwest import fetch as fetch
from ry.ryo3._reqwest import fetch_sync as fetch_sync
from ry.ryo3._same_file import is_same_file as is_same_file
from ry.ryo3._shlex import shplit as shplit
from ry.ryo3._size import Size as Size
from ry.ryo3._size import SizeFormatter as SizeFormatter
from ry.ryo3._size import fmt_size as fmt_size
from ry.ryo3._size import parse_size as parse_size
from ry.ryo3._sqlformat import SqlfmtQueryParams as SqlfmtQueryParams
from ry.ryo3._sqlformat import SqlFormatter as SqlFormatter
from ry.ryo3._sqlformat import sqlfmt as sqlfmt
from ry.ryo3._sqlformat import sqlfmt_params as sqlfmt_params
from ry.ryo3._std import DirEntry as DirEntry
from ry.ryo3._std import Duration as Duration
from ry.ryo3._std import FileReadStream as FileReadStream
from ry.ryo3._std import FileType as FileType
from ry.ryo3._std import Instant as Instant
from ry.ryo3._std import IpAddr as IpAddr
from ry.ryo3._std import Ipv4Addr as Ipv4Addr
from ry.ryo3._std import Ipv6Addr as Ipv6Addr
from ry.ryo3._std import Metadata as Metadata
from ry.ryo3._std import ReadDir as ReadDir
from ry.ryo3._std import SocketAddr as SocketAddr
from ry.ryo3._std import SocketAddrV4 as SocketAddrV4
from ry.ryo3._std import SocketAddrV6 as SocketAddrV6
from ry.ryo3._std import canonicalize as canonicalize
from ry.ryo3._std import copy as copy
from ry.ryo3._std import create_dir as create_dir
from ry.ryo3._std import create_dir_all as create_dir_all
from ry.ryo3._std import duration as duration
from ry.ryo3._std import exists as exists
from ry.ryo3._std import hard_link as hard_link
from ry.ryo3._std import instant as instant
from ry.ryo3._std import is_dir as is_dir
from ry.ryo3._std import is_file as is_file
from ry.ryo3._std import is_symlink as is_symlink
from ry.ryo3._std import metadata as metadata
from ry.ryo3._std import read as read
from ry.ryo3._std import read_bytes as read_bytes
from ry.ryo3._std import read_dir as read_dir
from ry.ryo3._std import read_link as read_link
from ry.ryo3._std import read_str as read_str
from ry.ryo3._std import read_stream as read_stream
from ry.ryo3._std import read_text as read_text
from ry.ryo3._std import read_to_string as read_to_string
from ry.ryo3._std import remove_dir as remove_dir
from ry.ryo3._std import remove_dir_all as remove_dir_all
from ry.ryo3._std import remove_file as remove_file
from ry.ryo3._std import rename as rename
from ry.ryo3._std import set_permissions as set_permissions
from ry.ryo3._std import sleep as sleep
from ry.ryo3._std import soft_link as soft_link
from ry.ryo3._std import symlink_metadata as symlink_metadata
from ry.ryo3._std import write as write
from ry.ryo3._std import write_bytes as write_bytes
from ry.ryo3._std import write_text as write_text
from ry.ryo3._std_constants import I8_BITS as I8_BITS
from ry.ryo3._std_constants import I8_MAX as I8_MAX
from ry.ryo3._std_constants import I8_MIN as I8_MIN
from ry.ryo3._std_constants import I16_BITS as I16_BITS
from ry.ryo3._std_constants import I16_MAX as I16_MAX
from ry.ryo3._std_constants import I16_MIN as I16_MIN
from ry.ryo3._std_constants import I32_BITS as I32_BITS
from ry.ryo3._std_constants import I32_MAX as I32_MAX
from ry.ryo3._std_constants import I32_MIN as I32_MIN
from ry.ryo3._std_constants import I64_BITS as I64_BITS
from ry.ryo3._std_constants import I64_MAX as I64_MAX
from ry.ryo3._std_constants import I64_MIN as I64_MIN
from ry.ryo3._std_constants import I128_BITS as I128_BITS
from ry.ryo3._std_constants import I128_MAX as I128_MAX
from ry.ryo3._std_constants import I128_MIN as I128_MIN
from ry.ryo3._std_constants import ISIZE_BITS as ISIZE_BITS
from ry.ryo3._std_constants import ISIZE_MAX as ISIZE_MAX
from ry.ryo3._std_constants import ISIZE_MIN as ISIZE_MIN
from ry.ryo3._std_constants import U8_BITS as U8_BITS
from ry.ryo3._std_constants import U8_MAX as U8_MAX
from ry.ryo3._std_constants import U8_MIN as U8_MIN
from ry.ryo3._std_constants import U16_BITS as U16_BITS
from ry.ryo3._std_constants import U16_MAX as U16_MAX
from ry.ryo3._std_constants import U16_MIN as U16_MIN
from ry.ryo3._std_constants import U32_BITS as U32_BITS
from ry.ryo3._std_constants import U32_MAX as U32_MAX
from ry.ryo3._std_constants import U32_MIN as U32_MIN
from ry.ryo3._std_constants import U64_BITS as U64_BITS
from ry.ryo3._std_constants import U64_MAX as U64_MAX
from ry.ryo3._std_constants import U64_MIN as U64_MIN
from ry.ryo3._std_constants import U128_BITS as U128_BITS
from ry.ryo3._std_constants import U128_MAX as U128_MAX
from ry.ryo3._std_constants import U128_MIN as U128_MIN
from ry.ryo3._std_constants import USIZE_BITS as USIZE_BITS
from ry.ryo3._std_constants import USIZE_MAX as USIZE_MAX
from ry.ryo3._std_constants import USIZE_MIN as USIZE_MIN
from ry.ryo3._tokio import AsyncDirEntry as AsyncDirEntry
from ry.ryo3._tokio import AsyncFile as AsyncFile
from ry.ryo3._tokio import AsyncFileReadStream as AsyncFileReadStream
from ry.ryo3._tokio import AsyncReadDir as AsyncReadDir
from ry.ryo3._tokio import aiopen as aiopen  # type: ignore[deprecated]
from ry.ryo3._tokio import aopen as aopen
from ry.ryo3._tokio import asleep as asleep
from ry.ryo3._tokio import canonicalize_async as canonicalize_async
from ry.ryo3._tokio import copy_async as copy_async
from ry.ryo3._tokio import create_dir_all_async as create_dir_all_async
from ry.ryo3._tokio import create_dir_async as create_dir_async
from ry.ryo3._tokio import exists_async as exists_async
from ry.ryo3._tokio import hard_link_async as hard_link_async
from ry.ryo3._tokio import metadata_async as metadata_async
from ry.ryo3._tokio import read_async as read_async
from ry.ryo3._tokio import read_dir_async as read_dir_async
from ry.ryo3._tokio import read_link_async as read_link_async
from ry.ryo3._tokio import read_stream_async as read_stream_async
from ry.ryo3._tokio import read_to_string_async as read_to_string_async
from ry.ryo3._tokio import remove_dir_all_async as remove_dir_all_async
from ry.ryo3._tokio import remove_dir_async as remove_dir_async
from ry.ryo3._tokio import remove_file_async as remove_file_async
from ry.ryo3._tokio import rename_async as rename_async
from ry.ryo3._tokio import sleep_async as sleep_async
from ry.ryo3._tokio import try_exists_async as try_exists_async
from ry.ryo3._tokio import write_async as write_async
from ry.ryo3._unindent import unindent as unindent
from ry.ryo3._unindent import unindent_bytes as unindent_bytes
from ry.ryo3._url import URL as URL
from ry.ryo3._walkdir import WalkDirEntry as WalkDirEntry
from ry.ryo3._walkdir import WalkdirGen as WalkdirGen
from ry.ryo3._walkdir import walkdir as walkdir
from ry.ryo3._which import which as which
from ry.ryo3._which import which_all as which_all
from ry.ryo3._which import which_re as which_re
from ry.ryo3._zstd import is_zstd as is_zstd
from ry.ryo3._zstd import zstd_compress as zstd_compress
from ry.ryo3._zstd import zstd_decode as zstd_decode
from ry.ryo3._zstd import zstd_decompress as zstd_decompress
from ry.ryo3._zstd import zstd_encode as zstd_encode
from ry.ryo3.errors import FeatureNotEnabledError as FeatureNotEnabledError
from ry.ryo3.JSON import stringify as stringify
from ry.ryo3.JSON import stringify_unsafe as stringify_unsafe
from ry.ryo3.orjson import orjson_default as orjson_default
from ry.ryo3.sh import cd as cd
from ry.ryo3.sh import home as home
from ry.ryo3.sh import ls as ls
from ry.ryo3.sh import mkdir as mkdir
from ry.ryo3.sh import mkdirp as mkdirp
from ry.ryo3.sh import pwd as pwd
</code></pre>
<h2 id="ry.ryo3.__about__"><code>ry.ryo3.__about__</code></h2>

<pre><code class="language-python">import typing as t

__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str
__target__: str
__opt_level__: t.Literal["0", "1", "2", "3", "s", "z"]
__allocator__: t.Literal["mimalloc", "system"]
__crypto_provider__: t.Literal["ring", "aws-lc-rs"]
</code></pre>
<h2 id="ry.ryo3._aws_lc"><code>ry.ryo3._aws_lc</code></h2>

<pre><code class="language-python">import typing as t

from ry._types import Buffer

SHA1_BLOCK_SIZE: t.TypeAlias = t.Literal[64]
SHA1_DIGEST_SIZE: t.TypeAlias = t.Literal[20]

SHA224_BLOCK_SIZE: t.TypeAlias = t.Literal[64]
SHA224_DIGEST_SIZE: t.TypeAlias = t.Literal[28]

SHA256_BLOCK_SIZE: t.TypeAlias = t.Literal[64]
SHA256_DIGEST_SIZE: t.TypeAlias = t.Literal[32]

SHA384_BLOCK_SIZE: t.TypeAlias = t.Literal[128]
SHA384_DIGEST_SIZE: t.TypeAlias = t.Literal[48]

SHA3_256_BLOCK_SIZE: t.TypeAlias = t.Literal[136]
SHA3_256_DIGEST_SIZE: t.TypeAlias = t.Literal[32]

SHA3_384_BLOCK_SIZE: t.TypeAlias = t.Literal[104]
SHA3_384_DIGEST_SIZE: t.TypeAlias = t.Literal[48]

SHA3_512_BLOCK_SIZE: t.TypeAlias = t.Literal[72]
SHA3_512_DIGEST_SIZE: t.TypeAlias = t.Literal[64]

SHA512_BLOCK_SIZE: t.TypeAlias = t.Literal[128]
SHA512_DIGEST_SIZE: t.TypeAlias = t.Literal[64]

SHA512_256_BLOCK_SIZE: t.TypeAlias = t.Literal[128]
SHA512_256_DIGEST_SIZE: t.TypeAlias = t.Literal[32]

_TName = t.TypeVar("_TName", bound=str)
_TBlockSize = t.TypeVar("_TBlockSize", bound=int)
_TDigestSize = t.TypeVar("_TDigestSize", bound=int)


@t.type_check_only
class _Sha(t.Generic[_TName, _TBlockSize, _TDigestSize]):
    name: _TName
    digest_size: _TDigestSize
    block_size: _TBlockSize

    def copy(self) -&gt; t.Self: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def update(self, obj: Buffer, /) -&gt; None: ...
    @staticmethod
    def oneshot(data: Buffer) -&gt; bytes: ...


# fmt: off
sha1: type[_Sha[t.Literal["sha1"], SHA1_BLOCK_SIZE, SHA1_DIGEST_SIZE]]
sha224: type[_Sha[t.Literal["sha224"], SHA224_BLOCK_SIZE, SHA224_DIGEST_SIZE]]
sha256: type[_Sha[t.Literal["sha256"], SHA256_BLOCK_SIZE, SHA256_DIGEST_SIZE]]
sha384: type[_Sha[t.Literal["sha384"], SHA384_BLOCK_SIZE, SHA384_DIGEST_SIZE]]
sha3_256: type[_Sha[t.Literal["sha3_256"], SHA3_256_BLOCK_SIZE, SHA3_256_DIGEST_SIZE]]
sha3_384: type[_Sha[t.Literal["sha3_384"], SHA3_384_BLOCK_SIZE, SHA3_384_DIGEST_SIZE]]
sha3_512: type[_Sha[t.Literal["sha3_512"], SHA3_512_BLOCK_SIZE, SHA3_512_DIGEST_SIZE]]
sha512: type[_Sha[t.Literal["sha512"], SHA512_BLOCK_SIZE, SHA512_DIGEST_SIZE]]
sha512_256: type[_Sha[t.Literal["sha512_256"], SHA512_256_BLOCK_SIZE, SHA512_256_DIGEST_SIZE]]
# fmt: on
</code></pre>
<h2 id="ry.ryo3._brotli"><code>ry.ryo3._brotli</code></h2>

<pre><code class="language-python">"""ryo3-brotli types"""

from typing import Literal, TypeAlias

from ry._types import Buffer

_Quality: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]


def brotli_encode(
    data: Buffer, quality: _Quality = 11, *, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(data: Buffer) -&gt; bytes: ...
def brotli(
    data: Buffer, quality: _Quality = 11, *, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""
</code></pre>
<h2 id="ry.ryo3._bytes"><code>ry.ryo3._bytes</code></h2>

<pre><code class="language-python">import sys
from typing import overload

import typing_extensions

if sys.version_info &gt;= (3, 12):
    from collections.abc import Buffer as Buffer
else:
    from typing_extensions import Buffer as Buffer


class Bytes(Buffer):
    """
    A buffer implementing the Python buffer protocol, allowing zero-copy access
    to underlying Rust memory.

    You can pass this to `memoryview` for a zero-copy view into the underlying
    data or to `bytes` to copy the underlying data into a Python `bytes`.

    Many methods from the Python `bytes` class are implemented on this,
    """

    def __init__(self, buf: Buffer = b"") -&gt; None:
        """Construct a new Bytes object.

        This will be a zero-copy view on the Python byte slice.
        """

    def __add__(self, other: Buffer) -&gt; Bytes: ...
    def __buffer__(self, flags: int) -&gt; memoryview: ...
    def __contains__(self, other: Buffer) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @overload
    def __getitem__(self, other: int) -&gt; int: ...
    @overload
    def __getitem__(self, other: slice) -&gt; Bytes: ...
    def __mul__(self, other: int) -&gt; Bytes: ...
    def __rmul__(self, other: int) -&gt; Bytes: ...
    def __len__(self) -&gt; int: ...
    def __bytes__(self) -&gt; bytes:
        """Return the underlying data as a Python `bytes` object."""

    def removeprefix(self, prefix: Buffer, /) -&gt; Bytes:
        """
        If the binary data starts with the prefix string, return `bytes[len(prefix):]`.
        Otherwise, return the original binary data.
        """

    def removesuffix(self, suffix: Buffer, /) -&gt; Bytes:
        """
        If the binary data ends with the suffix string and that suffix is not empty,
        return `bytes[:-len(suffix)]`. Otherwise, return the original binary data.
        """

    def isalnum(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetical ASCII characters or
        ASCII decimal digits and the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal digits
        are those byte values in the sequence `b'0123456789'`.
        """

    def isalpha(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetic ASCII characters and
        the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
        """

    def isascii(self) -&gt; bool:
        """
        Return `True` if the sequence is empty or all bytes in the sequence are ASCII,
        `False` otherwise.

        ASCII bytes are in the range `0-0x7F`.
        """

    def isdigit(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII decimal digits and the
        sequence is not empty, `False` otherwise.

        ASCII decimal digits are those byte values in the sequence `b'0123456789'`.
        """

    def islower(self) -&gt; bool:
        """
        Return `True` if there is at least one lowercase ASCII character in the sequence
        and no uppercase ASCII characters, `False` otherwise.
        """

    def isspace(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII whitespace and the sequence
        is not empty, `False` otherwise.

        ASCII whitespace characters are those byte values
        in the sequence `b' \t\n\r\x0b\f'` (space, tab, newline, carriage return,
        vertical tab, form feed).
        """

    def isupper(self) -&gt; bool:
        """
        Return `True` if there is at least one uppercase alphabetic ASCII character in
        the sequence and no lowercase ASCII characters, `False` otherwise.
        """

    def lower(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the uppercase ASCII characters converted
        to their corresponding lowercase counterpart.
        """

    def upper(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the lowercase ASCII characters converted
        to their corresponding uppercase counterpart.
        """

    def to_bytes(self) -&gt; bytes:
        """Copy this buffer's contents into a Python `bytes` object."""

    # =========================================================================
    # IMPL IN RY
    # =========================================================================

    def istitle(self) -&gt; bool:
        """
        Return `True` if the sequence is non-empty and contains only ASCII letters,
        digits, underscores, and hyphens, and starts with an ASCII letter or underscore.
        Otherwise, return `False`.
        """

    def decode(self, encoding: str = "utf-8", errors: str = "strict") -&gt; str:
        """Decode the binary data using the given encoding."""

    def hex(
        self, sep: str | None = None, bytes_per_sep: int | None = None
    ) -&gt; str:
        """Return a hexadecimal representation of the binary data."""

    @classmethod
    def fromhex(cls, string: str) -&gt; Bytes:
        """Construct a `Bytes` object from a hexadecimal string."""

    def startswith(self, prefix: Buffer, /) -&gt; bool:
        """Return `True` if the binary data starts with the prefix string, `False` otherwise."""

    def endswith(self, suffix: Buffer, /) -&gt; bool:
        """Return `True` if the binary data ends with the suffix string, `False` otherwise."""

    def capitalize(self) -&gt; Bytes:
        """
        Return a copy of the sequence with the first byte converted to uppercase and
        all other bytes converted to lowercase.
        """

    def strip(self, chars: Buffer | None = None, /) -&gt; Bytes:
        """
        Return a copy of the sequence with leading and trailing bytes removed.
        If `chars` is provided, remove all bytes in `chars` from both ends.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def lstrip(self, chars: Buffer | None = None, /) -&gt; Bytes:
        """
        Return a copy of the sequence with leading bytes removed.
        If `chars` is provided, remove all bytes in `chars` from the left end.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def rstrip(self, chars: Buffer | None = None, /) -&gt; Bytes:
        """
        Return a copy of the sequence with trailing bytes removed.
        If `chars` is provided, remove all bytes in `chars` from the right end.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def expandtabs(self, tabsize: int = 8) -&gt; Bytes:
        """
        Return a copy of the sequence with all ASCII tab characters replaced by spaces.
        The number of spaces is determined by the `tabsize` parameter.
        """

    def title(self) -&gt; Bytes:
        """
        Return a copy of the sequence with the first byte of each word converted to
        uppercase and all other bytes converted to lowercase.
        """

    def swapcase(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all uppercase ASCII characters converted to
        their corresponding lowercase counterpart and vice versa.
        """


BytesLike: typing_extensions.TypeAlias = (
    Buffer | bytes | bytearray | memoryview | Bytes
)
</code></pre>
<h2 id="ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></h2>

<pre><code class="language-python">"""ryo3-bzip2 types"""

from typing import Literal, TypeAlias

from ry import Bytes
from ry._types import Buffer

_Quality: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, "best", "fast"]


def bzip2_decode(data: Buffer) -&gt; Bytes: ...
def bzip2_encode(data: Buffer, quality: _Quality = 6) -&gt; Bytes: ...
def bzip2(data: Buffer, quality: _Quality = 6) -&gt; Bytes:
    """Alias for bzip2_encode"""
</code></pre>
<h2 id="ry.ryo3._dev"><code>ry.ryo3._dev</code></h2>

<pre><code class="language-python">"""ry.ryo3.dev"""

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,  # noqa: A002
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...
</code></pre>
<h2 id="ry.ryo3._encoding_rs"><code>ry.ryo3._encoding_rs</code></h2>

<pre><code class="language-python">import typing as t

Encoding: t.TypeAlias = t.Literal[
    # UTF-8
    "utf8",
    "utf-8",
    "unicode20utf8",
    "unicode11utf8",
    "x-unicode20utf8",
    "unicode-1-1-utf-8",
    # UTF-16LE
    "ucs-2",
    "utf-16",
    "unicode",
    "utf-16le",
    "csunicode",
    "unicodefeff",
    "iso-10646-ucs-2",
    # UTF-16BE
    "utf-16be",
    "unicodefffe",
    # Big5
    "big5",
    "csbig5",
    "cn-big5",
    "x-x-big5",
    "big5-hkscs",
    # EUC-JP
    "euc-jp",
    "x-euc-jp",
    "cseucpkdfmtjapanese",
    # EUC-KR
    "korean",
    "euc-kr",
    "ksc5601",
    "cseuckr",
    "ksc_5601",
    "iso-ir-149",
    "windows-949",
    "csksc56011987",
    "ks_c_5601-1987",
    "ks_c_5601-1989",
    # GBK
    "gbk",
    "x-gbk",
    "gb2312",
    "gb_2312",
    "chinese",
    "csgb2312",
    "iso-ir-58",
    "gb_2312-80",
    "csiso58gb231280",
    # IBM866
    "866",
    "cp866",
    "ibm866",
    "csibm866",
    # ISO-2022-JP
    "iso-2022-jp",
    "csiso2022jp",
    # ISO-8859-10
    "l6",
    "latin6",
    "iso885910",
    "iso8859-10",
    "iso-ir-157",
    "iso-8859-10",
    "csisolatin6",
    # ISO-8859-13
    "iso885913",
    "iso8859-13",
    "iso-8859-13",
    # ISO-8859-14
    "iso885914",
    "iso8859-14",
    "iso-8859-14",
    # ISO-8859-15
    "l9",
    "iso885915",
    "iso8859-15",
    "iso-8859-15",
    "iso_8859-15",
    "csisolatin9",
    # ISO-8859-16
    "iso-8859-16",
    # ISO-8859-2
    "l2",
    "latin2",
    "iso88592",
    "iso8859-2",
    "iso-ir-101",
    "iso-8859-2",
    "iso_8859-2",
    "csisolatin2",
    "iso_8859-2:1987",
    # ISO-8859-3
    "l3",
    "latin3",
    "iso88593",
    "iso8859-3",
    "iso-8859-3",
    "iso_8859-3",
    "iso-ir-109",
    "csisolatin3",
    "iso_8859-3:1988",
    # ISO-8859-4
    "l4",
    "latin4",
    "iso88594",
    "iso8859-4",
    "iso-ir-110",
    "iso-8859-4",
    "iso_8859-4",
    "csisolatin4",
    "iso_8859-4:1988",
    # ISO-8859-5
    "iso88595",
    "cyrillic",
    "iso8859-5",
    "iso-ir-144",
    "iso-8859-5",
    "iso_8859-5",
    "iso_8859-5:1988",
    "csisolatincyrillic",
    # ISO-8859-6
    "arabic",
    "ecma-114",
    "iso88596",
    "asmo-708",
    "iso8859-6",
    "iso-8859-6",
    "iso_8859-6",
    "iso-ir-127",
    "csiso88596e",
    "csiso88596i",
    "iso-8859-6-e",
    "iso-8859-6-i",
    "iso_8859-6:1987",
    "csisolatinarabic",
    # ISO-8859-7
    "greek",
    "greek8",
    "iso88597",
    "ecma-118",
    "elot_928",
    "iso8859-7",
    "iso-ir-126",
    "iso-8859-7",
    "iso_8859-7",
    "sun_eu_greek",
    "iso_8859-7:1987",
    "csisolatingreek",
    # ISO-8859-8
    "visual",
    "hebrew",
    "iso88598",
    "iso8859-8",
    "iso-8859-8",
    "iso_8859-8",
    "iso-ir-138",
    "csiso88598e",
    "iso-8859-8-e",
    "iso_8859-8:1988",
    "csisolatinhebrew",
    # ISO-8859-8-I
    "logical",
    "csiso88598i",
    "iso-8859-8-i",
    # KOI8-R
    "koi",
    "koi8",
    "koi8-r",
    "koi8_r",
    "cskoi8r",
    # KOI8-U
    "koi8-u",
    "koi8-ru",
    # Shift_JIS
    "sjis",
    "ms932",
    "x-sjis",
    "ms_kanji",
    "shift-jis",
    "shift_jis",
    "csshiftjis",
    "windows-31j",
    # gb18030
    "gb18030",
    # macintosh
    "mac",
    "macintosh",
    "csmacintosh",
    "x-mac-roman",
    # replacement
    "hz-gb-2312",
    "iso-2022-cn",
    "iso-2022-kr",
    "csiso2022kr",
    "replacement",
    "iso-2022-cn-ext",
    # windows-1250
    "cp1250",
    "x-cp1250",
    "windows-1250",
    # windows-1251
    "cp1251",
    "x-cp1251",
    "windows-1251",
    # windows-1252
    "l1",
    "cp819",
    "ascii",
    "latin1",
    "cp1252",
    "ibm819",
    "iso88591",
    "x-cp1252",
    "us-ascii",
    "iso8859-1",
    "iso-ir-100",
    "iso-8859-1",
    "iso_8859-1",
    "csisolatin1",
    "windows-1252",
    "ansi_x3.4-1968",
    "iso_8859-1:1987",
    # windows-1253
    "cp1253",
    "x-cp1253",
    "windows-1253",
    # windows-1254
    "l5",
    "cp1254",
    "latin5",
    "x-cp1254",
    "iso88599",
    "iso8859-9",
    "iso-ir-148",
    "iso-8859-9",
    "iso_8859-9",
    "csisolatin5",
    "windows-1254",
    "iso_8859-9:1989",
    # windows-1255
    "cp1255",
    "x-cp1255",
    "windows-1255",
    # windows-1256
    "cp1256",
    "x-cp1256",
    "windows-1256",
    # windows-1257
    "cp1257",
    "x-cp1257",
    "windows-1257",
    # windows-1258
    "cp1258",
    "x-cp1258",
    "windows-1258",
    # windows-874
    "tis-620",
    "dos-874",
    "iso885911",
    "iso8859-11",
    "iso-8859-11",
    "windows-874",
    # x-mac-cyrillic
    "x-mac-cyrillic",
    "x-mac-ukrainian",
    # x-user-defined
    "x-user-defined",
]
</code></pre>
<h2 id="ry.ryo3._flate2"><code>ry.ryo3._flate2</code></h2>

<pre><code class="language-python">"""ryo3-flate2 types"""

from typing import Literal, TypeAlias

from ry import Bytes
from ry._types import Buffer

Quality: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "best", "fast"]


def gzip_encode(data: Buffer, quality: Quality = 6) -&gt; Bytes: ...
def gzip_decode(data: Buffer) -&gt; Bytes: ...
def gzip(data: Buffer, quality: Quality = 6) -&gt; Bytes:
    """Alias for gzip_encode"""


def gunzip(data: Buffer) -&gt; Bytes:
    """Alias for gzip_decode"""


def is_gzipped(data: Buffer) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._fnv"><code>ry.ryo3._fnv</code></h2>

<pre><code class="language-python">"""ryo3-fnv types"""

import typing as t

from ry._types import Buffer


@t.final
class fnv1a:  # noqa: N801
    name: t.Literal["fnv1a"]
    digest_size: t.Literal[8]
    block_size: t.Literal[1]

    def __init__(
        self,
        data: Buffer | None = None,
        *,
        key: int | bytes = 0xCBF29CE484222325,  # noqa: PYI054
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def intdigest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; t.Self: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, key: int | bytes = 0xCBF29CE484222325
    ) -&gt; int: ...  # noqa: PYI054
</code></pre>
<h2 id="ry.ryo3._fspath"><code>ry.ryo3._fspath</code></h2>

<pre><code class="language-python">"""ryo3-fspath types"""

import typing as t
from os import PathLike
from pathlib import Path

from ry._types import Buffer
from ry.protocols import RyIterator, ToPy, ToString
from ry.ryo3._bytes import Bytes
from ry.ryo3._regex import Regex
from ry.ryo3._std import Metadata


@t.final
class FsPath(ToPy[Path], ToString):
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def to_string(self) -&gt; str: ...
    def to_py(self) -&gt; Path: ...
    def to_pathlib(self) -&gt; Path: ...
    # =========================================================================
    # IO
    # =========================================================================
    def read(self) -&gt; Bytes: ...
    def read_bytes(self) -&gt; bytes: ...
    def read_text(self) -&gt; str: ...
    def write(self, data: Buffer | bytes) -&gt; None: ...
    def write_bytes(self, data: Buffer | bytes) -&gt; None: ...
    def write_text(self, data: str) -&gt; None: ...
    def touch(self, mode: int | None = None, exist_ok: bool = True) -&gt; bool:
        """Returns `True` if file was created `False` if already existed."""

    def open(
        self,
        mode: str,
        buffering: int = -1,
        encoding: str | None = None,
        errors: str | None = None,
        newline: str | None = None,
    ) -&gt; t.IO[t.Any]: ...

    # =========================================================================
    # METHODS
    # =========================================================================
    def absolute(self) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...
    def as_uri(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def exists(self) -&gt; bool: ...
    def iterdir(self) -&gt; FsPathReaddir: ...
    def join(self, p: PathLike[str] | str | FsPath) -&gt; FsPath: ...
    # TODO: support *args
    def joinpath(self, other: str) -&gt; FsPath: ...
    def metadata(self) -&gt; Metadata: ...
    def mkdir(
        self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False
    ) -&gt; None: ...
    def read_dir(self) -&gt; FsPathReaddir: ...
    def read_link(self) -&gt; FsPath: ...
    def relative_to(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def rename(self, new_path: PathLike[str] | str) -&gt; FsPath: ...
    def replace(self, new_path: PathLike[str] | str) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def rmdir(self, recursive: bool = False) -&gt; None: ...
    def unlink(
        self, missing_ok: bool = False, recursive: bool = False
    ) -&gt; None: ...
    def with_name(self, name: str) -&gt; t.Self: ...
    def with_suffix(self, suffix: str) -&gt; t.Self: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; t.Self: ...
    @classmethod
    def home(cls) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; t.Self: ...
    @property
    def parents(self) -&gt; t.Sequence[t.Self]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; t.Self | None: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; RyIterator[t.Self]: ...
    def canonicalize(self) -&gt; t.Self: ...
    def components(self) -&gt; t.Iterator[t.Self]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, child: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; t.Self: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, base: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, base: PathLike[str] | str) -&gt; t.Self: ...
    def with_extension(self, extension: str) -&gt; t.Self: ...
    def with_file_name(self, name: str) -&gt; t.Self: ...

    # =========================================================================
    # FEATURE: `same-file`
    # =========================================================================
    def samefile(self, other: PathLike[str] | str | t.Self) -&gt; bool: ...
    def symlink_metadata(self) -&gt; Metadata: ...

    # =========================================================================
    # FEATURE: `which` &amp; `which-regex`
    # =========================================================================
    @staticmethod
    def which(cmd: str, path: str | None = None) -&gt; FsPath | None: ...
    @staticmethod
    def which_all(cmd: str, path: str | None = None) -&gt; list[FsPath]: ...
    @staticmethod
    def which_re(
        regex: str | Regex, path: str | None = None
    ) -&gt; list[FsPath]: ...

    # =========================================================================
    # DUNDERS
    # =========================================================================
    def __truediv__(self, other: PathLike[str] | str) -&gt; t.Self: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; t.Self: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __bytes__(self) -&gt; bytes: ...


class FsPathReaddir(RyIterator[FsPath]):
    def __init__(self) -&gt; t.NoReturn: ...
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; FsPath: ...
    def collect(self) -&gt; list[FsPath]: ...
    def take(self, n: int = 1) -&gt; list[FsPath]: ...
</code></pre>
<h2 id="ry.ryo3._glob"><code>ry.ryo3._glob</code></h2>

<pre><code class="language-python">"""ryo3-glob types"""

import typing as t
from os import PathLike
from pathlib import Path

from ry.protocols import RyIterator
from ry.ryo3._fspath import FsPath

_T = t.TypeVar("_T", bound=str | Path | FsPath)


@t.final
class GlobPaths(RyIterator[_T]):
    """glob::Paths iterable wrapper"""

    def __next__(self) -&gt; _T: ...
    def __iter__(self) -&gt; GlobPaths[_T]: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = True,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
    strict: bool = False,
    dtype: None = None,
) -&gt; GlobPaths[Path]: ...
@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = True,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
    strict: bool = False,
    dtype: type[_T],
) -&gt; GlobPaths[_T]: ...


@t.final
class GlobPattern:
    """Glob pattern matching ~ `::glob::Pattern`

    [DOCS](https://docs.rs/glob/latest/glob/struct.Pattern.html)

    Prefer the `::globset` wrappers (`Glob` | `Globset` | `Globster`).
    """

    def __init__(
        self,
        pattern: str,
        *,
        case_sensitive: bool = True,
        require_literal_separator: bool = False,
        require_literal_leading_dot: bool = False,
    ) -&gt; None: ...
    def __call__(
        self,
        ob: str | PathLike[str],
        *,
        case_sensitive: bool | None = None,
        require_literal_separator: bool | None = None,
        require_literal_leading_dot: bool | None = None,
    ) -&gt; bool: ...
    def matches(self, s: str) -&gt; bool: ...
    def matches_path(self, path: PathLike[str]) -&gt; bool: ...
    def matches_with(
        self,
        s: str,
        *,
        case_sensitive: bool | None = None,
        require_literal_separator: bool | None = None,
        require_literal_leading_dot: bool | None = None,
    ) -&gt; bool: ...
    def matches_path_with(
        self,
        path: PathLike[str],
        *,
        case_sensitive: bool | None = None,
        require_literal_separator: bool | None = None,
        require_literal_leading_dot: bool | None = None,
    ) -&gt; bool: ...
    @staticmethod
    def escape(pattern: str) -&gt; str: ...
    @property
    def pattern(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._globset"><code>ry.ryo3._globset</code></h2>

<pre><code class="language-python">"""ryo3-globset types"""

import typing as t
from os import PathLike


@t.final
class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool = False,
        literal_separator: bool = False,
        backslash_escape: bool = ...,  # True on windows, False otherwise
    ) -&gt; None: ...
    @property
    def regex(self) -&gt; str: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


@t.final
class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool = False,
        literal_separator: bool = False,
        backslash_escape: bool = ...,  # True on windows, False otherwise
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def globster(self) -&gt; Globster: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


@t.final
class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool = False,
        literal_separator: bool = False,
        backslash_escape: bool = ...,  # True on windows, False otherwise
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


def globster(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool = False,
    literal_separator: bool = False,
    backslash_escape: bool = ...,  # True on windows, False otherwise
) -&gt; Globster: ...
</code></pre>
<h2 id="ry.ryo3._heck"><code>ry.ryo3._heck</code></h2>

<pre><code class="language-python">"""ryo3-heck types"""


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...
</code></pre>
<h2 id="ry.ryo3._http"><code>ry.ryo3._http</code></h2>

<pre><code class="language-python">import typing as t
from collections.abc import Mapping

# fmt: off
HttpVersionLike: t.TypeAlias = t.Literal[
    "HTTP/0.9", "0.9", 0,
    "HTTP/1.0", "1.0", 1, 10,
    "HTTP/1.1", "1.1", 11,
    "HTTP/2.0", "2.0", 2, 20,
    "HTTP/3.0", "3.0", 3, 30,
]
# fmt: on

_StandardHeader: t.TypeAlias = t.Literal[
    "accept",
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept-ranges",
    "access-control-allow-credentials",
    "access-control-allow-headers",
    "access-control-allow-methods",
    "access-control-allow-origin",
    "access-control-expose-headers",
    "access-control-max-age",
    "access-control-request-headers",
    "access-control-request-method",
    "age",
    "allow",
    "alt-svc",
    "authorization",
    "cache-control",
    "cache-status",
    "cdn-cache-control",
    "connection",
    "content-disposition",
    "content-encoding",
    "content-language",
    "content-length",
    "content-location",
    "content-range",
    "content-security-policy",
    "content-security-policy-report-only",
    "content-type",
    "cookie",
    "dnt",
    "date",
    "etag",
    "expect",
    "expires",
    "forwarded",
    "from",
    "host",
    "if-match",
    "if-modified-since",
    "if-none-match",
    "if-range",
    "if-unmodified-since",
    "last-modified",
    "link",
    "location",
    "max-forwards",
    "origin",
    "pragma",
    "proxy-authenticate",
    "proxy-authorization",
    "public-key-pins",
    "public-key-pins-report-only",
    "range",
    "referer",
    "referrer-policy",
    "refresh",
    "retry-after",
    "sec-websocket-accept",
    "sec-websocket-extensions",
    "sec-websocket-key",
    "sec-websocket-protocol",
    "sec-websocket-version",
    "server",
    "set-cookie",
    "strict-transport-security",
    "te",
    "trailer",
    "transfer-encoding",
    "user-agent",
    "upgrade",
    "upgrade-insecure-requests",
    "vary",
    "via",
    "warning",
    "www-authenticate",
    "x-content-type-options",
    "x-dns-prefetch-control",
    "x-frame-options",
    "x-xss-protection",
]

_HeaderName: t.TypeAlias = _StandardHeader | str
_VT = t.TypeVar("_VT", bound=str | t.Sequence[str])


@t.final
class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(
        self,
        headers: Mapping[_HeaderName, _VT] | t.Self | None = None,
        /,
        **kwargs: _VT,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: _HeaderName) -&gt; str: ...
    def __setitem__(self, key: _HeaderName, value: str) -&gt; None: ...
    def __delitem__(self, key: _HeaderName) -&gt; None: ...
    def __contains__(self, key: _HeaderName) -&gt; bool: ...
    def __or__(self, other: t.Self | dict[str, str]) -&gt; t.Self: ...
    def __ror__(self, other: t.Self | dict[str, str]) -&gt; t.Self: ...
    def __iter__(self) -&gt; t.Iterator[_HeaderName]: ...
    def __bool__(self) -&gt; bool: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def to_py(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def to_dict(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def stringify(self, *, fmt: bool = False) -&gt; str: ...
    def append(self, key: _HeaderName, value: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def contains_key(self, key: _HeaderName) -&gt; bool: ...
    def get(self, key: _HeaderName) -&gt; str | None: ...
    def get_all(self, key: _HeaderName) -&gt; list[str]: ...
    def insert(self, key: _HeaderName, value: str) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def keys(self) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def pop(self, key: _HeaderName) -&gt; str: ...
    def remove(self, key: _HeaderName) -&gt; None: ...
    def update(
        self, headers: t.Self | dict[str, str], *, append: bool = False
    ) -&gt; None: ...
    def values(self) -&gt; list[str]: ...
    @property
    def is_flat(self) -&gt; bool: ...
    @staticmethod
    def from_json(data: str) -&gt; Headers: ...


@t.final
class HttpStatus:
    def __init__(self, code: int) -&gt; None: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: t.Self | int) -&gt; bool: ...
    def __le__(self, other: t.Self | int) -&gt; bool: ...
    def __gt__(self, other: t.Self | int) -&gt; bool: ...
    def __ge__(self, other: t.Self | int) -&gt; bool: ...
    def to_py(self) -&gt; int: ...
    @property
    def reason(self) -&gt; str: ...
    @property
    def canonical_reason(self) -&gt; str: ...
    @property
    def is_informational(self) -&gt; bool: ...
    @property
    def is_success(self) -&gt; bool: ...
    @property
    def is_redirect(self) -&gt; bool: ...
    @property
    def is_redirection(self) -&gt; bool: ...
    @property
    def is_client_error(self) -&gt; bool: ...
    @property
    def is_server_error(self) -&gt; bool: ...
    @property
    def is_error(self) -&gt; bool: ...
    @property
    def is_ok(self) -&gt; bool: ...
    @property
    def ok(self) -&gt; bool: ...

    # =========================================================================
    # CONST STATUS CODES
    # =========================================================================
    # fmt: off
    # 1xx: Informational
    CONTINUE: t.ClassVar[HttpStatus]  # 100 ~ Continue
    SWITCHING_PROTOCOLS: t.ClassVar[HttpStatus]  # 101 ~ Switching Protocols
    PROCESSING: t.ClassVar[HttpStatus]  # 102 ~ Processing
    EARLY_HINTS: t.ClassVar[HttpStatus]  # 103 ~ Early Hints
    # 2xx: Success
    OK: t.ClassVar[HttpStatus]  # 200 ~ OK
    CREATED: t.ClassVar[HttpStatus]  # 201 ~ Created
    ACCEPTED: t.ClassVar[HttpStatus]  # 202 ~ Accepted
    NON_AUTHORITATIVE_INFORMATION: t.ClassVar[HttpStatus]  # 203 ~ Non Authoritative Information
    NO_CONTENT: t.ClassVar[HttpStatus]  # 204 ~ No Content
    RESET_CONTENT: t.ClassVar[HttpStatus]  # 205 ~ Reset Content
    PARTIAL_CONTENT: t.ClassVar[HttpStatus]  # 206 ~ Partial Content
    MULTI_STATUS: t.ClassVar[HttpStatus]  # 207 ~ Multi-Status
    ALREADY_REPORTED: t.ClassVar[HttpStatus]  # 208 ~ Already Reported
    IM_USED: t.ClassVar[HttpStatus]  # 226 ~ IM Used
    # 3xx: Redirection
    MULTIPLE_CHOICES: t.ClassVar[HttpStatus]  # 300 ~ Multiple Choices
    MOVED_PERMANENTLY: t.ClassVar[HttpStatus]  # 301 ~ Moved Permanently
    FOUND: t.ClassVar[HttpStatus]  # 302 ~ Found
    SEE_OTHER: t.ClassVar[HttpStatus]  # 303 ~ See Other
    NOT_MODIFIED: t.ClassVar[HttpStatus]  # 304 ~ Not Modified
    USE_PROXY: t.ClassVar[HttpStatus]  # 305 ~ Use Proxy
    TEMPORARY_REDIRECT: t.ClassVar[HttpStatus]  # 307 ~ Temporary Redirect
    PERMANENT_REDIRECT: t.ClassVar[HttpStatus]  # 308 ~ Permanent Redirect
    # 4xx: Client Error
    BAD_REQUEST: t.ClassVar[HttpStatus]  # 400 ~ Bad Request
    UNAUTHORIZED: t.ClassVar[HttpStatus]  # 401 ~ Unauthorized
    PAYMENT_REQUIRED: t.ClassVar[HttpStatus]  # 402 ~ Payment Required
    FORBIDDEN: t.ClassVar[HttpStatus]  # 403 ~ Forbidden
    NOT_FOUND: t.ClassVar[HttpStatus]  # 404 ~ Not Found
    METHOD_NOT_ALLOWED: t.ClassVar[HttpStatus]  # 405 ~ Method Not Allowed
    NOT_ACCEPTABLE: t.ClassVar[HttpStatus]  # 406 ~ Not Acceptable
    PROXY_AUTHENTICATION_REQUIRED: t.ClassVar[HttpStatus]  # 407 ~ Proxy Authentication Required
    REQUEST_TIMEOUT: t.ClassVar[HttpStatus]  # 408 ~ Request Timeout
    CONFLICT: t.ClassVar[HttpStatus]  # 409 ~ Conflict
    GONE: t.ClassVar[HttpStatus]  # 410 ~ Gone
    LENGTH_REQUIRED: t.ClassVar[HttpStatus]  # 411 ~ Length Required
    PRECONDITION_FAILED: t.ClassVar[HttpStatus]  # 412 ~ Precondition Failed
    PAYLOAD_TOO_LARGE: t.ClassVar[HttpStatus]  # 413 ~ Payload Too Large
    URI_TOO_LONG: t.ClassVar[HttpStatus]  # 414 ~ URI Too Long
    UNSUPPORTED_MEDIA_TYPE: t.ClassVar[HttpStatus]  # 415 ~ Unsupported Media Type
    RANGE_NOT_SATISFIABLE: t.ClassVar[HttpStatus]  # 416 ~ Range Not Satisfiable
    EXPECTATION_FAILED: t.ClassVar[HttpStatus]  # 417 ~ Expectation Failed
    IM_A_TEAPOT: t.ClassVar[HttpStatus]  # 418 ~ I'm a teapot
    MISDIRECTED_REQUEST: t.ClassVar[HttpStatus]  # 421 ~ Misdirected Request
    UNPROCESSABLE_ENTITY: t.ClassVar[HttpStatus]  # 422 ~ Unprocessable Entity
    LOCKED: t.ClassVar[HttpStatus]  # 423 ~ Locked
    FAILED_DEPENDENCY: t.ClassVar[HttpStatus]  # 424 ~ Failed Dependency
    TOO_EARLY: t.ClassVar[HttpStatus]  # 425 ~ Too Early
    UPGRADE_REQUIRED: t.ClassVar[HttpStatus]  # 426 ~ Upgrade Required
    PRECONDITION_REQUIRED: t.ClassVar[HttpStatus]  # 428 ~ Precondition Required
    TOO_MANY_REQUESTS: t.ClassVar[HttpStatus]  # 429 ~ Too Many Requests
    REQUEST_HEADER_FIELDS_TOO_LARGE: t.ClassVar[HttpStatus]  # 431 ~ Request Header Fields Too Large
    UNAVAILABLE_FOR_LEGAL_REASONS: t.ClassVar[HttpStatus]  # 451 ~ Unavailable For Legal Reasons
    # 5xx: Server Error
    INTERNAL_SERVER_ERROR: t.ClassVar[HttpStatus]  # 500 ~ Internal Server Error
    NOT_IMPLEMENTED: t.ClassVar[HttpStatus]  # 501 ~ Not Implemented
    BAD_GATEWAY: t.ClassVar[HttpStatus]  # 502 ~ Bad Gateway
    SERVICE_UNAVAILABLE: t.ClassVar[HttpStatus]  # 503 ~ Service Unavailable
    GATEWAY_TIMEOUT: t.ClassVar[HttpStatus]  # 504 ~ Gateway Timeout
    HTTP_VERSION_NOT_SUPPORTED: t.ClassVar[HttpStatus]  # 505 ~ HTTP Version Not Supported
    VARIANT_ALSO_NEGOTIATES: t.ClassVar[HttpStatus]  # 506 ~ Variant Also Negotiates
    INSUFFICIENT_STORAGE: t.ClassVar[HttpStatus]  # 507 ~ Insufficient Storage
    LOOP_DETECTED: t.ClassVar[HttpStatus]  # 508 ~ Loop Detected
    NOT_EXTENDED: t.ClassVar[HttpStatus]  # 510 ~ Not Extended
    NETWORK_AUTHENTICATION_REQUIRED: t.ClassVar[HttpStatus]  # 511 ~ Network Authentication Required
    # fmt: on
</code></pre>
<h2 id="ry.ryo3._jiff"><code>ry.ryo3._jiff</code></h2>

<pre><code class="language-python">"""ryo3-jiff types"""

import datetime as pydt
import sys
import typing as t

from ry._types import (
    DateDifferenceTypedDict,
    DateTimeDifferenceTypedDict,
    DateTimeRoundTypedDict,
    DateTimeTypedDict,
    DateTypedDict,
    ISOWeekDateTypedDict,
    OffsetInfoDict,
    OffsetRoundTypedDict,
    OffsetTypedDict,
    SignedDurationRoundTypedDict,
    SignedDurationTypedDict,
    TimeDifferenceTypedDict,
    TimeRoundTypedDict,
    TimeSpanTypedDict,
    TimestampDifferenceTypedDict,
    TimestampRoundTypedDict,
    TimestampTypedDict,
    TimeTypedDict,
    TimeZoneDict,
    ZonedDateTimeDifferenceTypedDict,
    ZonedDateTimeRoundTypedDict,
    ZonedDateTimeTypedDict,
)
from ry.protocols import (
    FromStr,
    Strftime,
    ToPy,
    ToPyDate,
    ToPyDateTime,
    ToPyTime,
    ToPyTimeDelta,
    ToPyTzInfo,
    ToString,
    _Parse,
)
from ry.ryo3 import Duration
from ry.ryo3._jiff_tz import TimezoneDbName

if sys.version_info &gt;= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated

_T = t.TypeVar("_T")
_Temporal = t.TypeVar(
    "_Temporal", bound=ZonedDateTime | DateTime | Timestamp | Date | Time
)

_TDict = t.TypeVar("_TDict")
TimezoneName: t.TypeAlias = TimezoneDbName | str
JiffUnit: t.TypeAlias = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JiffRoundMode: t.TypeAlias = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half-ceil",
    "half-floor",
    "half-expand",
    "half-trunc",
    "half-even",
]
_DateTimeRoundSmallest: t.TypeAlias = t.Literal[
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_SignedDurationRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_TimeRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_TimestampRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_ZonedDateTimeRoundSmallest: t.TypeAlias = t.Literal[
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_OffsetRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
]
_DateDifferenceUnit: t.TypeAlias = t.Literal[
    "year",
    "month",
    "week",
    "day",
]

WeekdayStr: t.TypeAlias = t.Literal[
    "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
]
WeekdayInt: t.TypeAlias = t.Literal[
    1,  # Monday
    2,  # Tuesday
    3,  # Wednesday
    4,  # Thursday
    5,  # Friday
    6,  # Saturday
    7,  # Sunday
]
Weekday: t.TypeAlias = WeekdayStr | WeekdayInt


@t.final
class Date(
    # protocols
    FromStr,
    Strftime,
    ToPyDate,
    ToPy[pydt.date],
    ToString,
    _Parse,
):
    MIN: t.ClassVar[Date]
    MAX: t.ClassVar[Date]
    ZERO: t.ClassVar[Date]

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.date: ...
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls, date: pydt.date) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(cls, iso_week_date: ISOWeekDate) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self:
        """Same as today for parity with other date/time types"""

    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; Date: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; Date: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; Date: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; Date: ...
    def saturating_add(
        self,
        other: TimeSpan | SignedDuration | Duration | pydt.timedelta,
    ) -&gt; Date: ...
    def saturating_sub(
        self,
        other: TimeSpan | SignedDuration | Duration | pydt.timedelta,
    ) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int = 0
    ) -&gt; DateTime: ...
    def to_dict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def replace(
        self,
        *,
        year: int | None = None,
        month: int | None = None,
        day: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
    ) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def to_datetime(self, time: Time) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: _DateDifferenceUnit = "day",
        largest: _DateDifferenceUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: _DateDifferenceUnit = "day",
        largest: _DateDifferenceUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class Time(
    # protocols
    FromStr,
    Strftime,
    ToPyTime,
    ToPy[pydt.time],
    _Parse,
):
    MIN: t.ClassVar[Time]
    MAX: t.ClassVar[Time]

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.time: ...
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls, t: pydt.time) -&gt; t.Self: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def utcnow(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def to_dict(self) -&gt; TimeTypedDict: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def replace(
        self,
        *,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _TimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: TimeRound) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def to_datetime(self, date: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        t: Time | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        t: Time | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class DateTime(
    # protocols
    FromStr,
    Strftime,
    ToPyDate,
    ToPyDateTime,
    ToPyTime,
    ToPy[pydt.datetime],
    _Parse,
):
    MIN: t.ClassVar[DateTime]
    MAX: t.ClassVar[DateTime]
    ZERO: t.ClassVar[DateTime]

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, fmt: str) -&gt; str: ...
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def __format__(self, fmt: str) -&gt; str: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, datetime: pydt.datetime) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def from_parts(cls, date: Date, time: Time) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def to_dict(self) -&gt; DateTimeTypedDict: ...
    def date(self) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; t.Self: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def replace(
        self,
        obj: Date | DateTime | Time | None = None,
        *,
        date: Date | None = None,
        time: Time | None = None,
        year: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        month: int | None = None,
        day: int | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _DateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: DateTimeRound) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def start_of_day(self) -&gt; t.Self: ...
    def time(self) -&gt; Time: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


class TimeZoneTransition(t.TypedDict):
    timestamp: Timestamp
    offset: Offset
    dst: bool
    abbreviation: str


@t.final
class TimeZone(
    # protocols
    FromStr,
    ToPyTzInfo,
    ToPy[pydt.tzinfo],
    _Parse,
):
    UTC: t.ClassVar[TimeZone]

    def __init__(self, name: TimezoneName) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================

    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    def to_dict(self) -&gt; TimeZoneDict: ...
    @classmethod
    def from_str(cls, s: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_pytzinfo(cls, tz: pydt.tzinfo) -&gt; t.Self: ...
    def to_offset_info(self, timestamp: Timestamp) -&gt; OffsetInfoDict: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...
    @property
    def is_unknown(self) -&gt; bool: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls, offset: Offset) -&gt; t.Self: ...
    @classmethod
    def get(cls, tz_name: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def posix(cls, tz_name: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def system(cls) -&gt; t.Self: ...
    @classmethod
    def try_system(cls) -&gt; t.Self: ...
    @classmethod
    def tzif(cls, name: str, data: bytes) -&gt; t.Self: ...
    @classmethod
    def utc(cls) -&gt; t.Self: ...
    def equiv(self, other: t.Self | pydt.tzinfo | str) -&gt; bool: ...
    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_fixed_offset(self) -&gt; Offset:
        """Return a TimeZone with a fixed offset equivalent to this TimeZone.

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; tz = ry.TimeZone.fixed(ry.Offset(hours=-5))
            &gt;&gt;&gt; fixed_tz = tz.to_fixed_offset()
            &gt;&gt;&gt; fixed_tz
            Offset(hours=-5)

        """

    def to_offset(self, timestamp: Timestamp) -&gt; Offset: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, datetime: DateTime) -&gt; ZonedDateTime: ...
    def preceding(
        self,
        timestamp: Timestamp,
        /,
        limit: int | None = None,
    ) -&gt; list[TimeZoneTransition]: ...
    def following(
        self,
        timestamp: Timestamp,
        /,
        limit: int | None = None,
    ) -&gt; list[TimeZoneTransition]: ...
    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


@t.final
class SignedDuration(
    # protocols
    FromStr,
    ToPyTimeDelta,
    ToPy[pydt.timedelta],
    _Parse,
):
    MIN: t.ClassVar[SignedDuration]
    MAX: t.ClassVar[SignedDuration]
    ZERO: t.ClassVar[SignedDuration]

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; t.Self: ...
    @t.overload
    def __add__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    @t.overload
    def __add__(self, val: _Temporal) -&gt; _Temporal: ...
    def __radd__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    def __sub__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    def __rsub__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __rmul__(self, other: int) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    @t.overload
    def __truediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __truediv__(self, other: float) -&gt; t.Self: ...
    def abs(self) -&gt; t.Self: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...
    # =========================================================================
    # EQUIV
    # =========================================================================
    def equiv(self, other: t.Self | Duration | pydt.timedelta) -&gt; bool: ...
    # =========================================================================
    # STRING
    # =========================================================================
    def isoformat(self) -&gt; str: ...
    @classmethod
    def from_isoformat(cls, s: str) -&gt; t.Self: ...
    def to_string(self, *, friendly: bool = False) -&gt; str: ...
    def friendly(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.timedelta: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_dict(self) -&gt; SignedDurationTypedDict: ...
    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; t.Self: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; t.Self: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; t.Self: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; t.Self: ...
    @classmethod
    def from_secs(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; t.Self: ...
    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: t.Self) -&gt; t.Self | None: ...
    def checked_div(self, other: int) -&gt; t.Self | None: ...
    def checked_mul(self, other: int) -&gt; t.Self | None: ...
    def checked_neg(self) -&gt; t.Self | None: ...
    def checked_sub(self, other: t.Self) -&gt; t.Self | None: ...
    def div_duration_f32(self, other: t.Self) -&gt; float: ...
    def div_duration_f64(self, other: t.Self) -&gt; float: ...
    def div_f32(self, n: float) -&gt; float: ...
    def div_f64(self, n: float) -&gt; float: ...
    def mul_f32(self, n: float) -&gt; t.Self: ...
    def mul_f64(self, n: float) -&gt; t.Self: ...
    def saturating_add(self, other: t.Self) -&gt; t.Self: ...
    def saturating_mul(self, other: int) -&gt; t.Self: ...
    def saturating_sub(self, other: t.Self) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_timespan(self) -&gt; TimeSpan: ...
    def round(
        self,
        smallest: _SignedDurationRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: SignedDurationRound) -&gt; t.Self: ...


TimeSpanArithmetic: t.TypeAlias = (
    TimeSpan
    | Duration
    | SignedDuration
    | tuple[
        TimeSpan | Duration | SignedDuration, ZonedDateTime | Date | DateTime
    ]
)


@t.final
class TimeSpan(
    # protocols
    ToPy[pydt.timedelta],
    ToPyTimeDelta,
    FromStr,
    _Parse,
):
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def isoformat(self) -&gt; str: ...
    @classmethod
    def from_isoformat(cls, s: str) -&gt; t.Self: ...
    def to_string(self, *, friendly: bool = False) -&gt; str: ...
    def friendly(self) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def parse_common_iso(cls, s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    @t.overload
    def __add__(self, val: TimeSpanArithmetic) -&gt; t.Self: ...
    @t.overload
    def __add__(self, val: _Temporal) -&gt; _Temporal: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __neg__(self) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __invert__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: int) -&gt; t.Self: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(self, other: TimeSpanArithmetic) -&gt; t.Self: ...
    def mul(self, other: int) -&gt; t.Self: ...
    def sub(self, other: TimeSpanArithmetic) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; t.Self: ...
    def to_dict(self) -&gt; TimeSpanTypedDict: ...
    def fieldwise(self) -&gt; TimeSpanTypedDict: ...
    def compare(
        self,
        other: t.Self,
        relative: ZonedDateTime | DateTime | Date | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def negate(self) -&gt; t.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: JiffUnit = "nanosecond",
        increment: int = 1,
        *,
        relative: ZonedDateTime | Date | DateTime | None = None,
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "half-expand",
        days_are_24_hours: bool = False,
    ) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self,
        relative: ZonedDateTime | Date | DateTime | None = None,
    ) -&gt; SignedDuration: ...
    def total(
        self,
        unit: JiffUnit,
        relative: ZonedDateTime | Date | DateTime | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; float: ...
    def total_seconds(
        self,
        relative: ZonedDateTime | Date | DateTime | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; float: ...
    def _years(self, years: int, /) -&gt; t.Self: ...
    def _months(self, months: int, /) -&gt; t.Self: ...
    def _weeks(self, weeks: int, /) -&gt; t.Self: ...
    def _days(self, days: int, /) -&gt; t.Self: ...
    def _hours(self, hours: int, /) -&gt; t.Self: ...
    def _minutes(self, minutes: int, /) -&gt; t.Self: ...
    def _seconds(self, seconds: int, /) -&gt; t.Self: ...
    def _milliseconds(self, milliseconds: int, /) -&gt; t.Self: ...
    def _microseconds(self, microseconds: int, /) -&gt; t.Self: ...
    def _nanoseconds(self, nanoseconds: int, /) -&gt; t.Self: ...


@t.final
class Timestamp(
    # protocols
    FromStr,
    Strftime,
    ToPyDate,
    ToPyDateTime,
    ToPyTime,
    ToPy[pydt.datetime],
    _Parse,
):
    """An instant in time represented as the number of nanoseconds since the Unix epoch.

    A timestamp is always in the Unix timescale with a UTC offset of zero.
    """

    MIN: t.ClassVar[Timestamp]
    MAX: t.ClassVar[Timestamp]
    UNIX_EPOCH: t.ClassVar[Timestamp]

    def __init__(self, second: int = 0, nanosecond: int = 0) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_millisecond(cls, millisecond: int) -&gt; t.Self: ...
    @classmethod
    def from_microsecond(cls, microsecond: int) -&gt; t.Self: ...
    @classmethod
    def from_nanosecond(cls, nanosecond: int) -&gt; t.Self: ...
    @classmethod
    def from_second(cls, second: int) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, datetime: pydt.datetime) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    def to_dict(self) -&gt; TimestampTypedDict: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def second(self) -&gt; int:
        """Return the second component of the timestamp

        Returns:
            int: The second component of the timestamp.

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.second
            5
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.second
            -5

        """

    @property
    def nanosecond(self) -&gt; int:
        """Return the nanosecond component (-999_999_999..999_999_999)

        Returns:
            int: The nanosecond component of the timestamp (-999_999_999..999_999_999).

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.nanosecond
            123456789
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.nanosecond
            999999999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.nanosecond
            -123456789
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.nanosecond
            -999999999

        """

    @property
    def subsec_microsecond(self) -&gt; int:
        """Return the subsecond microsecond component (-999_999..999_999)

        Returns:
            int: subsecond microsecond component of the timestamp

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.subsec_microsecond
            123456
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.subsec_microsecond
            999999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.subsec_microsecond
            -123456
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.subsec_microsecond
            -999999

        """

    @property
    def subsec_millisecond(self) -&gt; int:
        """Return the subsecond millisecond component (-999..999)

        Returns:
            int: The subsecond millisecond component of the timestamp (-999..999).

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.subsec_millisecond
            123
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.subsec_millisecond
            999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.subsec_millisecond
            -123
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.subsec_millisecond
            -999

        """

    @property
    def subsec_nanosecond(self) -&gt; int:
        """Return the subsecond nanosecond component (-999_999_999..999_999_999)

        Returns:
            int: The subsecond nanosecond component of the timestamp (-999_999_999..999_999_999).

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.subsec_nanosecond
            123456789
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.subsec_nanosecond
            999999999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.subsec_nanosecond
            -123456789
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.subsec_nanosecond
            -999999999

        """

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def isoformat(self) -&gt; str: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def time(self) -&gt; Time: ...
    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...
    def as_second(self) -&gt; int: ...
    def display_with_offset(self, offset: Offset) -&gt; str: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime:
        """Deprecated ~ use `in_tz`"""

    @property
    def is_zero(self) -&gt; bool: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_string(self) -&gt; str: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def round(
        self,
        smallest: _TimestampRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: TimestampRound) -&gt; t.Self: ...


@t.final
class ZonedDateTime(
    # protocols
    ToPy[pydt.datetime],
    ToPyDate,
    ToPyTime,
    ToPyDateTime,
    ToPyTzInfo,
    FromStr,
    _Parse,
    Strftime,
):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
        tz: TimezoneName | None = None,
    ) -&gt; None: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, datetime: pydt.datetime) -&gt; t.Self: ...
    def to_dict(self) -&gt; ZonedDateTimeTypedDict: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls, tz: TimezoneName | None = None) -&gt; t.Self: ...
    @classmethod
    def utcnow(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_rfc2822(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse_rfc2822(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def from_parts(
        cls, timestamp: Timestamp, time_zone: TimeZone
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...
    @property
    def timezone(self) -&gt; TimeZone: ...
    @property
    def tz(self) -&gt; TimeZone: ...

    # =========================================================================
    # STRING/FORMAT
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def to_rfc2822(self) -&gt; str: ...
    def format_rfc2822(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; t.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; t.Self: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; t.Self: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; t.Self: ...
    def inutc(self) -&gt; t.Self: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; Date: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; Date: ...
    def offset(self) -&gt; Offset: ...
    def replace(
        self,
        obj: Date | DateTime | Time | Offset | None = None,
        *,
        date: Date | None = None,
        time: Time | None = None,
        year: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        month: int | None = None,
        day: int | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
        offset: Offset | None = None,
        offset_conflict: t.Literal[
            "always-offset", "always-timezone", "prefer-offset", "reject"
        ]
        | None = None,
        disambiguation: t.Literal["compatible", "earliest", "latest", "reject"]
        | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _ZonedDateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: ZonedDateTimeRound) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def start_of_day(self) -&gt; t.Self: ...
    def time(self) -&gt; Time: ...
    def timestamp(self) -&gt; Timestamp: ...
    def tomorrow(self) -&gt; t.Self: ...
    def with_time_zone(self, tz: TimeZone) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self,
        other: t.Self,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: t.Self,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class ISOWeekDate(
    # protocols
    ToPy[pydt.date],
    ToPyDate,
    FromStr,
    _Parse,
):
    MIN: t.ClassVar[ISOWeekDate]
    MAX: t.ClassVar[ISOWeekDate]
    ZERO: t.ClassVar[ISOWeekDate]

    def __init__(self, year: int, week: int, weekday: Weekday) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================

    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __le__(self, other: ISOWeekDate) -&gt; bool: ...
    def __gt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __ge__(self, other: ISOWeekDate) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_date(cls, date: Date) -&gt; t.Self: ...
    @classmethod
    def from_pydate(cls, date: pydt.date) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def week(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; WeekdayInt: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...
    def isoformat(self) -&gt; str: ...
    def to_py(self) -&gt; pydt.date: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_string(self) -&gt; str: ...
    def to_dict(self) -&gt; ISOWeekDateTypedDict: ...


@t.final
class Offset(
    # protocols
    ToPy[pydt.tzinfo],
    ToPyTzInfo,
    ToPyTimeDelta,
    FromStr,
    _Parse,
):
    MIN: t.ClassVar[Offset]
    MAX: t.ClassVar[Offset]
    UTC: t.ClassVar[Offset]
    ZERO: t.ClassVar[Offset]

    def __init__(
        self,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    # __FROM__
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    @classmethod
    def from_pytzinfo(cls, tz: pydt.tzinfo) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...

    # __TO__
    def to_dict(self) -&gt; OffsetTypedDict: ...
    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls) -&gt; t.Self: ...
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_seconds(cls, seconds: int) -&gt; t.Self: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def isoformat(self) -&gt; str: ...
    def negate(self) -&gt; t.Self: ...
    def since(self, other: t.Self) -&gt; TimeSpan: ...
    def until(self, other: t.Self) -&gt; TimeSpan: ...
    def round(
        self,
        smallest: _OffsetRoundSmallest = "second",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: OffsetRound) -&gt; t.Self: ...


# =============================================================================
# DIFFERENCE
# =============================================================================
_TObj = t.TypeVar("_TObj", Date, DateTime, Time, Timestamp, ZonedDateTime)


@t.type_check_only
class _Difference(t.Generic[_TObj, _TDict]):
    def __init__(
        self,
        obj: _TObj,
        *,
        smallest: JiffUnit,
        largest: JiffUnit | None = None,
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @property
    def smallest(self) -&gt; JiffUnit: ...
    @property
    def largest(self) -&gt; JiffUnit | None: ...
    @property
    def mode(self) -&gt; JiffRoundMode: ...
    @property
    def increment(self) -&gt; int: ...
    def _smallest(self, unit: JiffUnit) -&gt; t.Self: ...
    def _largest(self, unit: JiffUnit) -&gt; t.Self: ...
    def _mode(self, mode: JiffRoundMode) -&gt; t.Self: ...
    def _increment(self, increment: int) -&gt; t.Self: ...
    def to_dict(self) -&gt; _TDict: ...


@t.final
class DateDifference(_Difference[Date, DateDifferenceTypedDict]):
    def __init__(
        self,
        obj: Date,
        *,
        smallest: JiffUnit = "day",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def date(self) -&gt; Date: ...


@t.final
class DateTimeDifference(_Difference[DateTime, DateTimeDifferenceTypedDict]):
    def __init__(
        self,
        obj: DateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def datetime(self) -&gt; DateTime: ...


@t.final
class TimeDifference(_Difference[Time, TimeDifferenceTypedDict]):
    def __init__(
        self,
        obj: Time,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def time(self) -&gt; Time: ...


@t.final
class TimestampDifference(_Difference[Timestamp, TimestampDifferenceTypedDict]):
    def __init__(
        self,
        obj: Timestamp,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def timestamp(self) -&gt; Timestamp: ...


@t.final
class ZonedDateTimeDifference(
    _Difference[ZonedDateTime, ZonedDateTimeDifferenceTypedDict]
):
    def __init__(
        self,
        obj: ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def zoned(self) -&gt; ZonedDateTime: ...


# =============================================================================
# ROUND
# =============================================================================

_TSmallest = t.TypeVar(
    "_TSmallest",
)


@t.type_check_only
class _Round(t.Generic[_TSmallest, _TDict]):
    def __eq__(self, other: object) -&gt; bool: ...
    def _mode(self, mode: JiffRoundMode) -&gt; t.Self: ...
    def _smallest(self, smallest: _TSmallest) -&gt; t.Self: ...
    def _increment(self, increment: int) -&gt; t.Self: ...
    @property
    def smallest(self) -&gt; _TSmallest: ...
    @property
    def mode(self) -&gt; JiffRoundMode: ...
    @property
    def increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: _TSmallest | None = None,
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; t.Self: ...
    def to_dict(self) -&gt; _TDict: ...


@t.final
class DateTimeRound(_Round[_DateTimeRoundSmallest, DateTimeRoundTypedDict]):
    def __init__(
        self,
        smallest: _DateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: DateTime) -&gt; DateTime: ...


@t.final
class SignedDurationRound(
    _Round[_SignedDurationRoundSmallest, SignedDurationRoundTypedDict]
):
    def __init__(
        self,
        smallest: _SignedDurationRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: SignedDuration) -&gt; SignedDuration: ...


@t.final
class TimeRound(_Round[_TimeRoundSmallest, TimeRoundTypedDict]):
    def __init__(
        self,
        smallest: _TimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: Time) -&gt; Time: ...


@t.final
class TimestampRound(_Round[_TimestampRoundSmallest, TimestampRoundTypedDict]):
    def __init__(
        self,
        smallest: _TimestampRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: Timestamp) -&gt; Timestamp: ...


@t.final
class ZonedDateTimeRound(
    _Round[_ZonedDateTimeRoundSmallest, ZonedDateTimeRoundTypedDict]
):
    def __init__(
        self,
        smallest: _ZonedDateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: ZonedDateTime) -&gt; ZonedDateTime: ...


@t.final
class OffsetRound(_Round[_OffsetRoundSmallest, OffsetRoundTypedDict]):
    def __init__(
        self,
        smallest: _OffsetRoundSmallest = "second",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: Offset) -&gt; Offset: ...


@t.type_check_only
class JiffSeries(t.Protocol[_T]):
    def __iter__(self) -&gt; JiffSeries[_T]: ...
    def __next__(self) -&gt; _T: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...
    def take_until(self, value: _T) -&gt; list[_T]: ...
    def collect(self) -&gt; list[_T]: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def zoned(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
    tz: TimezoneName | None = None,
) -&gt; ZonedDateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...
def now() -&gt; ZonedDateTime: ...
def utcnow() -&gt; ZonedDateTime: ...


# =============================================================================
# TIMEZONE-DATABASE
# =============================================================================
@t.final
class TimeZoneDatabase:
    def __init__(self) -&gt; None:
        """Defaults to using the `self.from_env`"""

    @t.overload
    def get(self, name: TimezoneName, err: t.Literal[False]) -&gt; TimeZone | None:
        """Returns TimeZone or None if the timezone is not found"""

    @t.overload
    def get(self, name: TimezoneName, err: t.Literal[True] = True) -&gt; TimeZone:
        """Returns TimeZone, if not found raises a ValueError"""

    def available(self) -&gt; list[str]: ...
    def __getitem__(self, name: TimezoneName) -&gt; TimeZone: ...
    def __len__(self) -&gt; int: ...
    def is_definitively_empty(self) -&gt; bool: ...
    @classmethod
    def from_env(cls) -&gt; t.Self: ...
    @classmethod
    def from_dir(cls, path: str) -&gt; t.Self: ...
    @classmethod
    def from_concatenated_path(cls, path: str) -&gt; t.Self: ...
    @classmethod
    def bundled(cls) -&gt; t.Self: ...
</code></pre>
<h2 id="ry.ryo3._jiff_tz"><code>ry.ryo3._jiff_tz</code></h2>

<pre><code class="language-python">from typing import Literal, TypeAlias

TimezoneDbName: TypeAlias = Literal[
    "Africa/Abidjan",
    "Africa/Accra",
    "Africa/Addis_Ababa",
    "Africa/Algiers",
    "Africa/Asmara",
    "Africa/Asmera",
    "Africa/Bamako",
    "Africa/Bangui",
    "Africa/Banjul",
    "Africa/Bissau",
    "Africa/Blantyre",
    "Africa/Brazzaville",
    "Africa/Bujumbura",
    "Africa/Cairo",
    "Africa/Casablanca",
    "Africa/Ceuta",
    "Africa/Conakry",
    "Africa/Dakar",
    "Africa/Dar_es_Salaam",
    "Africa/Djibouti",
    "Africa/Douala",
    "Africa/El_Aaiun",
    "Africa/Freetown",
    "Africa/Gaborone",
    "Africa/Harare",
    "Africa/Johannesburg",
    "Africa/Juba",
    "Africa/Kampala",
    "Africa/Khartoum",
    "Africa/Kigali",
    "Africa/Kinshasa",
    "Africa/Lagos",
    "Africa/Libreville",
    "Africa/Lome",
    "Africa/Luanda",
    "Africa/Lubumbashi",
    "Africa/Lusaka",
    "Africa/Malabo",
    "Africa/Maputo",
    "Africa/Maseru",
    "Africa/Mbabane",
    "Africa/Mogadishu",
    "Africa/Monrovia",
    "Africa/Nairobi",
    "Africa/Ndjamena",
    "Africa/Niamey",
    "Africa/Nouakchott",
    "Africa/Ouagadougou",
    "Africa/Porto-Novo",
    "Africa/Sao_Tome",
    "Africa/Timbuktu",
    "Africa/Tripoli",
    "Africa/Tunis",
    "Africa/Windhoek",
    "America/Adak",
    "America/Anchorage",
    "America/Anguilla",
    "America/Antigua",
    "America/Araguaina",
    "America/Argentina/Buenos_Aires",
    "America/Argentina/Catamarca",
    "America/Argentina/ComodRivadavia",
    "America/Argentina/Cordoba",
    "America/Argentina/Jujuy",
    "America/Argentina/La_Rioja",
    "America/Argentina/Mendoza",
    "America/Argentina/Rio_Gallegos",
    "America/Argentina/Salta",
    "America/Argentina/San_Juan",
    "America/Argentina/San_Luis",
    "America/Argentina/Tucuman",
    "America/Argentina/Ushuaia",
    "America/Aruba",
    "America/Asuncion",
    "America/Atikokan",
    "America/Atka",
    "America/Bahia",
    "America/Bahia_Banderas",
    "America/Barbados",
    "America/Belem",
    "America/Belize",
    "America/Blanc-Sablon",
    "America/Boa_Vista",
    "America/Bogota",
    "America/Boise",
    "America/Buenos_Aires",
    "America/Cambridge_Bay",
    "America/Campo_Grande",
    "America/Cancun",
    "America/Caracas",
    "America/Catamarca",
    "America/Cayenne",
    "America/Cayman",
    "America/Chicago",
    "America/Chihuahua",
    "America/Ciudad_Juarez",
    "America/Coral_Harbour",
    "America/Cordoba",
    "America/Costa_Rica",
    "America/Coyhaique",
    "America/Creston",
    "America/Cuiaba",
    "America/Curacao",
    "America/Danmarkshavn",
    "America/Dawson",
    "America/Dawson_Creek",
    "America/Denver",
    "America/Detroit",
    "America/Dominica",
    "America/Edmonton",
    "America/Eirunepe",
    "America/El_Salvador",
    "America/Ensenada",
    "America/Fort_Nelson",
    "America/Fort_Wayne",
    "America/Fortaleza",
    "America/Glace_Bay",
    "America/Godthab",
    "America/Goose_Bay",
    "America/Grand_Turk",
    "America/Grenada",
    "America/Guadeloupe",
    "America/Guatemala",
    "America/Guayaquil",
    "America/Guyana",
    "America/Halifax",
    "America/Havana",
    "America/Hermosillo",
    "America/Indiana/Indianapolis",
    "America/Indiana/Knox",
    "America/Indiana/Marengo",
    "America/Indiana/Petersburg",
    "America/Indiana/Tell_City",
    "America/Indiana/Vevay",
    "America/Indiana/Vincennes",
    "America/Indiana/Winamac",
    "America/Indianapolis",
    "America/Inuvik",
    "America/Iqaluit",
    "America/Jamaica",
    "America/Jujuy",
    "America/Juneau",
    "America/Kentucky/Louisville",
    "America/Kentucky/Monticello",
    "America/Knox_IN",
    "America/Kralendijk",
    "America/La_Paz",
    "America/Lima",
    "America/Los_Angeles",
    "America/Louisville",
    "America/Lower_Princes",
    "America/Maceio",
    "America/Managua",
    "America/Manaus",
    "America/Marigot",
    "America/Martinique",
    "America/Matamoros",
    "America/Mazatlan",
    "America/Mendoza",
    "America/Menominee",
    "America/Merida",
    "America/Metlakatla",
    "America/Mexico_City",
    "America/Miquelon",
    "America/Moncton",
    "America/Monterrey",
    "America/Montevideo",
    "America/Montreal",
    "America/Montserrat",
    "America/Nassau",
    "America/New_York",
    "America/Nipigon",
    "America/Nome",
    "America/Noronha",
    "America/North_Dakota/Beulah",
    "America/North_Dakota/Center",
    "America/North_Dakota/New_Salem",
    "America/Nuuk",
    "America/Ojinaga",
    "America/Panama",
    "America/Pangnirtung",
    "America/Paramaribo",
    "America/Phoenix",
    "America/Port-au-Prince",
    "America/Port_of_Spain",
    "America/Porto_Acre",
    "America/Porto_Velho",
    "America/Puerto_Rico",
    "America/Punta_Arenas",
    "America/Rainy_River",
    "America/Rankin_Inlet",
    "America/Recife",
    "America/Regina",
    "America/Resolute",
    "America/Rio_Branco",
    "America/Rosario",
    "America/Santa_Isabel",
    "America/Santarem",
    "America/Santiago",
    "America/Santo_Domingo",
    "America/Sao_Paulo",
    "America/Scoresbysund",
    "America/Shiprock",
    "America/Sitka",
    "America/St_Barthelemy",
    "America/St_Johns",
    "America/St_Kitts",
    "America/St_Lucia",
    "America/St_Thomas",
    "America/St_Vincent",
    "America/Swift_Current",
    "America/Tegucigalpa",
    "America/Thule",
    "America/Thunder_Bay",
    "America/Tijuana",
    "America/Toronto",
    "America/Tortola",
    "America/Vancouver",
    "America/Virgin",
    "America/Whitehorse",
    "America/Winnipeg",
    "America/Yakutat",
    "America/Yellowknife",
    "Antarctica/Casey",
    "Antarctica/Davis",
    "Antarctica/DumontDUrville",
    "Antarctica/Macquarie",
    "Antarctica/Mawson",
    "Antarctica/McMurdo",
    "Antarctica/Palmer",
    "Antarctica/Rothera",
    "Antarctica/South_Pole",
    "Antarctica/Syowa",
    "Antarctica/Troll",
    "Antarctica/Vostok",
    "Arctic/Longyearbyen",
    "Asia/Aden",
    "Asia/Almaty",
    "Asia/Amman",
    "Asia/Anadyr",
    "Asia/Aqtau",
    "Asia/Aqtobe",
    "Asia/Ashgabat",
    "Asia/Ashkhabad",
    "Asia/Atyrau",
    "Asia/Baghdad",
    "Asia/Bahrain",
    "Asia/Baku",
    "Asia/Bangkok",
    "Asia/Barnaul",
    "Asia/Beirut",
    "Asia/Bishkek",
    "Asia/Brunei",
    "Asia/Calcutta",
    "Asia/Chita",
    "Asia/Choibalsan",
    "Asia/Chongqing",
    "Asia/Chungking",
    "Asia/Colombo",
    "Asia/Dacca",
    "Asia/Damascus",
    "Asia/Dhaka",
    "Asia/Dili",
    "Asia/Dubai",
    "Asia/Dushanbe",
    "Asia/Famagusta",
    "Asia/Gaza",
    "Asia/Harbin",
    "Asia/Hebron",
    "Asia/Ho_Chi_Minh",
    "Asia/Hong_Kong",
    "Asia/Hovd",
    "Asia/Irkutsk",
    "Asia/Istanbul",
    "Asia/Jakarta",
    "Asia/Jayapura",
    "Asia/Jerusalem",
    "Asia/Kabul",
    "Asia/Kamchatka",
    "Asia/Karachi",
    "Asia/Kashgar",
    "Asia/Kathmandu",
    "Asia/Katmandu",
    "Asia/Khandyga",
    "Asia/Kolkata",
    "Asia/Krasnoyarsk",
    "Asia/Kuala_Lumpur",
    "Asia/Kuching",
    "Asia/Kuwait",
    "Asia/Macao",
    "Asia/Macau",
    "Asia/Magadan",
    "Asia/Makassar",
    "Asia/Manila",
    "Asia/Muscat",
    "Asia/Nicosia",
    "Asia/Novokuznetsk",
    "Asia/Novosibirsk",
    "Asia/Omsk",
    "Asia/Oral",
    "Asia/Phnom_Penh",
    "Asia/Pontianak",
    "Asia/Pyongyang",
    "Asia/Qatar",
    "Asia/Qostanay",
    "Asia/Qyzylorda",
    "Asia/Rangoon",
    "Asia/Riyadh",
    "Asia/Saigon",
    "Asia/Sakhalin",
    "Asia/Samarkand",
    "Asia/Seoul",
    "Asia/Shanghai",
    "Asia/Singapore",
    "Asia/Srednekolymsk",
    "Asia/Taipei",
    "Asia/Tashkent",
    "Asia/Tbilisi",
    "Asia/Tehran",
    "Asia/Tel_Aviv",
    "Asia/Thimbu",
    "Asia/Thimphu",
    "Asia/Tokyo",
    "Asia/Tomsk",
    "Asia/Ujung_Pandang",
    "Asia/Ulaanbaatar",
    "Asia/Ulan_Bator",
    "Asia/Urumqi",
    "Asia/Ust-Nera",
    "Asia/Vientiane",
    "Asia/Vladivostok",
    "Asia/Yakutsk",
    "Asia/Yangon",
    "Asia/Yekaterinburg",
    "Asia/Yerevan",
    "Atlantic/Azores",
    "Atlantic/Bermuda",
    "Atlantic/Canary",
    "Atlantic/Cape_Verde",
    "Atlantic/Faeroe",
    "Atlantic/Faroe",
    "Atlantic/Jan_Mayen",
    "Atlantic/Madeira",
    "Atlantic/Reykjavik",
    "Atlantic/South_Georgia",
    "Atlantic/St_Helena",
    "Atlantic/Stanley",
    "Australia/ACT",
    "Australia/Adelaide",
    "Australia/Brisbane",
    "Australia/Broken_Hill",
    "Australia/Canberra",
    "Australia/Currie",
    "Australia/Darwin",
    "Australia/Eucla",
    "Australia/Hobart",
    "Australia/LHI",
    "Australia/Lindeman",
    "Australia/Lord_Howe",
    "Australia/Melbourne",
    "Australia/North",
    "Australia/NSW",
    "Australia/Perth",
    "Australia/Queensland",
    "Australia/South",
    "Australia/Sydney",
    "Australia/Tasmania",
    "Australia/Victoria",
    "Australia/West",
    "Australia/Yancowinna",
    "Brazil/Acre",
    "Brazil/DeNoronha",
    "Brazil/East",
    "Brazil/West",
    "Canada/Atlantic",
    "Canada/Central",
    "Canada/Eastern",
    "Canada/Mountain",
    "Canada/Newfoundland",
    "Canada/Pacific",
    "Canada/Saskatchewan",
    "Canada/Yukon",
    "CET",
    "Chile/Continental",
    "Chile/EasterIsland",
    "CST6CDT",
    "Cuba",
    "EET",
    "Egypt",
    "Eire",
    "EST",
    "EST5EDT",
    "Etc/GMT",
    "Etc/GMT+0",
    "Etc/GMT+1",
    "Etc/GMT+10",
    "Etc/GMT+11",
    "Etc/GMT+12",
    "Etc/GMT+2",
    "Etc/GMT+3",
    "Etc/GMT+4",
    "Etc/GMT+5",
    "Etc/GMT+6",
    "Etc/GMT+7",
    "Etc/GMT+8",
    "Etc/GMT+9",
    "Etc/GMT-0",
    "Etc/GMT-1",
    "Etc/GMT-10",
    "Etc/GMT-11",
    "Etc/GMT-12",
    "Etc/GMT-13",
    "Etc/GMT-14",
    "Etc/GMT-2",
    "Etc/GMT-3",
    "Etc/GMT-4",
    "Etc/GMT-5",
    "Etc/GMT-6",
    "Etc/GMT-7",
    "Etc/GMT-8",
    "Etc/GMT-9",
    "Etc/GMT0",
    "Etc/Greenwich",
    "Etc/UCT",
    "Etc/Universal",
    "Etc/UTC",
    "Etc/Zulu",
    "Europe/Amsterdam",
    "Europe/Andorra",
    "Europe/Astrakhan",
    "Europe/Athens",
    "Europe/Belfast",
    "Europe/Belgrade",
    "Europe/Berlin",
    "Europe/Bratislava",
    "Europe/Brussels",
    "Europe/Bucharest",
    "Europe/Budapest",
    "Europe/Busingen",
    "Europe/Chisinau",
    "Europe/Copenhagen",
    "Europe/Dublin",
    "Europe/Gibraltar",
    "Europe/Guernsey",
    "Europe/Helsinki",
    "Europe/Isle_of_Man",
    "Europe/Istanbul",
    "Europe/Jersey",
    "Europe/Kaliningrad",
    "Europe/Kiev",
    "Europe/Kirov",
    "Europe/Kyiv",
    "Europe/Lisbon",
    "Europe/Ljubljana",
    "Europe/London",
    "Europe/Luxembourg",
    "Europe/Madrid",
    "Europe/Malta",
    "Europe/Mariehamn",
    "Europe/Minsk",
    "Europe/Monaco",
    "Europe/Moscow",
    "Europe/Nicosia",
    "Europe/Oslo",
    "Europe/Paris",
    "Europe/Podgorica",
    "Europe/Prague",
    "Europe/Riga",
    "Europe/Rome",
    "Europe/Samara",
    "Europe/San_Marino",
    "Europe/Sarajevo",
    "Europe/Saratov",
    "Europe/Simferopol",
    "Europe/Skopje",
    "Europe/Sofia",
    "Europe/Stockholm",
    "Europe/Tallinn",
    "Europe/Tirane",
    "Europe/Tiraspol",
    "Europe/Ulyanovsk",
    "Europe/Uzhgorod",
    "Europe/Vaduz",
    "Europe/Vatican",
    "Europe/Vienna",
    "Europe/Vilnius",
    "Europe/Volgograd",
    "Europe/Warsaw",
    "Europe/Zagreb",
    "Europe/Zaporozhye",
    "Europe/Zurich",
    "Factory",
    "GB",
    "GB-Eire",
    "GMT",
    "GMT+0",
    "GMT-0",
    "GMT0",
    "Greenwich",
    "Hongkong",
    "HST",
    "Iceland",
    "Indian/Antananarivo",
    "Indian/Chagos",
    "Indian/Christmas",
    "Indian/Cocos",
    "Indian/Comoro",
    "Indian/Kerguelen",
    "Indian/Mahe",
    "Indian/Maldives",
    "Indian/Mauritius",
    "Indian/Mayotte",
    "Indian/Reunion",
    "Iran",
    "Israel",
    "Jamaica",
    "Japan",
    "Kwajalein",
    "Libya",
    "MET",
    "Mexico/BajaNorte",
    "Mexico/BajaSur",
    "Mexico/General",
    "MST",
    "MST7MDT",
    "Navajo",
    "NZ",
    "NZ-CHAT",
    "Pacific/Apia",
    "Pacific/Auckland",
    "Pacific/Bougainville",
    "Pacific/Chatham",
    "Pacific/Chuuk",
    "Pacific/Easter",
    "Pacific/Efate",
    "Pacific/Enderbury",
    "Pacific/Fakaofo",
    "Pacific/Fiji",
    "Pacific/Funafuti",
    "Pacific/Galapagos",
    "Pacific/Gambier",
    "Pacific/Guadalcanal",
    "Pacific/Guam",
    "Pacific/Honolulu",
    "Pacific/Johnston",
    "Pacific/Kanton",
    "Pacific/Kiritimati",
    "Pacific/Kosrae",
    "Pacific/Kwajalein",
    "Pacific/Majuro",
    "Pacific/Marquesas",
    "Pacific/Midway",
    "Pacific/Nauru",
    "Pacific/Niue",
    "Pacific/Norfolk",
    "Pacific/Noumea",
    "Pacific/Pago_Pago",
    "Pacific/Palau",
    "Pacific/Pitcairn",
    "Pacific/Pohnpei",
    "Pacific/Ponape",
    "Pacific/Port_Moresby",
    "Pacific/Rarotonga",
    "Pacific/Saipan",
    "Pacific/Samoa",
    "Pacific/Tahiti",
    "Pacific/Tarawa",
    "Pacific/Tongatapu",
    "Pacific/Truk",
    "Pacific/Wake",
    "Pacific/Wallis",
    "Pacific/Yap",
    "Poland",
    "Portugal",
    "PRC",
    "PST8PDT",
    "ROC",
    "ROK",
    "Singapore",
    "Turkey",
    "UCT",
    "Universal",
    "US/Alaska",
    "US/Aleutian",
    "US/Arizona",
    "US/Central",
    "US/East-Indiana",
    "US/Eastern",
    "US/Hawaii",
    "US/Indiana-Starke",
    "US/Michigan",
    "US/Mountain",
    "US/Pacific",
    "US/Samoa",
    "UTC",
    "W-SU",
    "WET",
    "Zulu",
]
</code></pre>
<h2 id="ry.ryo3._jiter"><code>ry.ryo3._jiter</code></h2>

<pre><code class="language-python">import typing as t
from os import PathLike

from ry._types import Buffer, Unpack

# =============================================================================
# JSON
# =============================================================================
JsonPrimitive: t.TypeAlias = None | bool | int | float | str
JsonValue: t.TypeAlias = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


class JsonParseKwargs(t.TypedDict, total=False):
    allow_inf_nan: bool
    """Allow parsing of `Infinity`, `-Infinity`, `NaN` ~ default: False"""
    cache_mode: t.Literal[True, False, "all", "keys", "none"]
    """Cache mode for JSON parsing ~ default: `all` """
    partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"]
    """Partial mode for JSON parsing ~ default: False"""
    catch_duplicate_keys: bool
    """Catch duplicate keys in JSON objects ~ default: False"""


def parse_json(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_jsonl(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; list[JsonValue]: ...
def read_json(
    p: str | PathLike[str],
    /,
    lines: bool = False,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def json_cache_clear() -&gt; None: ...
def json_cache_usage() -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._memchr"><code>ry.ryo3._memchr</code></h2>

<pre><code class="language-python">"""ryo3-memchr types"""

from typing import TypeAlias

from ry._types import Buffer

Byte: TypeAlias = int | bytes


def memchr(needle: Byte, haystack: Buffer) -&gt; int | None: ...
def memchr2(needle1: Byte, needle2: Byte, haystack: Buffer) -&gt; int | None: ...
def memchr3(
    needle1: Byte, needle2: Byte, needle3: Byte, haystack: Buffer
) -&gt; int | None: ...
def memrchr(needle: Byte, haystack: Buffer) -&gt; int | None: ...
def memrchr2(needle1: Byte, needle2: Byte, haystack: Buffer) -&gt; int | None: ...
def memrchr3(
    needle1: Byte, needle2: Byte, needle3: Byte, haystack: Buffer
) -&gt; int | None: ...
</code></pre>
<h2 id="ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></h2>

<pre><code class="language-python">"""ryo3-quick-maths types"""

import typing as t


def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """
</code></pre>
<h2 id="ry.ryo3._regex"><code>ry.ryo3._regex</code></h2>

<pre><code class="language-python">"""ryo3-regex types"""

import typing as t

# =============================================================================
# Regex
# =============================================================================


@t.final
class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: bytes | int | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def is_match(self, haystack: str) -&gt; bool: ...
    def test(self, haystack: str) -&gt; bool: ...
    def find(self, haystack: str) -&gt; str | None: ...
    def find_all(self, haystack: str) -&gt; list[tuple[int, int]]: ...
    def findall(self, haystack: str) -&gt; list[tuple[int, int]]: ...
    def replace(self, haystack: str, replacement: str) -&gt; str: ...
    def replace_all(self, haystack: str, replacement: str) -&gt; str: ...
    def split(self, haystack: str) -&gt; list[str]: ...
    def splitn(self, haystack: str, n: int) -&gt; list[str]: ...
</code></pre>
<h2 id="ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></h2>

<pre><code class="language-python">import typing as t

import ry
from ry._types import Buffer, Unpack
from ry.protocols import FromStr, _Parse
from ry.ryo3._encoding_rs import Encoding
from ry.ryo3._http import Headers, HttpStatus, HttpVersionLike
from ry.ryo3._std import Duration, SocketAddr
from ry.ryo3._url import URL

_Body: t.TypeAlias = (
    Buffer
    | t.Generator[Buffer]
    | t.AsyncGenerator[Buffer]
    | t.Iterable[Buffer]
    | t.AsyncIterable[Buffer]
)
# proxy
_ProxyKw: t.TypeAlias = t.Sequence[Proxy | URL | str] | Proxy | URL | str
# resolve
_ResolveMapLike: t.TypeAlias = dict[str, t.Sequence[SocketAddr]]


class RequestKwargs(t.TypedDict, total=False):
    body: _Body | None
    headers: Headers | dict[str, str] | None
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None
    json: t.Any
    form: t.Any
    multipart: t.Any
    timeout: Duration | None
    basic_auth: tuple[str, str | None] | None
    bearer_auth: str | None
    version: HttpVersionLike | None


class ClientConfig(t.TypedDict):
    headers: Headers | None  # default: None
    cookies: bool
    user_agent: (
        str | bool | None
    )  # None/True =&gt; default ("ry/{ry.__version__}"), False =&gt; disabled
    redirect: int | None
    resolve: _ResolveMapLike | None  # default: None
    referer: bool
    proxy: list[Proxy] | Proxy | None  # default: None
    hickory_dns: bool
    connection_verbose: bool  # default: False
    # ____ TIMEOUT ____
    timeout: Duration | None  # default: None
    connect_timeout: Duration | None  # default: None
    read_timeout: Duration | None  # default: None
    # ____ COMPRESSION / CONTENT-ENCODING ____
    gzip: bool
    brotli: bool
    deflate: bool
    zstd: bool
    # ____ HTTP1 ____
    http1_only: bool
    https_only: bool
    http1_title_case_headers: bool
    http1_allow_obsolete_multiline_headers_in_responses: bool
    http1_allow_spaces_after_header_name_in_responses: bool
    http1_ignore_invalid_headers_in_responses: bool
    # ____ HTTP2 ____
    http2_prior_knowledge: bool
    http2_initial_stream_window_size: int | None
    http2_initial_connection_window_size: int | None
    http2_adaptive_window: bool
    http2_max_frame_size: int | None
    http2_max_header_list_size: int | None
    http2_keep_alive_interval: Duration | None
    http2_keep_alive_timeout: Duration | None
    http2_keep_alive_while_idle: bool
    # ____ POOL ____
    pool_idle_timeout: Duration | None
    pool_max_idle_per_host: int | None
    # ____ TCP ____
    tcp_keepalive: Duration | None
    tcp_keepalive_interval: Duration | None
    tcp_keepalive_retries: int | None
    tcp_nodelay: bool
    # ____ TLS ____
    identity: Identity | None
    tls_certs_merge: list[Certificate] | None
    tls_certs_only: list[Certificate] | None
    tls_crls_only: list[CertificateRevocationList] | None
    tls_info: bool
    tls_sni: bool
    tls_version_max: (
        t.Literal["1.0", "1.1", "1.2", "1.3"] | None
    )  # default: None
    tls_version_min: (
        t.Literal["1.0", "1.1", "1.2", "1.3"] | None
    )  # default: None
    tls_danger_accept_invalid_certs: bool  # default: False
    tls_danger_accept_invalid_hostnames: bool  # default: False
    # __ UNSTABLE __
    _tls_cached_native_certs: bool  # default: False


@t.final
class HttpClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | Headers | None = None,
        cookies: bool = False,
        user_agent: str | bool | None = None,
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        redirect: int | None = 10,
        resolve: _ResolveMapLike | None = None,
        referer: bool = True,
        connection_verbose: bool = False,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
        zstd: bool = True,
        hickory_dns: bool = True,
        http1_only: bool = False,
        https_only: bool = False,
        http1_title_case_headers: bool = False,
        http1_allow_obsolete_multiline_headers_in_responses: bool = False,
        http1_allow_spaces_after_header_name_in_responses: bool = False,
        http1_ignore_invalid_headers_in_responses: bool = False,
        http2_prior_knowledge: bool = False,
        http2_initial_stream_window_size: int | None = None,
        http2_initial_connection_window_size: int | None = None,
        http2_adaptive_window: bool = False,
        http2_max_frame_size: int | None = None,
        http2_max_header_list_size: int | None = None,
        http2_keep_alive_interval: Duration | None = None,
        http2_keep_alive_timeout: Duration | None = None,
        http2_keep_alive_while_idle: bool = False,
        pool_idle_timeout: Duration | None = ...,  # 90 seconds
        pool_max_idle_per_host: int | None = ...,  # usize::MAX
        tcp_keepalive: Duration | None = ...,  # 15 seconds
        tcp_keepalive_interval: Duration | None = ...,  # 15 seconds
        tcp_keepalive_retries: int | None = 3,
        tcp_nodelay: bool = True,
        identity: Identity | None = None,
        tls_certs_only: list[Certificate] | None = None,
        tls_certs_merge: list[Certificate] | None = None,
        tls_crls_only: list[CertificateRevocationList] | None = None,
        tls_version_min: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_version_max: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_info: bool = False,
        tls_sni: bool = True,
        tls_danger_accept_invalid_certs: bool = False,
        tls_danger_accept_invalid_hostnames: bool = False,
        proxy: _ProxyKw | None = None,
        _tls_cached_native_certs: bool = False,
    ) -&gt; None: ...
    def config(self) -&gt; ClientConfig: ...
    async def get(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def post(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def put(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def delete(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def patch(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def options(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def head(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    def fetch_sync(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    async def __call__(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...


@t.final
class Client:
    """experimental client using the `pyo3/experimental-async` feature"""

    def __init__(
        self,
        *,
        headers: dict[str, str] | Headers | None = None,
        cookies: bool = False,
        user_agent: str | bool | None = None,
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        redirect: int | None = 10,
        resolve: _ResolveMapLike | None = None,
        referer: bool = True,
        connection_verbose: bool = False,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
        zstd: bool = True,
        hickory_dns: bool = True,
        http1_only: bool = False,
        https_only: bool = False,
        http1_title_case_headers: bool = False,
        http1_allow_obsolete_multiline_headers_in_responses: bool = False,
        http1_allow_spaces_after_header_name_in_responses: bool = False,
        http1_ignore_invalid_headers_in_responses: bool = False,
        http2_prior_knowledge: bool = False,
        http2_initial_stream_window_size: int | None = None,
        http2_initial_connection_window_size: int | None = None,
        http2_adaptive_window: bool = False,
        http2_max_frame_size: int | None = None,
        http2_max_header_list_size: int | None = None,
        http2_keep_alive_interval: Duration | None = None,
        http2_keep_alive_timeout: Duration | None = None,
        http2_keep_alive_while_idle: bool = False,
        pool_idle_timeout: Duration | None = ...,  # 90 seconds
        pool_max_idle_per_host: int | None = ...,  # usize::MAX
        tcp_keepalive: Duration | None = ...,  # 15 seconds
        tcp_keepalive_interval: Duration | None = ...,  # 15 seconds
        tcp_keepalive_retries: int | None = 3,
        tcp_nodelay: bool = True,
        identity: Identity | None = None,
        tls_certs_only: list[Certificate] | None = None,
        tls_certs_merge: list[Certificate] | None = None,
        tls_crls_only: list[CertificateRevocationList] | None = None,
        tls_version_min: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_version_max: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_info: bool = False,
        tls_sni: bool = True,
        tls_danger_accept_invalid_certs: bool = False,
        tls_danger_accept_invalid_hostnames: bool = False,
        proxy: _ProxyKw | None = None,
        _tls_cached_native_certs: bool = False,
    ) -&gt; None: ...
    def config(self) -&gt; ClientConfig: ...
    async def get(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; AsyncResponse: ...
    async def post(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; AsyncResponse: ...
    async def put(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; AsyncResponse: ...
    async def delete(
        self, url: URL | str, **kwargs: Unpack[RequestKwargs]
    ) -&gt; AsyncResponse: ...
    async def patch(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def options(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def head(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    def fetch_sync(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    async def __call__(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...


@t.final
class BlockingClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | Headers | None = None,
        cookies: bool = False,
        user_agent: str | bool | None = None,
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        redirect: int | None = 10,
        resolve: _ResolveMapLike | None = None,
        referer: bool = True,
        connection_verbose: bool = False,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
        zstd: bool = True,
        hickory_dns: bool = True,
        http1_only: bool = False,
        https_only: bool = False,
        http1_title_case_headers: bool = False,
        http1_allow_obsolete_multiline_headers_in_responses: bool = False,
        http1_allow_spaces_after_header_name_in_responses: bool = False,
        http1_ignore_invalid_headers_in_responses: bool = False,
        http2_prior_knowledge: bool = False,
        http2_initial_stream_window_size: int | None = None,
        http2_initial_connection_window_size: int | None = None,
        http2_adaptive_window: bool = False,
        http2_max_frame_size: int | None = None,
        http2_max_header_list_size: int | None = None,
        http2_keep_alive_interval: Duration | None = None,
        http2_keep_alive_timeout: Duration | None = None,
        http2_keep_alive_while_idle: bool = False,
        pool_idle_timeout: Duration | None = ...,  # 90 seconds
        pool_max_idle_per_host: int | None = ...,  # usize::MAX
        tcp_keepalive: Duration | None = ...,  # 15 seconds
        tcp_keepalive_interval: Duration | None = ...,  # 15 seconds
        tcp_keepalive_retries: int | None = 3,
        tcp_nodelay: bool = True,
        identity: Identity | None = None,
        tls_certs_only: list[Certificate] | None = None,
        tls_certs_merge: list[Certificate] | None = None,
        tls_crls_only: list[CertificateRevocationList] | None = None,
        tls_version_min: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_version_max: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_info: bool = False,
        tls_sni: bool = True,
        tls_danger_accept_invalid_certs: bool = False,
        tls_danger_accept_invalid_hostnames: bool = False,
        proxy: _ProxyKw | None = None,
        _tls_cached_native_certs: bool = False,
    ) -&gt; None: ...
    def config(self) -&gt; ClientConfig: ...
    def get(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def post(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def put(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def delete(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def patch(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def options(
        self, url: URL | str, **kwargs: Unpack[RequestKwargs]
    ) -&gt; BlockingResponse: ...
    def head(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def fetch(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def __call__(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...


@t.final
class ReqwestError(Exception):
    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None: ...
    def __dbg__(self) -&gt; str: ...
    def is_body(self) -&gt; bool: ...
    def is_builder(self) -&gt; bool: ...
    def is_connect(self) -&gt; bool: ...
    def is_decode(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_request(self) -&gt; bool: ...
    def is_status(self) -&gt; bool: ...
    def is_timeout(self) -&gt; bool: ...
    @property
    def status(self) -&gt; HttpStatus | None: ...
    def url(self) -&gt; URL | None: ...
    def without_url(self) -&gt; None: ...
    def with_url(self, url: URL) -&gt; ReqwestError: ...


@t.final
class Response:
    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def headers(self) -&gt; Headers: ...
    async def text(self, *, encoding: Encoding = "utf-8") -&gt; str: ...
    async def text_with_charset(self, encoding: Encoding) -&gt; str: ...
    async def json(
        self,
        *,
        allow_inf_nan: bool = False,
        cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
        partial_mode: t.Literal[
            True, False, "off", "on", "trailing-strings"
        ] = False,
        catch_duplicate_keys: bool = False,
    ) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(
        self, min_read_size: int = 0, /
    ) -&gt; ResponseStream: ...  # min_read_size=0 -&gt; None
    def stream(
        self, min_read_size: int = 0, /
    ) -&gt; ResponseStream: ...  # min_read_size=0 -&gt; None
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def redirected(self) -&gt; bool: ...
    @property
    def content_length(self) -&gt; int | None: ...
    @property
    def content_encoding(self) -&gt; str | None: ...
    @property
    def cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def set_cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def body_used(self) -&gt; bool:
        """True if the body has been consumed"""

    @property
    def ok(self) -&gt; bool:
        """True if the status is a success (2xx)"""

    @property
    def remote_addr(self) -&gt; SocketAddr | None: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    def __bool__(self) -&gt; bool:
        """True if the status is a success (2xx)"""


@t.final
class AsyncResponse:
    """'experimental-async' response type"""

    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def headers(self) -&gt; Headers: ...
    async def text(self, *, encoding: Encoding = "utf-8") -&gt; str: ...
    async def text_with_charset(self, encoding: Encoding) -&gt; str: ...
    async def json(
        self,
        *,
        allow_inf_nan: bool = False,
        cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
        partial_mode: t.Literal[
            True, False, "off", "on", "trailing-strings"
        ] = False,
        catch_duplicate_keys: bool = False,
    ) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(
        self, min_read_size: int = 0, /
    ) -&gt; _AsyncResponseStream: ...  # min_read_size=0 -&gt; None
    def stream(
        self, min_read_size: int = 0, /
    ) -&gt; _AsyncResponseStream: ...  # min_read_size=0 -&gt; None
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def redirected(self) -&gt; bool: ...
    @property
    def content_length(self) -&gt; int | None: ...
    @property
    def content_encoding(self) -&gt; str | None: ...
    @property
    def cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def set_cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def body_used(self) -&gt; bool:
        """True if the body has been consumed"""

    @property
    def ok(self) -&gt; bool:
        """True if the status is a success (2xx)"""

    @property
    def remote_addr(self) -&gt; SocketAddr | None: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    def __bool__(self) -&gt; bool:
        """True if the status is a success (2xx)"""


@t.final
class BlockingResponse:
    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def headers(self) -&gt; Headers: ...
    def text(self, *, encoding: Encoding = "utf-8") -&gt; str: ...
    def text_with_charset(self, encoding: Encoding) -&gt; str: ...
    def json(
        self,
        *,
        allow_inf_nan: bool = False,
        cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
        partial_mode: t.Literal[
            True, False, "off", "on", "trailing-strings"
        ] = False,
        catch_duplicate_keys: bool = False,
    ) -&gt; t.Any: ...
    def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(
        self, min_read_size: int = 0, /
    ) -&gt; BlockingResponseStream: ...
    def stream(self, min_read_size: int = 0, /) -&gt; BlockingResponseStream: ...
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def redirected(self) -&gt; bool: ...
    @property
    def content_length(self) -&gt; int | None: ...
    @property
    def content_encoding(self) -&gt; str | None: ...
    @property
    def cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def set_cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def body_used(self) -&gt; bool:
        """True if the body has been consumed"""

    @property
    def ok(self) -&gt; bool:
        """True if the status is a success (2xx)"""

    @property
    def remote_addr(self) -&gt; SocketAddr | None: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    def __bool__(self) -&gt; bool:
        """True if the status is a success (2xx)"""


@t.final
class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...
    async def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    @t.overload
    async def collect(self, join: t.Literal[True]) -&gt; ry.Bytes: ...
    @t.overload
    async def collect(
        self, join: t.Literal[False] = False
    ) -&gt; list[ry.Bytes]: ...


@t.final
class _AsyncResponseStream:
    def __aiter__(self) -&gt; _AsyncResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...
    async def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    async def collect(self) -&gt; list[ry.Bytes]: ...


@t.final
class BlockingResponseStream:
    def __iter__(self) -&gt; BlockingResponseStream: ...
    def __next__(self) -&gt; ry.Bytes: ...
    def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    @t.overload
    def collect(self, join: t.Literal[True]) -&gt; ry.Bytes: ...
    @t.overload
    def collect(self, join: t.Literal[False] = False) -&gt; list[ry.Bytes]: ...


async def fetch(
    url: URL | str,
    *,
    method: str = "GET",
    body: _Body | None = None,
    headers: Headers | dict[str, str] | None = None,
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None = None,
    json: t.Any = None,
    form: t.Any = None,
    multipart: t.Any | None = None,
    timeout: Duration | None = None,
    basic_auth: tuple[str, str | None] | None = None,
    bearer_auth: str | None = None,
    version: HttpVersionLike | None = None,
) -&gt; Response: ...
def fetch_sync(
    url: URL | str,
    *,
    method: str = "GET",
    body: _Body | None = None,
    headers: Headers | dict[str, str] | None = None,
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None = None,
    json: t.Any = None,
    form: t.Any = None,
    multipart: t.Any | None = None,
    timeout: Duration | None = None,
    basic_auth: tuple[str, str | None] | None = None,
    bearer_auth: str | None = None,
    version: HttpVersionLike | None = None,
) -&gt; BlockingResponse: ...


@t.final
class Cookie(FromStr, _Parse):
    def __init__(
        self,
        name: str,
        value: str,
        *,
        domain: str | None = None,
        expires: int | None = None,
        http_only: bool | None = None,
        max_age: Duration | None = None,
        partitioned: bool | None = None,
        path: str | None = None,
        permanent: bool = False,
        removal: bool = False,
        same_site: t.Literal["Lax", "Strict", "None"] | None = None,
        secure: bool | None = None,
    ) -&gt; None: ...
    @classmethod
    def from_str(cls, s: str) -&gt; Cookie: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; Cookie: ...
    @staticmethod
    def parse_encoded(s: str) -&gt; Cookie: ...

    # -------------------------------------------------------------------------
    # METHODS
    # -------------------------------------------------------------------------
    # -- STRING --
    def encoded(self) -&gt; str: ...
    def stripped(self) -&gt; str: ...
    def encoded_stripped(self) -&gt; str: ...
    def stripped_encoded(self) -&gt; str: ...

    # -------------------------------------------------------------------------
    # PROPERTIES
    # -------------------------------------------------------------------------
    @property
    def name(self) -&gt; str: ...
    @property
    def value(self) -&gt; str: ...
    @property
    def value_trimmed(self) -&gt; str: ...
    @property
    def name_value(self) -&gt; tuple[str, str]: ...
    @property
    def name_value_trimmed(self) -&gt; tuple[str, str]: ...
    @property
    def domain(self) -&gt; str | None: ...
    @property
    def expires(self) -&gt; int | None: ...
    @property
    def http_only(self) -&gt; bool | None: ...
    @property
    def max_age(self) -&gt; Duration | None: ...
    @property
    def partitioned(self) -&gt; bool | None: ...
    @property
    def path(self) -&gt; str | None: ...
    @property
    def same_site(self) -&gt; t.Literal["Lax", "Strict", "None"] | None: ...
    @property
    def secure(self) -&gt; bool | None: ...


@t.final
class Certificate:
    def __bytes__(self) -&gt; bytes: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    @classmethod
    def from_der(cls, der: Buffer) -&gt; t.Self: ...
    @classmethod
    def from_pem(cls, pem: Buffer) -&gt; t.Self: ...
    @classmethod
    def from_pem_bundle(cls, pem_bundle: Buffer) -&gt; list[t.Self]: ...


@t.final
class CertificateRevocationList:
    def __init__(self, pem: Buffer) -&gt; None: ...
    def __bytes__(self) -&gt; bytes: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    @classmethod
    def from_pem(cls, pem: Buffer) -&gt; t.Self: ...
    @classmethod
    def from_pem_bundle(cls, pem_bundle: Buffer) -&gt; list[t.Self]: ...


@t.final
class Identity:
    def __init__(self, pem: Buffer) -&gt; None: ...
    def __bytes__(self) -&gt; bytes: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    @classmethod
    def from_pem(cls, pem: Buffer) -&gt; t.Self: ...


class ProxyKwargs(t.TypedDict, total=False):
    basic_auth: tuple[str, str] | None
    no_proxy: str | None
    headers: Headers | dict[str, str] | None


@t.final
class Proxy:
    def __init__(
        self,
        url: URL | str,
        ptype: t.Literal["http", "https", "all"] = "http",
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; None: ...
    @staticmethod
    def all(
        url: URL | str,
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; Proxy: ...
    @staticmethod
    def http(
        url: URL | str,
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; Proxy: ...
    @staticmethod
    def https(
        url: URL | str,
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; Proxy: ...
    # -------------------------------------------------------------------------
    # BUILDERS
    # -------------------------------------------------------------------------
    def basic_auth(self, username: str, password: str) -&gt; Proxy: ...
    def no_proxy(self, url: str) -&gt; Proxy: ...
    def headers(self, headers: Headers | dict[str, str]) -&gt; Proxy: ...
    # -------------------------------------------------------------------------
    # DUNDERS
    # -------------------------------------------------------------------------
    def __eq__(self, other: object) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._same_file"><code>ry.ryo3._same_file</code></h2>

<pre><code class="language-python">"""ryo3-same-file types"""

from os import PathLike


def is_same_file(left: PathLike[str], right: PathLike[str]) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._shlex"><code>ry.ryo3._shlex</code></h2>

<pre><code class="language-python">"""ryo3-shlex types"""


def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""
</code></pre>
<h2 id="ry.ryo3._size"><code>ry.ryo3._size</code></h2>

<pre><code class="language-python">import builtins
import typing as t

from ry.protocols import FromStr, _Parse

FormatSizeBase: t.TypeAlias = t.Literal[2, 10]  # default=2
FormatSizeStyle: t.TypeAlias = t.Literal[  # default="default"
    "default",
    "abbreviated",
    "abbreviated_lowercase",
    "abbreviated-lowercase",
    "full",
    "full-lowercase",
    "full_lowercase",
]


def fmt_size(
    n: int,
    *,
    base: FormatSizeBase = 2,
    style: FormatSizeStyle = "default",
) -&gt; str:
    """Return human-readable string representation of bytes-size."""


def parse_size(s: str) -&gt; int:
    """Return integer representation of human-readable bytes-size string.

    Raises:
        ValueError: If string is not a valid human-readable bytes-size string.
    """


@t.final
class SizeFormatter:
    """Human-readable bytes-size formatter."""

    def __init__(
        self,
        base: FormatSizeBase = 2,
        style: FormatSizeStyle = "default",
    ) -&gt; None:
        """Initialize human-readable bytes-size formatter."""

    def format(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __call__(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""


@t.final
class Size(FromStr, _Parse):
    """Bytes-size object."""

    def __init__(self, size: int) -&gt; None: ...
    @property
    def bytes(self) -&gt; int: ...
    def format(
        self,
        *,
        base: FormatSizeBase = 2,
        style: FormatSizeStyle = "default",
    ) -&gt; str: ...

    # =========================================================================
    # CLASS-METHODS
    # =========================================================================

    # -------------------------------------------------------------------------
    # PARSING
    # -------------------------------------------------------------------------
    @classmethod
    def parse(cls, s: str | builtins.bytes) -&gt; Size: ...
    @classmethod
    def from_str(cls, s: str) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # BYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_bytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # KILOBYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_kb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kibibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kilobytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # MEGABYTES
    # -------------------------------------------------------------------------

    @classmethod
    def from_mb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_mebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_megabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_mib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # GIGABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_gb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gibibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gigabytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # TERABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_tb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_tebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_terabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_tib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # PETABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_pb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_pebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_petabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_pib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # EXABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_eb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_eib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_exabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_exbibytes(cls, size: float) -&gt; Size: ...

    # =========================================================================
    # DUNDERS
    # =========================================================================
    def __add__(self, other: Size | float) -&gt; Size: ...
    def __sub__(self, other: Size | float) -&gt; Size: ...
    def __mul__(self, other: Size | float) -&gt; Size: ...
    def __rmul__(self, other: Size | float) -&gt; Size: ...
    def __neg__(self) -&gt; Size: ...
    def __pos__(self) -&gt; Size: ...
    def __abs__(self) -&gt; Size: ...
    def __invert__(self) -&gt; Size: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Size | float) -&gt; bool: ...
    def __le__(self, other: Size | float) -&gt; bool: ...
    def __gt__(self, other: Size | float) -&gt; bool: ...
    def __ge__(self, other: Size | float) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __int__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></h2>

<pre><code class="language-python">"""ryo3-sqlformat types"""

import typing as t

Dialect: t.TypeAlias = t.Literal["generic", "postgresql", "sqlserver"]
Indent: t.TypeAlias = t.Literal["tabs", "\t"] | int
SqlfmtParamValue: t.TypeAlias = str | int | float | bool
_TSqlfmtParamValue_co = t.TypeVar(
    "_TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike: t.TypeAlias = (
    dict[str, _TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, _TSqlfmtParamValue_co]]
    | t.Sequence[_TSqlfmtParamValue_co]
)


@t.final
class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    ) -&gt; None: ...
    def __len__(self) -&gt; int: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int | t.Literal["tabs", "\t"] = 2,
    uppercase: bool | None = None,
    lines_between_queries: int = 1,
    ignore_case_convert: list[str] | None = None,
    inline: bool = False,
    max_inline_block: int = 50,
    max_inline_arguments: int | None = None,
    max_inline_top_level: int | None = None,
    joins_as_top_level: bool = False,
    dialect: t.Literal["generic", "postgresql", "sqlserver"] = "generic",
) -&gt; str: ...


class _SqlFormatterDict(t.TypedDict):
    indent: int | t.Literal["tabs"]
    uppercase: bool | None
    lines_between_queries: int
    ignore_case_convert: list[str] | None
    inline: bool
    max_inline_block: int
    max_inline_arguments: int | None
    max_inline_top_level: int | None
    joins_as_top_level: bool
    dialect: t.Literal["generic", "postgresql", "sqlserver"]


@t.final
class SqlFormatter:
    def __init__(
        self,
        *,
        indent: int | t.Literal["tabs", "\t"] = 2,
        uppercase: bool | None = None,
        lines_between_queries: int = 1,
        ignore_case_convert: list[str] | None = None,
        inline: bool = False,
        max_inline_block: int = 50,
        max_inline_arguments: int | None = None,
        max_inline_top_level: int | None = None,
        joins_as_top_level: bool = False,
        dialect: t.Literal["generic", "postgresql", "sqlserver"] = "generic",
    ) -&gt; None: ...
    def to_dict(self) -&gt; _SqlFormatterDict: ...
    def fmt(
        self,
        sql: str,
        params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
        | SqlfmtQueryParams
        | None = None,
    ) -&gt; str: ...
    def __call__(
        self,
        sql: str,
        params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
        | SqlfmtQueryParams
        | None = None,
    ) -&gt; str: ...
    def __eq__(self, value: object) -&gt; bool: ...
    def __ne__(self, value: object) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._std"><code>ry.ryo3._std</code></h2>

<pre><code class="language-python">"""ryo3-std types"""

import datetime as pydt
import ipaddress
import pathlib
import typing as t

from ry._types import (
    Buffer,
    DurationDict,
    FsPathLike,
    MetadataDict,
)
from ry.protocols import (
    FromStr,
    RyIterator,
    ToPy,
    ToPyTimeDelta,
    ToString,
    _Parse,
)
from ry.ryo3._bytes import Bytes


# =============================================================================
# STD::TIME
# =============================================================================
@t.final
class Duration(FromStr, ToPyTimeDelta, ToPy[pydt.timedelta], ToString, _Parse):
    ZERO: t.ClassVar[Duration]
    MIN: t.ClassVar[Duration]
    MAX: t.ClassVar[Duration]
    NANOSECOND: t.ClassVar[Duration]
    MICROSECOND: t.ClassVar[Duration]
    MILLISECOND: t.ClassVar[Duration]
    SECOND: t.ClassVar[Duration]

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __add__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __sub__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __radd__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __rsub__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...
    def __bool__(self) -&gt; bool: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    @t.overload
    def __truediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __truediv__(self, other: float) -&gt; t.Self: ...
    @t.overload
    def __rtruediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __rtruediv__(self, other: float) -&gt; t.Self: ...
    def __mul__(self, other: float) -&gt; t.Self: ...
    def __rmul__(self, other: float) -&gt; t.Self: ...
    def abs_diff(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def sleep(self, *, interval: int = 10) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...
    def to_dict(self) -&gt; DurationDict: ...
    @classmethod
    def from_dict(cls, d: DurationDict) -&gt; t.Self: ...

    # =========================================================================
    # TO/FROM STRING(s)
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...
    @classmethod
    def fromisoformat(cls, s: str) -&gt; t.Self: ...
    def friendly(
        self,
        designator: t.Literal[
            "compact", "human", "human-time", "short", "verbose"
        ] = "compact",
    ) -&gt; str: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int:
        """Alias for .nanos"""

    @property
    def ns(self) -&gt; int:
        """Alias for .nanos"""

    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def seconds_remainder(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; t.Self: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; t.Self: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; t.Self: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; t.Self: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; t.Self: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_days(cls, days: int) -&gt; t.Self: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; t.Self: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # ARITHMETIC
    # =========================================================================
    def checked_add(self, other: t.Self) -&gt; t.Self | None: ...
    def checked_div(self, other: int) -&gt; t.Self | None: ...
    def checked_mul(self, other: float) -&gt; t.Self | None: ...
    def checked_sub(self, other: t.Self) -&gt; t.Self | None: ...
    def div_duration_f32(self, other: t.Self) -&gt; float: ...
    def div_duration_f64(self, other: t.Self) -&gt; float: ...
    def div_f32(self, n: float) -&gt; t.Self: ...
    def div_f64(self, n: float) -&gt; t.Self: ...
    def mul_f32(self, n: float) -&gt; t.Self: ...
    def mul_f64(self, n: float) -&gt; t.Self: ...
    def saturating_add(self, other: t.Self) -&gt; t.Self: ...
    def saturating_mul(self, other: int) -&gt; t.Self: ...
    def saturating_sub(self, other: t.Self) -&gt; t.Self: ...


@t.final
class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: t.Self) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; t.Self | None: ...
    def checked_duration_since(self, earlier: t.Self) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; t.Self | None: ...
    def duration_since(self, earlier: t.Self) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: t.Self) -&gt; Duration: ...


def duration(secs: int = 0, nanos: int = 0) -&gt; Duration:
    """constructor alias for Duration"""


def instant() -&gt; Instant:
    """constructor alias for Instant"""


def sleep(secs: float) -&gt; float:
    """sleep for given seconds

    Args:
        secs: number of seconds to sleep

    Returns:
        number of seconds actually slept

    Raises:
        ValueError: if secs is negative
        OverflowError: if NaN or secs is too large to convert to a duration
    """


# =============================================================================
# STD::FS
# =============================================================================
FileTypeStr: t.TypeAlias = t.Literal[
    "file",
    "dir",
    "symlink",
    # unix
    "block-device",
    "char-device",
    "fifo",
    "socket",
    # windows
    "symlink-dir",
    "symlink-file",
    # unknown
    "unknown",
]


@t.final
class FileType(ToPy[FileTypeStr]):
    def __init__(
        self,
        t: t.Literal[
            "f",
            "file",
            "d",
            "dir",
            "directory",
            "l",
            "symlink",
            "link",
            "block-device",
            "char-device",
            "fifo",
            "socket",
            "symlink-dir",
            "symlink-file",
            "unknown",
        ],
    ) -&gt; None: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def is_block_device(self) -&gt; bool: ...
    @property
    def is_unknown(self) -&gt; bool: ...
    @property
    def is_char_device(self) -&gt; bool: ...
    @property
    def is_fifo(self) -&gt; bool: ...
    @property
    def is_socket(self) -&gt; bool: ...
    @property
    def is_symlink_dir(self) -&gt; bool: ...
    @property
    def is_symlink_file(self) -&gt; bool: ...
    def to_py(self) -&gt; FileTypeStr: ...


@t.final
class Permissions:
    @property
    def readonly(self) -&gt; bool: ...
    def __eq__(self, value: object) -&gt; bool: ...
    def __ne__(self, value: object) -&gt; bool: ...


@t.final
class Metadata:
    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def len(self) -&gt; int: ...
    @property
    def is_empty(self) -&gt; bool: ...
    @property
    def modified(self) -&gt; pydt.datetime: ...
    @property
    def accessed(self) -&gt; pydt.datetime: ...
    @property
    def created(self) -&gt; pydt.datetime: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def permissions(self) -&gt; Permissions: ...
    @property
    def readonly(self) -&gt; bool: ...
    def to_py(self) -&gt; MetadataDict: ...


@t.final
class DirEntry:
    def __init__(self) -&gt; t.NoReturn: ...
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def filename(self) -&gt; str: ...
    def metadata(self) -&gt; Metadata: ...
    def file_type(self) -&gt; FileType: ...


@t.final
class ReadDir(RyIterator[DirEntry]):
    def __init__(self) -&gt; t.NoReturn: ...
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; DirEntry: ...
    def collect(self) -&gt; list[DirEntry]: ...
    def take(self, n: int = 1) -&gt; list[DirEntry]: ...


@t.final
class FileReadStream(RyIterator[Bytes]):
    def __init__(
        self,
        path: FsPathLike,
        *,
        read_size: int = 65536,
        offset: int = 0,
        buffered: bool = True,
        strict: bool = True,
    ) -&gt; None:
        """Return a FileReadStream

        Args:
            path: path-like object
            read_size: number of bytes to read at a time. Defaults to 65536.
            offset: offset to start reading from. Defaults to 0.
            buffered: whether the stream is buffered. Defaults to True.
            strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

        Raises:
            FileNotFoundError: If file does not exist.
            IsADirectoryError: If path is a directory.
            ValueError: If offset is beyond EOF and strict is True.

        """

    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; Bytes: ...
    def collect(self) -&gt; list[Bytes]: ...
    def take(self, n: int = 1) -&gt; list[Bytes]: ...


# ============================================================================
# STD::FS ~ functions
# =============================================================================
_TPath = t.TypeVar("_TPath", bound=FsPathLike)


def canonicalize(path: _TPath) -&gt; _TPath: ...
def copy(from_path: FsPathLike, to_path: FsPathLike) -&gt; int: ...
def create_dir(path: FsPathLike) -&gt; None: ...
def create_dir_all(path: FsPathLike) -&gt; None: ...
def exists(path: FsPathLike) -&gt; bool: ...
def hard_link(original: FsPathLike, link: FsPathLike) -&gt; None: ...
def is_dir(path: FsPathLike) -&gt; bool: ...
def is_file(path: FsPathLike) -&gt; bool: ...
def is_symlink(path: FsPathLike) -&gt; bool: ...
def metadata(path: FsPathLike) -&gt; Metadata: ...
def read(path: FsPathLike) -&gt; Bytes: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def read_dir(path: FsPathLike) -&gt; ReadDir: ...
def read_link(path: FsPathLike) -&gt; pathlib.Path: ...
def read_stream(
    path: FsPathLike,
    read_size: int = 65536,
    *,
    offset: int = 0,
    buffered: bool = True,
    strict: bool = True,
) -&gt; FileReadStream:
    """Return a FileReadStream

    Args:
        path: path-like object
        read_size: number of bytes to read at a time. Defaults to 65536.
        offset: offset to start reading from. Defaults to 0.
        buffered: whether the stream is buffered. Defaults to True.
        strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

    Raises:
        FileNotFoundError: If file does not exist.
        IsADirectoryError: If path is a directory.
        ValueError: If offset is beyond EOF and strict is True.

    """


def read_text(path: FsPathLike) -&gt; str: ...
def read_str(path: FsPathLike) -&gt; str: ...
def read_to_string(path: FsPathLike) -&gt; str: ...
def remove_dir(path: FsPathLike) -&gt; None: ...
def remove_dir_all(path: FsPathLike) -&gt; None: ...
def remove_file(path: FsPathLike) -&gt; None: ...
def rename(from_path: FsPathLike, to_path: FsPathLike) -&gt; None: ...
def set_permissions(path: FsPathLike, perm: Permissions) -&gt; None: ...
def soft_link(original: FsPathLike, link: FsPathLike) -&gt; None: ...
def symlink_metadata(path: FsPathLike) -&gt; Metadata: ...
def write(path: FsPathLike, data: Buffer | str) -&gt; int: ...
def write_bytes(path: FsPathLike, buf: bytes) -&gt; int: ...
def write_text(path: FsPathLike, s: str) -&gt; int: ...


# =============================================================================
# STD::NET
# =============================================================================


class _Version4(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[4]: ...


class _Version6(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[6]: ...


class _Version(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[4, 6]: ...


class _Ipv4AddrProperties(t.Protocol):
    @property
    def is_benchmarking(self) -&gt; bool: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_link_local(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_reserved(self) -&gt; bool: ...
    @property
    def is_shared(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...
    @property
    def is_unicast(self) -&gt; bool: ...


_T_ipaddress_co = t.TypeVar(
    "_T_ipaddress_co",
    bound=ipaddress.IPv4Address | ipaddress.IPv6Address,
    covariant=True,
)


class ToPyIpAddress(t.Protocol[_T_ipaddress_co]):
    def to_pyipaddress(self) -&gt; _T_ipaddress_co: ...


@t.final
class Ipv4Addr(
    _Ipv4AddrProperties,
    _Version4,
    FromStr,
    _Parse,
    ToPy[ipaddress.IPv4Address],
    ToPyIpAddress[ipaddress.IPv4Address],
    ToString,
):
    BROADCAST: Ipv4Addr
    LOCALHOST: Ipv4Addr
    UNSPECIFIED: Ipv4Addr

    @t.overload
    def __init__(self, a: int, b: int, c: int, d: int) -&gt; None: ...
    @t.overload
    def __init__(
        self, iplike: int | str | bytes | Ipv4Addr | ipaddress.IPv4Address
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __le__(self, other: Ipv4Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv4Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv4Address: ...
    def to_string(self) -&gt; str: ...
    @property
    def version(self) -&gt; t.Literal[4]: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[True]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[False]: ...
    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; Ipv4Addr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; Ipv4Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; Ipv4Addr: ...
    @classmethod
    def from_octets(cls, a: int, b: int, c: int, d: int) -&gt; Ipv4Addr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddrv4(self, port: int) -&gt; SocketAddrV4: ...
    def to_socketaddrv6(
        self, port: int, flowinfo: int = 0, scope_id: int = 0
    ) -&gt; SocketAddrV6: ...


class _Ipv6AddrProperties(t.Protocol):
    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def is_benchmarking(self) -&gt; bool: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4_mapped(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_reserved(self) -&gt; bool: ...
    @property
    def is_shared(self) -&gt; bool: ...
    @property
    def is_unicast(self) -&gt; bool: ...
    @property
    def is_unicast_global(self) -&gt; t.NoReturn: ...
    @property
    def is_unicast_link_local(self) -&gt; bool: ...
    @property
    def is_unique_local(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...


@t.final
class Ipv6Addr(
    _Ipv6AddrProperties,
    _Version6,
    FromStr,
    _Parse,
    ToPy[ipaddress.IPv6Address],
    ToPyIpAddress[ipaddress.IPv6Address],
    ToString,
):
    LOCALHOST: Ipv6Addr
    UNSPECIFIED: Ipv6Addr

    @t.overload
    def __init__(
        self, a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int
    ) -&gt; None: ...
    @t.overload
    def __init__(
        self, iplike: int | str | bytes | Ipv6Addr | ipaddress.IPv6Address
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __le__(self, other: Ipv6Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv6Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv6Address: ...
    def to_string(self) -&gt; str: ...
    @property
    def version(self) -&gt; t.Literal[6]: ...
    @property
    def is_documentation(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[False]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[True]: ...
    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; Ipv6Addr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; Ipv6Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; IpAddr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddrv4(self, port: int) -&gt; SocketAddrV4: ...
    def to_socketaddrv6(
        self, port: int, flowinfo: int = 0, scope_id: int = 0
    ) -&gt; SocketAddrV6: ...


@t.final
class IpAddr(
    _Ipv4AddrProperties,
    _Ipv6AddrProperties,
    _Version,
    FromStr,
    _Parse,
    ToPy[ipaddress.IPv4Address | ipaddress.IPv6Address],
    ToPyIpAddress[ipaddress.IPv4Address | ipaddress.IPv6Address],
    ToString,
):
    BROADCAST: IpAddr
    LOCALHOST_V4: IpAddr
    UNSPECIFIED_V4: IpAddr
    LOCALHOST_V6: IpAddr
    UNSPECIFIED_V6: IpAddr

    def __init__(
        self,
        iplike: int
        | str
        | bytes
        | Ipv4Addr
        | Ipv6Addr
        | ipaddress.IPv4Address
        | ipaddress.IPv6Address,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: IpAddr) -&gt; bool: ...
    def __le__(self, other: IpAddr) -&gt; bool: ...
    def __gt__(self, other: IpAddr) -&gt; bool: ...
    def __ge__(self, other: IpAddr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_string(self) -&gt; str: ...
    def to_py(self) -&gt; ipaddress.IPv4Address | ipaddress.IPv6Address: ...
    def to_ipv4(self) -&gt; Ipv4Addr: ...
    def to_ipv6(self) -&gt; Ipv6Addr: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; IpAddr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; IpAddr: ...

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def version(self) -&gt; t.Literal[4, 6]: ...
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; bool: ...
    @property
    def is_ipv6(self) -&gt; bool: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_canonical(self) -&gt; IpAddr: ...


@t.final
class SocketAddrV4(
    _Ipv4AddrProperties,
    _Version4,
    # protocols
    FromStr,
    ToPyIpAddress[ipaddress.IPv4Address],
    ToString,
    _Parse,
):
    def __init__(
        self,
        ip: IpAddr | Ipv4Addr | ipaddress.IPv4Address | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddrV4) -&gt; bool: ...
    def __le__(self, other: SocketAddrV4) -&gt; bool: ...
    def __gt__(self, other: SocketAddrV4) -&gt; bool: ...
    def __ge__(self, other: SocketAddrV4) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_ipv4(self) -&gt; Ipv4Addr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddr(self) -&gt; SocketAddr: ...
    def to_string(self) -&gt; str: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @property
    def port(self) -&gt; int: ...
    @property
    def ip(self) -&gt; Ipv4Addr: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[True]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[False]: ...


@t.final
class SocketAddrV6(
    _Ipv6AddrProperties,
    _Version6,
    # protocols
    FromStr,
    ToPyIpAddress[ipaddress.IPv6Address],
    ToString,
    _Parse,
):
    def __init__(
        self,
        ip: IpAddr | Ipv6Addr | ipaddress.IPv4Address | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddrV6) -&gt; bool: ...
    def __le__(self, other: SocketAddrV6) -&gt; bool: ...
    def __gt__(self, other: SocketAddrV6) -&gt; bool: ...
    def __ge__(self, other: SocketAddrV6) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_string(self) -&gt; str: ...
    def to_ipv6(self) -&gt; Ipv6Addr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddr(self) -&gt; SocketAddr: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @property
    def port(self) -&gt; int: ...
    @property
    def ip(self) -&gt; Ipv6Addr: ...
    @property
    def is_documentation(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[True]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[False]: ...


@t.final
class SocketAddr(
    _Ipv4AddrProperties,
    _Ipv6AddrProperties,
    _Version,
    # protocols
    FromStr,
    _Parse,
    ToString,
    ToPyIpAddress[ipaddress.IPv4Address | ipaddress.IPv6Address],
):
    def __init__(
        self,
        ip: IpAddr
        | Ipv4Addr
        | Ipv6Addr
        | ipaddress.IPv4Address
        | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddr) -&gt; bool: ...
    def __le__(self, other: SocketAddr) -&gt; bool: ...
    def __gt__(self, other: SocketAddr) -&gt; bool: ...
    def __ge__(self, other: SocketAddr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    @classmethod
    def from_str(cls, s: str) -&gt; SocketAddr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; SocketAddr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_string(self) -&gt; str: ...
    def to_socketaddrv4(self) -&gt; SocketAddrV4:
        """Return SocketAddrV4 representation

        Raises:
            ValueError: if the internal SocketAddr v6
        """

    def to_socketaddrv6(self) -&gt; SocketAddrV6:
        """Return SocketAddrV6 representation

        Raises:
            ValueError: if the internal SocketAddr v4
        """

    @property
    def is_ipv4(self) -&gt; bool: ...
    @property
    def is_ipv6(self) -&gt; bool: ...
    @property
    def ip(self) -&gt; IpAddr: ...
    @property
    def port(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._std_constants"><code>ry.ryo3._std_constants</code></h2>

<pre><code class="language-python">from typing import Literal

# ruff: noqa: PYI054
# u8
U8_BITS: Literal[8]
U8_MAX: Literal[255]
U8_MIN: Literal[0]
# i8
I8_BITS: Literal[8]
I8_MAX: Literal[127]
I8_MIN: Literal[-128]
# i16
I16_BITS: Literal[16]
I16_MAX: Literal[32_767]
I16_MIN: Literal[-32_768]
# u16
U16_BITS: Literal[16]
U16_MAX: Literal[65_535]
U16_MIN: Literal[0]

# u32
U32_BITS: Literal[32]
U32_MAX: Literal[4_294_967_295]
U32_MIN: Literal[0]

# i32
I32_BITS: Literal[32]
I32_MAX: Literal[2_147_483_647]
I32_MIN: Literal[-2_147_483_648]

# u64
U64_BITS: Literal[64]
U64_MAX: Literal[18_446_744_073_709_551_615]
U64_MIN: Literal[0]

# i64
I64_BITS: Literal[64]
I64_MAX: Literal[9_223_372_036_854_775_807]
I64_MIN: Literal[-9_223_372_036_854_775_808]

# u128
U128_BITS: Literal[128]
U128_MAX: Literal[340_282_366_920_938_463_463_374_607_431_768_211_455]
U128_MIN: Literal[0]

# i128
I128_BITS: Literal[128]
I128_MAX: Literal[170_141_183_460_469_231_731_687_303_715_884_105_727]
I128_MIN: Literal[-170_141_183_460_469_231_731_687_303_715_884_105_728]

# usize
USIZE_BITS: Literal[32, 64]
USIZE_MAX: Literal[4_294_967_295, 18_446_744_073_709_551_615]
USIZE_MIN: Literal[0]
# isize
ISIZE_BITS: Literal[32, 64]
ISIZE_MAX: Literal[2_147_483_647, 9_223_372_036_854_775_807]
ISIZE_MIN: Literal[-2_147_483_648, -9_223_372_036_854_775_808]
</code></pre>
<h2 id="ry.ryo3._tokio"><code>ry.ryo3._tokio</code></h2>

<pre><code class="language-python">"""ryo4-tokio types"""

import pathlib
import sys
import typing as t
from collections.abc import Generator
from types import TracebackType

from ry import Bytes
from ry._types import Buffer, FsPathLike, OpenBinaryMode
from ry.protocols import RyAsyncIterator
from ry.ryo3._std import FileType, Metadata

if sys.version_info &gt;= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated


# =============================================================================
# FS
# =============================================================================
async def canonicalize_async(path: FsPathLike) -&gt; FsPathLike: ...
async def copy_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def create_dir_async(path: FsPathLike) -&gt; None: ...
async def create_dir_all_async(path: FsPathLike) -&gt; None: ...
async def hard_link_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def metadata_async(path: FsPathLike) -&gt; None: ...
async def read_async(path: FsPathLike) -&gt; Bytes: ...
async def remove_dir_async(path: FsPathLike) -&gt; None: ...
async def remove_dir_all_async(path: FsPathLike) -&gt; None: ...
async def remove_file_async(path: FsPathLike) -&gt; None: ...
async def read_link_async(path: FsPathLike) -&gt; FsPathLike: ...
async def read_to_string_async(path: FsPathLike) -&gt; str: ...
async def rename_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def write_async(path: FsPathLike, buf: Buffer) -&gt; None: ...
async def try_exists_async(path: FsPathLike) -&gt; bool: ...
async def exists_async(path: FsPathLike) -&gt; bool: ...


@t.final
class AsyncDirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def filename(self) -&gt; str: ...
    async def metadata(self) -&gt; Metadata: ...
    async def file_type(self) -&gt; FileType: ...


@t.final
class AsyncReadDir:
    """Async iterator for read_dir_async"""

    async def collect(self) -&gt; list[AsyncDirEntry]: ...
    async def take(self, n: int) -&gt; list[AsyncDirEntry]: ...
    def __aiter__(self) -&gt; AsyncReadDir: ...
    async def __anext__(self) -&gt; AsyncDirEntry: ...


async def read_dir_async(path: FsPathLike) -&gt; AsyncReadDir: ...


# =============================================================================
# SLEEP
# =============================================================================
async def sleep_async(secs: float) -&gt; float: ...
async def asleep(secs: float) -&gt; float:
    """Alias for sleep_async"""


# =============================================================================
# ASYNC-FILE
# =============================================================================
@t.final
class AsyncFile:
    def __init__(
        self, path: FsPathLike, mode: OpenBinaryMode = "rb", buffering: int = -1
    ) -&gt; None: ...
    async def close(self) -&gt; None: ...
    async def flush(self) -&gt; None: ...
    async def isatty(self) -&gt; t.NoReturn: ...
    async def open(self) -&gt; None: ...
    async def peek(self, size: int = ..., /) -&gt; Bytes: ...
    async def read(self, size: int | None = None, /) -&gt; Bytes: ...
    async def readable(self) -&gt; bool: ...
    async def readall(self) -&gt; Bytes: ...
    async def readline(self, size: int | None = None, /) -&gt; Bytes: ...
    async def readlines(self, hint: int | None = None, /) -&gt; list[Bytes]: ...
    async def seek(self, offset: int, whence: int = ..., /) -&gt; int: ...
    async def seekable(self) -&gt; bool: ...
    async def tell(self) -&gt; int: ...
    async def truncate(self, pos: int | None = None, /) -&gt; int: ...
    async def writable(self) -&gt; bool: ...
    async def write(self, b: Buffer, /) -&gt; int: ...
    @property
    def closed(self) -&gt; bool: ...
    def __await__(self) -&gt; Generator[t.Any, t.Any, t.Self]: ...
    def __aiter__(self) -&gt; t.Self: ...
    async def __anext__(self) -&gt; Bytes: ...
    async def __aenter__(self) -&gt; t.Self: ...
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -&gt; None: ...


def aopen(
    path: FsPathLike, mode: OpenBinaryMode | str = "rb", buffering: int = -1
) -&gt; AsyncFile: ...
@deprecated("`aiopen` is deprecated, use `aopen` instead")
def aiopen(
    path: FsPathLike, mode: OpenBinaryMode | str = "rb", buffering: int = -1
) -&gt; AsyncFile: ...


@t.final
class AsyncFileReadStream(RyAsyncIterator[Bytes]):
    def __init__(
        self,
        path: FsPathLike,
        *,
        read_size: int = 65536,
        offset: int = 0,
        buffered: bool = True,
        strict: bool = True,
    ) -&gt; None:
        """Return an AsyncFileReadStream

        Args:
            path: path-like object
            read_size: number of bytes to read at a time. Defaults to 65536.
            offset: offset to start reading from. Defaults to 0.
            buffered: whether the stream is buffered. Defaults to True.
            strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

        Raises:
            FileNotFoundError: If file does not exist.
            IsADirectoryError: If path is a directory.
            ValueError: If offset is beyond EOF and strict is True.

        """

    def __await__(self) -&gt; Generator[t.Any, t.Any, t.Self]: ...
    def __aiter__(self) -&gt; t.Self: ...
    async def __anext__(self) -&gt; Bytes: ...
    async def collect(self) -&gt; list[Bytes]: ...
    async def take(self, n: int = 1) -&gt; list[Bytes]: ...


def read_stream_async(
    path: FsPathLike,
    read_size: int = 65536,
    *,
    offset: int = 0,
    buffered: bool = True,
    strict: bool = True,
) -&gt; AsyncFileReadStream:
    """Return a FileReadStream

    Args:
        path: path-like object
        read_size: number of bytes to read at a time. Defaults to 65536.
        offset: offset to start reading from. Defaults to 0.
        buffered: whether the stream is buffered. Defaults to True.
        strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

    Raises:
        FileNotFoundError: If file does not exist.
        IsADirectoryError: If path is a directory.
        ValueError: If offset is beyond EOF and strict is True.

    """
</code></pre>
<h2 id="ry.ryo3._unindent"><code>ry.ryo3._unindent</code></h2>

<pre><code class="language-python">"""ryo3-unindent types"""


def unindent(s: str, /) -&gt; str: ...
def unindent_bytes(b: bytes, /) -&gt; bytes: ...
</code></pre>
<h2 id="ry.ryo3._url"><code>ry.ryo3._url</code></h2>

<pre><code class="language-python">import sys
import typing as t
from ipaddress import IPv4Address, IPv6Address

from ry._types import FsPathLike
from ry.protocols import FromStr, ToString, _Parse
from ry.ryo3._std import IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr

if sys.version_info &gt;= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated


@t.final
class URL(FromStr, ToString, _Parse):
    def __init__(
        self, url: str | bytes | URL, *, params: dict[str, str] | None = None
    ) -&gt; None: ...
    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse_with_params(
        cls, url: str | bytes, params: dict[str, str]
    ) -&gt; t.Self: ...
    @classmethod
    def from_directory_path(cls, path: FsPathLike) -&gt; t.Self: ...
    @classmethod
    def from_filepath(cls, path: FsPathLike) -&gt; t.Self: ...
    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def __fspath__(self) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def domain(self) -&gt; str | None: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | Ipv4Addr | Ipv6Addr | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None:
        """
        Return the port number for this URL, if any.

        Note: the default port numbers are never reflected by the serialization,
        use the `port_or_known_default` if you want a default port number returned.

        Default port numbers:
            - `http`  | `ws`  =&gt; `80`
            - `https` | `wss` =&gt; `443`
            - `ftp`           =&gt; `21`

        Examples:

            &gt;&gt;&gt; from ry import URL
            &gt;&gt;&gt; assert URL("https://rotatingsandwiches.com:3000").port == 3000
            &gt;&gt;&gt; assert URL("https://rotatingsandwiches.com").port is None
            &gt;&gt;&gt; assert URL("https://rotatingsandwiches.com:443/").port is None
            &gt;&gt;&gt; assert URL("ssh://rotatingsandwiches.com:22").port == 22

        """

    @property
    def port_or_known_default(self) -&gt; int | None:
        """Return the port number, or the default port number if known.

        Default port numbers:
            - `http`  | `ws`  =&gt; `80`
            - `https` | `wss` =&gt; `443`
            - `ftp`           =&gt; `21`

        Examples:

            &gt;&gt;&gt; from ry import URL
            &gt;&gt;&gt; URL("https://rotatingsandwiches.com:3000").port_or_known_default
            3000
            &gt;&gt;&gt; URL("https://rotatingsandwiches.com").port_or_known_default
            443
            &gt;&gt;&gt; URL("https://rotatingsandwiches.com:443/").port_or_known_default
            443
            &gt;&gt;&gt; URL("ssh://rotatingsandwiches.com:22").port_or_known_default
            22

        """

    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_string(self) -&gt; str: ...
    @property
    def query_pairs(self) -&gt; tuple[tuple[str, str], ...]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def user(self) -&gt; str:
        """alias for yarl compatibility"""

    @property
    def username(self) -&gt; str: ...
    @property
    def origin(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def equiv(self, other: URL | str) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def make_relative(self, other: URL) -&gt; t.Self: ...
    def socket_addrs(
        self, default_port_number: int | None = None
    ) -&gt; list[SocketAddr]: ...
    def to_filepath(self) -&gt; str: ...
    def replace(
        self,
        *,
        fragment: str | None = None,
        host: str | None = None,
        ip_host: IPv4Address
        | IPv6Address
        | Ipv4Addr
        | Ipv6Addr
        | IpAddr
        | None = None,
        password: str | None = None,
        path: str | None = None,
        port: int | None = None,
        query: str | None = None,
        scheme: str | None = None,
        username: str | None = None,
    ) -&gt; t.Self: ...
    def with_fragment(self, fragment: str | None = None) -&gt; t.Self: ...
    def with_host(self, host: str | None = None) -&gt; t.Self: ...
    def with_ip_host(
        self, address: IPv4Address | IPv6Address | Ipv4Addr | Ipv6Addr | IpAddr
    ) -&gt; t.Self: ...
    def with_password(self, password: str | None = None) -&gt; t.Self: ...
    def with_path(self, path: str) -&gt; t.Self: ...
    def with_port(self, port: int | None = None) -&gt; t.Self: ...
    def with_query(self, query: str | None = None) -&gt; t.Self: ...
    def with_scheme(self, scheme: str) -&gt; t.Self: ...
    def with_username(self, username: str) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __truediv__(self, relative: str) -&gt; t.Self: ...
    def __rtruediv__(self, relative: str) -&gt; t.Self: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # DEPRECATED
    # =========================================================================
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_fragment(self, fragment: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_host(self, host: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_ip_host(
        self, address: IPv4Address | IPv6Address | Ipv4Addr | Ipv6Addr | IpAddr
    ) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_password(self, password: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_path(self, path: str) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_port(self, port: int | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_query(self, query: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_scheme(self, scheme: str) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_username(self, username: str) -&gt; t.Self: ...
</code></pre>
<h2 id="ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></h2>

<pre><code class="language-python">"""ryo3-walkdir types"""

import typing as t
from os import PathLike

from ry import FileType, FsPath, Glob, GlobSet, Globster
from ry.protocols import RyIterator


@t.final
class WalkDirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; FsPath: ...
    @property
    def file_name(self) -&gt; str: ...
    @property
    def depth(self) -&gt; int: ...
    @property
    def path_is_symlink(self) -&gt; bool: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def len(self) -&gt; int: ...


_T_walkdir = t.TypeVar(
    "_T_walkdir",
    bound=WalkDirEntry | str,
)


@t.final
class WalkdirGen(RyIterator[_T_walkdir]):
    """walkdir::Walkdir iterable wrapper"""

    def __init__(self) -&gt; t.NoReturn: ...
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; _T_walkdir: ...
    def collect(self) -&gt; list[_T_walkdir]: ...
    def take(self, n: int = 1) -&gt; list[_T_walkdir]: ...


@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    /,
    *,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    follow_root_links: bool = True,
    same_file_system: bool = False,
    sort_by_file_name: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
    objects: t.Literal[True],
) -&gt; WalkdirGen[WalkDirEntry]: ...
@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    /,
    *,
    objects: t.Literal[False] = False,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    follow_root_links: bool = True,
    same_file_system: bool = False,
    sort_by_file_name: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
) -&gt; WalkdirGen[str]: ...
</code></pre>
<h2 id="ry.ryo3._which"><code>ry.ryo3._which</code></h2>

<pre><code class="language-python">"""ryo3-which types"""

from pathlib import Path

from ry.ryo3._regex import Regex


def which(cmd: str, path: None | str = None) -&gt; Path | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[Path]: ...
def which_re(regex: str | Regex, path: None | str = None) -&gt; list[Path]: ...
</code></pre>
<h2 id="ry.ryo3._zstd"><code>ry.ryo3._zstd</code></h2>

<pre><code class="language-python">"""ry.ryo3 root level zstd exports"""

from ry.ryo3.zstd import compress as zstd_compress
from ry.ryo3.zstd import decode as zstd_decode
from ry.ryo3.zstd import decompress as zstd_decompress
from ry.ryo3.zstd import encode as zstd_encode
from ry.ryo3.zstd import is_zstd as is_zstd

__all__ = (
    "is_zstd",
    "zstd_compress",
    "zstd_decode",
    "zstd_decompress",
    "zstd_encode",
)
</code></pre>
<h2 id="ry.ryo3.dirs"><code>ry.ryo3.dirs</code></h2>

<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...
</code></pre>
<h2 id="ry.ryo3.errors"><code>ry.ryo3.errors</code></h2>

<pre><code class="language-python">class FeatureNotEnabledError(RuntimeError):
    """Raised when a feature is not enabled in the current build."""
</code></pre>
<h2 id="ry.ryo3.JSON"><code>ry.ryo3.JSON</code></h2>

<pre><code class="language-python">"""ry.ryo3.JSON"""

import typing as t

from ry._types import Buffer, Unpack
from ry.ryo3._bytes import Bytes
from ry.ryo3._jiter import JsonParseKwargs, JsonValue


def minify(buf: Buffer | str, /) -&gt; Bytes:
    """Return minified json data (remove whitespace, newlines)

    Args:
        data: The JSON data to minify.

    Returns:
        Minified JSON data as a `Bytes` object.

    Examples:
        &gt;&gt;&gt; import json as pyjson
        &gt;&gt;&gt; from ry.ryo3 import JSON
        &gt;&gt;&gt; data = {"key": "value", "number": 123, "bool": True}
        &gt;&gt;&gt; json_str = pyjson.dumps(data, indent=2)
        &gt;&gt;&gt; print(json_str)
        {
          "key": "value",
          "number": 123,
          "bool": true
        }
        &gt;&gt;&gt; bytes(JSON.minify(json_str))
        b'{"key":"value","number":123,"bool":true}'

    """


def fmt(buf: Buffer | str, /) -&gt; Bytes:
    """Return minified json data (remove whitespace, newlines)

    Args:
        data: The JSON data to minify.

    Returns:
        Minified JSON data as a `Bytes` object.

    Examples:
        &gt;&gt;&gt; import json as pyjson
        &gt;&gt;&gt; from ry.ryo3 import JSON
        &gt;&gt;&gt; data = {"key": "value", "number": 123, "bool": True}
        &gt;&gt;&gt; json_str = pyjson.dumps(data, indent=2)
        &gt;&gt;&gt; print(json_str)
        {
          "key": "value",
          "number": 123,
          "bool": true
        }
        &gt;&gt;&gt; bytes(JSON.fmt(json_str)).decode()
        '{\n  "key": "value",\n  "number": 123,\n  "bool": true\n}'
        &gt;&gt;&gt; print(bytes(JSON.fmt(json_str)).decode())
        {
          "key": "value",
          "number": 123,
          "bool": true
        }

    """


@t.overload
def stringify(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[True],
) -&gt; bytes: ...
@t.overload
def stringify(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[False] = False,
) -&gt; Bytes: ...
@t.overload
def dumps(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[True],
) -&gt; bytes: ...
@t.overload
def dumps(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[False] = False,
) -&gt; Bytes: ...
def loads(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def cache_clear() -&gt; None: ...
def cache_usage() -&gt; int: ...


# under construction
def stringify_unsafe(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: bool = False,
) -&gt; t.NoReturn: ...
</code></pre>
<h2 id="ry.ryo3.orjson"><code>ry.ryo3.orjson</code></h2>

<pre><code class="language-python">"""orjson + ry types

orjson-types: https://github.com/ijl/orjson/blob/master/pysrc/orjson/__init__.pyi
"""

import typing as t

import orjson


def orjson_default(obj: t.Any) -&gt; orjson.Fragment:
    """Fn to be used with `orjson.dumps` to serialize ry-compatible types

    Example:
        &gt;&gt;&gt; import orjson
        &gt;&gt;&gt; from ry import orjson_default, Date
        &gt;&gt;&gt; data = {"key": "value", "date": Date(2023, 10, 1)}
        &gt;&gt;&gt; orjson.dumps(data, default=orjson_default)
        b'{"key":"value","date":"2023-10-01"}'

    """
</code></pre>
<h2 id="ry.ryo3.sh"><code>ry.ryo3.sh</code></h2>

<pre><code class="language-python">import typing as t
from os import PathLike

from ry.ryo3._fspath import FsPath


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: str | PathLike[str]) -&gt; None: ...
@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[False] = False,
) -&gt; list[str]:
    """List directory contents - returns list of strings"""


@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[True],
) -&gt; list[FsPath]:
    """List directory contents - returns list of FsPath objects"""


def mkdir(
    path: str | PathLike[str],
    *,
    exist_ok: bool = False,
    recursive: bool = False,
) -&gt; None: ...
def mkdirp(path: str | PathLike[str]) -&gt; None: ...
</code></pre>
<h2 id="ry.ryo3.ulid"><code>ry.ryo3.ulid</code></h2>

<pre><code class="language-python">import builtins
import datetime as pydt
import typing as t
import uuid
from collections.abc import Callable as Callable

from pydantic import GetCoreSchemaHandler as GetCoreSchemaHandler
from pydantic import (
    ValidatorFunctionWrapHandler as ValidatorFunctionWrapHandler,
)
from pydantic_core import CoreSchema as CoreSchema

from ry.protocols import FromStr


@t.final
class ULID(FromStr):
    def __init__(self, value: builtins.bytes | str | None = None) -&gt; None: ...

    # ----------------
    # INSTANCE METHODS
    # ----------------
    def to_bytes(self) -&gt; builtins.bytes: ...
    def to_uuid(self) -&gt; uuid.UUID: ...
    def to_uuid4(self) -&gt; uuid.UUID: ...

    # ----------
    # PROPERTIES
    # ----------
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def timestamp(self) -&gt; float: ...
    @property
    def datetime(self) -&gt; pydt.datetime: ...
    @property
    def hex(self) -&gt; str: ...

    # -------------
    # CLASS METHODS
    # -------------
    @classmethod
    def from_datetime(cls, value: pydt.datetime) -&gt; ULID: ...
    @classmethod
    def from_timestamp(cls, value: float) -&gt; ULID: ...
    @classmethod
    def from_timestamp_seconds(cls, value: float) -&gt; ULID: ...
    @classmethod
    def from_timestamp_milliseconds(cls, value: int) -&gt; ULID: ...
    @classmethod
    def from_uuid(cls, uu: uuid.UUID) -&gt; ULID: ...
    @classmethod
    def from_bytes(cls, b: builtins.bytes) -&gt; ULID: ...
    @classmethod
    def from_hex(cls, hexstr: str) -&gt; ULID: ...
    @classmethod
    def from_str(cls, s: str) -&gt; ULID: ...
    @classmethod
    def from_string(cls, s: str) -&gt; ULID:
        """Alias for `from_str` to match python-ulid lib"""

    @classmethod
    def from_int(cls, i: int) -&gt; ULID: ...
    @classmethod
    def parse(cls, value: t.Any) -&gt; ULID: ...

    # -------
    # DUNDERS
    # -------
    def __int__(self) -&gt; int: ...
    def __bytes__(self) -&gt; builtins.bytes: ...
    def __lt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __le__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __ge__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # --------
    # PYDANTIC
    # --------
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source: t.Any, handler: GetCoreSchemaHandler
    ) -&gt; CoreSchema: ...
</code></pre>
<h2 id="ry.ryo3.uuid"><code>ry.ryo3.uuid</code></h2>

<pre><code class="language-python">"""ryo3-uuid types

based on typeshed types for python's builtin uuid module

REF: https://github.com/python/typeshed/blob/main/stdlib/uuid.pyi
"""

import builtins
import typing as t
import uuid as pyuuid
from enum import Enum

from ry._types import Buffer
from ry.protocols import FromStr

_FieldsType: t.TypeAlias = tuple[int, int, int, int, int, int]


class SafeUUID(Enum):
    safe = 0
    unsafe = -1
    unknown = None


@t.final
class UUID(FromStr):
    NAMESPACE_DNS: UUID
    NAMESPACE_URL: UUID
    NAMESPACE_OID: UUID
    NAMESPACE_X500: UUID

    def __init__(
        self,
        hex: str | None = None,  # noqa: A002
        bytes: builtins.bytes | None = None,  # noqa: A002
        bytes_le: builtins.bytes | None = None,
        fields: _FieldsType | None = None,
        int: builtins.int | None = None,  # noqa: A002
        version: builtins.int | None = None,
        *,
        is_safe: SafeUUID = ...,
    ) -&gt; None: ...
    @property
    def is_nil(self) -&gt; bool: ...
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def bytes_le(self) -&gt; builtins.bytes: ...
    @property
    def clock_seq(self) -&gt; builtins.int: ...
    @property
    def clock_seq_hi_variant(self) -&gt; builtins.int: ...
    @property
    def clock_seq_low(self) -&gt; builtins.int: ...
    @property
    def fields(self) -&gt; _FieldsType: ...
    @property
    def hex(self) -&gt; str: ...
    @property
    def int(self) -&gt; builtins.int: ...
    @property
    def node(self) -&gt; builtins.int: ...
    @property
    def time(self) -&gt; builtins.int: ...
    @property
    def time_hi_version(self) -&gt; builtins.int: ...
    @property
    def time_low(self) -&gt; builtins.int: ...
    @property
    def time_mid(self) -&gt; builtins.int: ...
    @property
    def urn(self) -&gt; str: ...
    @property
    def variant(self) -&gt; str: ...
    @property
    def version(self) -&gt; builtins.int | None: ...
    def to_py(self) -&gt; pyuuid.UUID: ...
    def to_string(self) -&gt; str: ...
    # --- CLASSMETHODS --
    @classmethod
    def from_bytes(cls, b: builtins.bytes) -&gt; t.Self: ...
    @classmethod
    def from_bytes_le(cls, b: builtins.bytes) -&gt; t.Self: ...
    @classmethod
    def from_fields(cls, fields: _FieldsType) -&gt; t.Self: ...
    @classmethod
    def from_hex(cls, hexstr: str) -&gt; t.Self: ...
    @classmethod
    def from_int(cls, i: builtins.int) -&gt; t.Self: ...
    @classmethod
    def from_pyuuid(cls, ob: pyuuid.UUID) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    # --- DUNDERS ---
    def __bytes__(self) -&gt; builtins.bytes: ...
    def __lt__(self, other: UUID) -&gt; bool: ...
    def __le__(self, other: UUID) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: UUID) -&gt; bool: ...
    def __ge__(self, other: UUID) -&gt; bool: ...
    def __hash__(self) -&gt; builtins.int: ...
    def __int__(self) -&gt; builtins.int: ...


def getnode() -&gt; builtins.int: ...
def uuid1(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid3(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid4() -&gt; UUID: ...
def uuid5(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid6(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid7(timestamp: int | None = None) -&gt; UUID: ...
@t.overload
def uuid8(*, buf: Buffer) -&gt; UUID: ...  # 16 bytes buffer
@t.overload
def uuid8(
    a: int | None = None,
    b: int | None = None,
    c: int | None = None,
    *,
    buf: None = None,
) -&gt; UUID: ...


NAMESPACE_DNS: UUID
NAMESPACE_URL: UUID
NAMESPACE_OID: UUID
NAMESPACE_X500: UUID
RESERVED_NCS: str
RFC_4122: str
RESERVED_MICROSOFT: str
RESERVED_FUTURE: str
</code></pre>
<h2 id="ry.ryo3.xxhash"><code>ry.ryo3.xxhash</code></h2>

<pre><code class="language-python">import typing as t

from ry._types import Buffer


@t.final
class xxh32:  # noqa: N801
    name: t.Literal["xxh32"]
    digest_size: t.Literal[4]
    block_size: t.Literal[16]

    def __init__(self, data: Buffer = ..., *, seed: int = 0) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...
    @staticmethod
    def oneshot(data: Buffer, *, seed: int = 0) -&gt; int: ...


@t.final
class xxh64:  # noqa: N801
    name: t.Literal["xxh64"]
    digest_size: t.Literal[8]
    block_size: t.Literal[32]

    def __init__(
        self, data: Buffer | None = None, *, seed: int = 0
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...
    @staticmethod
    def oneshot(data: Buffer, *, seed: int = 0) -&gt; int: ...


@t.final
class xxh3_64:  # noqa: N801
    name: t.Literal["xxh3_64"]
    digest_size: t.Literal[8]
    block_size: t.Literal[32]

    def __init__(
        self,
        data: Buffer = ...,
        *,
        seed: int = 0,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, seed: int = 0, secret: bytes | None = None
    ) -&gt; int: ...


@t.final
class xxh3_128:  # noqa: N801
    name: t.Literal["xxh3_128"]
    digest_size: t.Literal[16]
    block_size: t.Literal[64]

    def __init__(
        self,
        data: Buffer = ...,
        *,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, seed: int = 0, secret: bytes | None = None
    ) -&gt; int: ...


xxh128 = xxh3_128

# -----------------------------------------------------------------------------
# ONE-SHOT FUNCTIONS
# -----------------------------------------------------------------------------


# xxh32
def xxh32_digest(data: Buffer, *, seed: int = 0) -&gt; bytes: ...
def xxh32_hexdigest(data: Buffer, *, seed: int = 0) -&gt; str: ...
def xxh32_intdigest(data: Buffer, *, seed: int = 0) -&gt; int: ...


# xxh64
def xxh64_digest(data: Buffer, *, seed: int = 0) -&gt; bytes: ...
def xxh64_hexdigest(data: Buffer, *, seed: int = 0) -&gt; str: ...
def xxh64_intdigest(data: Buffer, *, seed: int = 0) -&gt; int: ...


# xxh3
def xxh3_64_digest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; bytes: ...
def xxh3_64_intdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; int: ...
def xxh3_64_hexdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; str: ...


# xxh128
def xxh3_128_digest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; bytes: ...
def xxh3_128_intdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; int: ...
def xxh3_128_hexdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; str: ...


# xxh128
def xxh128_digest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; bytes: ...
def xxh128_hexdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; str: ...
def xxh128_intdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3.zstd"><code>ry.ryo3.zstd</code></h2>

<pre><code class="language-python">"""ryo3-zstd types"""

from typing import Literal, TypeAlias

from ry import Bytes
from ry._types import Buffer

__zstd_version__: str  # zstd version string ("1.5.7" as of 2025-03-14)
BLOCKSIZELOG_MAX: int
BLOCKSIZE_MAX: int
CLEVEL_DEFAULT: int  # default=3 (as of 2025-03-14)
CONTENTSIZE_ERROR: int
CONTENTSIZE_UNKNOWN: int
MAGICNUMBER: int
MAGIC_DICTIONARY: int
MAGIC_SKIPPABLE_MASK: int
MAGIC_SKIPPABLE_START: int
VERSION_MAJOR: int
VERSION_MINOR: int
VERSION_NUMBER: int
VERSION_RELEASE: int

_Quality: TypeAlias = Literal[
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
]


# __COMPRESSION__
def compress(data: Buffer, level: _Quality = 3) -&gt; Bytes: ...
def encode(data: Buffer, level: _Quality = 3) -&gt; Bytes: ...
def zstd(data: Buffer, level: _Quality = 3) -&gt; Bytes: ...


# __DECOMPRESSION__
def decode(data: Buffer) -&gt; Bytes: ...
def decompress(data: Buffer) -&gt; Bytes: ...
def unzstd(data: Buffer) -&gt; Bytes: ...


# __MAGIC__
def is_zstd(data: Buffer) -&gt; bool: ...
</code></pre>
<h2 id="ry._types"><code>ry._types</code></h2>

<pre><code class="language-python">"""ry-types"""

from __future__ import annotations

import sys
from os import PathLike
from typing import TYPE_CHECKING, Literal, TypeAlias

if TYPE_CHECKING:
    import datetime as pydt


if sys.version_info &gt;= (3, 12):  # pragma: no cover
    from collections.abc import Buffer
    from typing import TypedDict, Unpack
else:  # pragma: no cover
    from typing_extensions import Buffer, TypedDict, Unpack

__all__ = (
    "Buffer",
    "DateDifferenceTypedDict",
    "DateTimeDifferenceTypedDict",
    "DateTimeRoundTypedDict",
    "DateTimeTypedDict",
    "DateTimeTypedDict",
    "DateTypedDict",
    "DateTypedDict",
    "DurationDict",
    "FsPathLike",
    "ISOWeekDateTypedDict",
    "JiffRoundMode",
    "JiffUnit",
    "MetadataDict",
    "OffsetInfoDict",
    "OffsetRoundTypedDict",
    "SignedDurationRoundTypedDict",
    "TimeDifferenceTypedDict",
    "TimeRoundTypedDict",
    "TimeSpanTypedDict",
    "TimeTypedDict",
    "TimestampDifferenceTypedDict",
    "TimestampRoundTypedDict",
    "TimestampTypedDict",
    "Unpack",
    "ZonedDateTimeDifferenceTypedDict",
    "ZonedDateTimeRoundTypedDict",
)

FsPathLike = str | PathLike[str]


# =============================================================================
# STD
# =============================================================================
class DurationDict(TypedDict):
    secs: int
    nanos: int


class MetadataDict(TypedDict):
    is_dir: bool
    is_file: bool
    is_symlink: bool
    len: int
    readonly: bool
    file_type: Literal["file", "directory", "symlink"]
    accessed: pydt.datetime
    created: pydt.datetime
    modified: pydt.datetime


# =============================================================================
# JIFF
# =============================================================================
JiffUnit: TypeAlias = Literal[
    "year",  # 9
    "month",  # 8
    "day",  # 6
    "hour",  # 5
    "minute",  # 4
    "second",  # 3
    "millisecond",  # 2
    "microsecond",  # 1
    "nanosecond",  # 0
]
JiffRoundMode: TypeAlias = Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half-ceil",
    "half-floor",
    "half-expand",
    "half-trunc",
    "half-even",
]


class DateTypedDict(TypedDict):
    year: int
    month: int
    day: int


class TimeTypedDict(TypedDict):
    hour: int
    minute: int
    second: int
    nanosecond: int


class DateTimeTypedDict(TypedDict):
    year: int
    month: int
    day: int
    hour: int
    minute: int
    second: int
    nanosecond: int


class ZonedDateTimeTypedDict(TypedDict):
    year: int
    month: int
    day: int
    hour: int
    minute: int
    second: int
    nanosecond: int
    tz: str


class TimestampTypedDict:
    second: int
    nanosecond: int


class SignedDurationTypedDict(TypedDict):
    secs: int
    nanos: int


class TimeSpanTypedDict(TypedDict):
    """TimeSpan TypedDict

    Examples:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; ts = ry.timespan(years=1, months=2, weeks=3)
        &gt;&gt;&gt; ts.to_dict()
        {'years': 1, 'months': 2, 'weeks': 3, 'days': 0, 'hours': 0, 'minutes': 0, 'seconds': 0, 'milliseconds': 0, 'microseconds': 0, 'nanoseconds': 0}

    """

    years: int
    months: int
    weeks: int
    days: int
    hours: int
    minutes: int
    seconds: int
    milliseconds: int
    microseconds: int
    nanoseconds: int


class TimeZoneDict(TypedDict):
    tz: str


class OffsetTypedDict(TypedDict):
    seconds: int
    fmt: str


class OffsetInfoDict(TypedDict):
    offset: OffsetTypedDict
    dst: bool
    abbreviation: str


class ISOWeekDateTypedDict(TypedDict):
    year: int
    week: int
    weekday: int


# -----------------------------------------------------------------------------
# JIFF ROUND
# -----------------------------------------------------------------------------
class DateTimeRoundTypedDict(TypedDict):
    smallest: Literal[
        "day",
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class SignedDurationRoundTypedDict(TypedDict):
    smallest: Literal[
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class TimeRoundTypedDict(TypedDict):
    smallest: Literal[
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class TimestampRoundTypedDict(TypedDict):
    smallest: Literal[
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class ZonedDateTimeRoundTypedDict(TypedDict):
    smallest: Literal[
        "day",
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class OffsetRoundTypedDict(TypedDict):
    smallest: Literal[
        "second",
        "minute",
        "hour",
    ]
    mode: JiffRoundMode
    increment: int


# -----------------------------------------------------------------------------
# JIFF DIFFERENCE
# -----------------------------------------------------------------------------
class _DifferenceTypedDict(TypedDict):
    mode: JiffRoundMode
    increment: int


DateDifferenceUnit: TypeAlias = Literal["month", "year", "day"]


class DateDifferenceTypedDict(_DifferenceTypedDict):
    smallest: DateDifferenceUnit
    largest: DateDifferenceUnit | None


class DateTimeDifferenceTypedDict(_DifferenceTypedDict):
    smallest: JiffUnit
    largest: JiffUnit | None


TimeDifferenceUnit: TypeAlias = Literal[
    "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"
]


class TimeDifferenceTypedDict(_DifferenceTypedDict):
    smallest: TimeDifferenceUnit
    largest: TimeDifferenceUnit | None


class ZonedDateTimeDifferenceTypedDict(_DifferenceTypedDict):
    smallest: JiffUnit
    largest: JiffUnit | None


TimeStampDifferenceUnit: TypeAlias = Literal[
    "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"
]


class TimestampDifferenceTypedDict(_DifferenceTypedDict):
    smallest: TimeStampDifferenceUnit
    largest: TimeStampDifferenceUnit | None


# =============================================================================
# OPEN MODES (CANONICAL)
# =============================================================================
# ry accepts the non-canonical modes, but they are mapped to the canonical ones]

OpenTextModeUpdating: TypeAlias = Literal[
    "a+", "at+", "r+", "rt+", "w+", "wt+", "x+", "xt+"
]
OpenTextModeWriting: TypeAlias = Literal["a", "at", "w", "wt", "x", "xt"]
OpenTextModeReading: TypeAlias = Literal["r", "rt"]
OpenTextMode: TypeAlias = Literal[
    "a",
    "a+",
    "at",
    "at+",
    "r",
    "r+",
    "rt",
    "rt+",
    "w",
    "w+",
    "wt",
    "wt+",
    "x",
    "x+",
    "xt",
    "xt+",
]
OpenBinaryModeUpdating: TypeAlias = Literal["ab+", "rb+", "wb+", "xb+"]
OpenBinaryModeWriting: TypeAlias = Literal["ab", "wb", "xb"]
OpenBinaryModeReading: TypeAlias = Literal["rb"]
OpenBinaryMode: TypeAlias = Literal[
    "ab", "ab+", "rb", "rb+", "wb", "wb+", "xb", "xb+"
]
OpenMode: TypeAlias = Literal[
    "a",
    "a+",
    "ab",
    "ab+",
    "at",
    "at+",
    "r",
    "r+",
    "rb",
    "rb+",
    "rt",
    "rt+",
    "w",
    "w+",
    "wb",
    "wb+",
    "wt",
    "wt+",
    "x",
    "x+",
    "xb",
    "xb+",
    "xt",
    "xt+",
]
</code></pre>
<h2 id="ry.dirs"><code>ry.dirs</code></h2>

<pre><code class="language-python">from ry.ryo3.dirs import audio as audio
from ry.ryo3.dirs import audio_dir as audio_dir
from ry.ryo3.dirs import cache as cache
from ry.ryo3.dirs import cache_dir as cache_dir
from ry.ryo3.dirs import config as config
from ry.ryo3.dirs import config_dir as config_dir
from ry.ryo3.dirs import config_local as config_local
from ry.ryo3.dirs import config_local_dir as config_local_dir
from ry.ryo3.dirs import data as data
from ry.ryo3.dirs import data_dir as data_dir
from ry.ryo3.dirs import data_local as data_local
from ry.ryo3.dirs import data_local_dir as data_local_dir
from ry.ryo3.dirs import desktop as desktop
from ry.ryo3.dirs import desktop_dir as desktop_dir
from ry.ryo3.dirs import document as document
from ry.ryo3.dirs import document_dir as document_dir
from ry.ryo3.dirs import download as download
from ry.ryo3.dirs import download_dir as download_dir
from ry.ryo3.dirs import executable as executable
from ry.ryo3.dirs import executable_dir as executable_dir
from ry.ryo3.dirs import font as font
from ry.ryo3.dirs import font_dir as font_dir
from ry.ryo3.dirs import home as home
from ry.ryo3.dirs import home_dir as home_dir
from ry.ryo3.dirs import picture as picture
from ry.ryo3.dirs import picture_dir as picture_dir
from ry.ryo3.dirs import preference as preference
from ry.ryo3.dirs import preference_dir as preference_dir
from ry.ryo3.dirs import public as public
from ry.ryo3.dirs import public_dir as public_dir
from ry.ryo3.dirs import runtime as runtime
from ry.ryo3.dirs import runtime_dir as runtime_dir
from ry.ryo3.dirs import state as state
from ry.ryo3.dirs import state_dir as state_dir
from ry.ryo3.dirs import template as template
from ry.ryo3.dirs import template_dir as template_dir
from ry.ryo3.dirs import video as video
from ry.ryo3.dirs import video_dir as video_dir

__all__ = (
    "audio",
    "audio_dir",
    "cache",
    "cache_dir",
    "config",
    "config_dir",
    "config_local",
    "config_local_dir",
    "data",
    "data_dir",
    "data_local",
    "data_local_dir",
    "desktop",
    "desktop_dir",
    "document",
    "document_dir",
    "download",
    "download_dir",
    "executable",
    "executable_dir",
    "font",
    "font_dir",
    "home",
    "home_dir",
    "picture",
    "picture_dir",
    "preference",
    "preference_dir",
    "public",
    "public_dir",
    "runtime",
    "runtime_dir",
    "state",
    "state_dir",
    "template",
    "template_dir",
    "video",
    "video_dir",
)
</code></pre>
<h2 id="ry.JSON"><code>ry.JSON</code></h2>

<pre><code class="language-python">"""ry.JSON"""

from ry.ryo3.JSON import cache_clear as cache_clear
from ry.ryo3.JSON import cache_usage as cache_usage
from ry.ryo3.JSON import dumps as dumps
from ry.ryo3.JSON import fmt as fmt
from ry.ryo3.JSON import loads as loads
from ry.ryo3.JSON import minify as minify
from ry.ryo3.JSON import parse as parse
from ry.ryo3.JSON import stringify as stringify

__all__ = (
    "cache_clear",
    "cache_usage",
    "dumps",
    "fmt",
    "loads",
    "minify",
    "parse",
    "stringify",
)
</code></pre>
<h2 id="ry.protocols"><code>ry.protocols</code></h2>

<pre><code class="language-python">import datetime as pydt
import typing as t

__all__ = (
    "FromStr",
    "NoInit",
    "RyIterator",
    "Strftime",
    "ToPy",
    "ToPyDate",
    "ToPyDateTime",
    "ToPyTime",
    "ToPyTimeDelta",
    "ToPyTzInfo",
    "ToString",
    "_Parse",
)

_T = t.TypeVar("_T")
_T_co = t.TypeVar("_T_co", covariant=True)


class ToPy(t.Protocol[_T_co]):
    """Objects that can be converted to a python stdlib type (`_T_co`) via `obj.to_py()`."""

    def to_py(self) -&gt; _T_co: ...


class NoInit(t.Protocol):
    """Protocol for types that cannot be instantiated directly."""

    def __init__(self) -&gt; t.NoReturn: ...


# =============================================================================
# TO/FROM STRING
# =============================================================================
class FromStr(t.Protocol):
    """Protocol for types that have a `.from_str()` class method."""

    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...


class _Parse(t.Protocol):
    """Protocol for types that have a `.parse()` class method."""

    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...


class ToString(t.Protocol):
    """Protocol for types that have a `.to_string()` method."""

    def to_string(self) -&gt; str: ...


# =============================================================================
# ITERABLE
# =============================================================================
class RyIterator(t.Protocol[_T]):
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; _T: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


class RyAsyncIterator(t.Protocol[_T]):
    def __aiter__(self) -&gt; t.Self: ...
    async def __anext__(self) -&gt; _T: ...
    async def collect(self) -&gt; list[_T]: ...
    async def take(self, n: int = 1) -&gt; list[_T]: ...


# =============================================================================
# DATETIME
# =============================================================================


class Strftime(t.Protocol):
    """Protocol for types that have a `.strftime()` method."""

    def strftime(self, fmt: str) -&gt; str: ...


class ToPyDate(t.Protocol):
    """Objects that can be converted to a Python `datetime.date`."""

    def to_pydate(self) -&gt; pydt.date: ...


class ToPyTime(t.Protocol):
    """Objects that can be converted to a Python `datetime.time`."""

    def to_pytime(self) -&gt; pydt.time: ...


class ToPyDateTime(t.Protocol):
    """Objects that can be converted to a Python `datetime.datetime`."""

    def to_pydatetime(self) -&gt; pydt.datetime: ...


class ToPyTimeDelta(t.Protocol):
    """Objects that can be converted to a Python `datetime.timedelta`."""

    def to_pytimedelta(self) -&gt; pydt.timedelta: ...


class ToPyTzInfo(t.Protocol):
    """Objects that can be converted to a Python `datetime.tzinfo`."""

    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
</code></pre>
<h2 id="ry.ulid"><code>ry.ulid</code></h2>

<pre><code class="language-python">from ry.ryo3.ulid import ULID

__all__ = ("ULID",)
</code></pre>
<h2 id="ry.uuid"><code>ry.uuid</code></h2>

<pre><code class="language-python">from ry.ryo3.uuid import (
    NAMESPACE_DNS,
    NAMESPACE_OID,
    NAMESPACE_URL,
    NAMESPACE_X500,
    RESERVED_FUTURE,
    RESERVED_MICROSOFT,
    RESERVED_NCS,
    RFC_4122,
    UUID,
    getnode,
    uuid1,
    uuid3,
    uuid4,
    uuid5,
    uuid6,
    uuid7,
    uuid8,
)

__all__ = (
    "NAMESPACE_DNS",
    "NAMESPACE_OID",
    "NAMESPACE_URL",
    "NAMESPACE_X500",
    "RESERVED_FUTURE",
    "RESERVED_MICROSOFT",
    "RESERVED_NCS",
    "RFC_4122",
    "UUID",
    "getnode",
    "uuid1",
    "uuid3",
    "uuid4",
    "uuid5",
    "uuid6",
    "uuid7",
    "uuid8",
)
</code></pre>
<h2 id="ry.xxhash"><code>ry.xxhash</code></h2>

<pre><code class="language-python">from ry.ryo3.xxhash import xxh3_64 as xxh3_64
from ry.ryo3.xxhash import xxh3_64_digest as xxh3_64_digest
from ry.ryo3.xxhash import xxh3_64_hexdigest as xxh3_64_hexdigest
from ry.ryo3.xxhash import xxh3_64_intdigest as xxh3_64_intdigest
from ry.ryo3.xxhash import xxh3_128 as xxh3_128
from ry.ryo3.xxhash import xxh3_128_digest as xxh3_128_digest
from ry.ryo3.xxhash import xxh3_128_hexdigest as xxh3_128_hexdigest
from ry.ryo3.xxhash import xxh3_128_intdigest as xxh3_128_intdigest
from ry.ryo3.xxhash import xxh32 as xxh32
from ry.ryo3.xxhash import xxh32_digest as xxh32_digest
from ry.ryo3.xxhash import xxh32_hexdigest as xxh32_hexdigest
from ry.ryo3.xxhash import xxh32_intdigest as xxh32_intdigest
from ry.ryo3.xxhash import xxh64 as xxh64
from ry.ryo3.xxhash import xxh64_digest as xxh64_digest
from ry.ryo3.xxhash import xxh64_hexdigest as xxh64_hexdigest
from ry.ryo3.xxhash import xxh64_intdigest as xxh64_intdigest
from ry.ryo3.xxhash import xxh128 as xxh128
from ry.ryo3.xxhash import xxh128_digest as xxh128_digest
from ry.ryo3.xxhash import xxh128_hexdigest as xxh128_hexdigest
from ry.ryo3.xxhash import xxh128_intdigest as xxh128_intdigest

__all__ = (
    "xxh3_64",
    "xxh3_64_digest",
    "xxh3_64_hexdigest",
    "xxh3_64_intdigest",
    "xxh3_128",
    "xxh3_128_digest",
    "xxh3_128_hexdigest",
    "xxh3_128_intdigest",
    "xxh32",
    "xxh32_digest",
    "xxh32_hexdigest",
    "xxh32_intdigest",
    "xxh64",
    "xxh64_digest",
    "xxh64_hexdigest",
    "xxh64_intdigest",
    "xxh128",
    "xxh128_digest",
    "xxh128_hexdigest",
    "xxh128_intdigest",
)
</code></pre>
<h2 id="ry.zstd"><code>ry.zstd</code></h2>

<pre><code class="language-python">from ry.ryo3.zstd import BLOCKSIZE_MAX as BLOCKSIZE_MAX
from ry.ryo3.zstd import BLOCKSIZELOG_MAX as BLOCKSIZELOG_MAX
from ry.ryo3.zstd import CLEVEL_DEFAULT as CLEVEL_DEFAULT
from ry.ryo3.zstd import CONTENTSIZE_ERROR as CONTENTSIZE_ERROR
from ry.ryo3.zstd import CONTENTSIZE_UNKNOWN as CONTENTSIZE_UNKNOWN
from ry.ryo3.zstd import MAGIC_DICTIONARY as MAGIC_DICTIONARY
from ry.ryo3.zstd import MAGIC_SKIPPABLE_MASK as MAGIC_SKIPPABLE_MASK
from ry.ryo3.zstd import MAGIC_SKIPPABLE_START as MAGIC_SKIPPABLE_START
from ry.ryo3.zstd import MAGICNUMBER as MAGICNUMBER
from ry.ryo3.zstd import VERSION_MAJOR as VERSION_MAJOR
from ry.ryo3.zstd import VERSION_MINOR as VERSION_MINOR
from ry.ryo3.zstd import VERSION_NUMBER as VERSION_NUMBER
from ry.ryo3.zstd import VERSION_RELEASE as VERSION_RELEASE
from ry.ryo3.zstd import __zstd_version__ as __zstd_version__
from ry.ryo3.zstd import compress as compress
from ry.ryo3.zstd import decode as decode
from ry.ryo3.zstd import decompress as decompress
from ry.ryo3.zstd import is_zstd as is_zstd
from ry.ryo3.zstd import unzstd as unzstd

__all__ = (
    "BLOCKSIZELOG_MAX",
    "BLOCKSIZE_MAX",
    "CLEVEL_DEFAULT",
    "CONTENTSIZE_ERROR",
    "CONTENTSIZE_UNKNOWN",
    "MAGICNUMBER",
    "MAGIC_DICTIONARY",
    "MAGIC_SKIPPABLE_MASK",
    "MAGIC_SKIPPABLE_START",
    "VERSION_MAJOR",
    "VERSION_MINOR",
    "VERSION_NUMBER",
    "VERSION_RELEASE",
    "__zstd_version__",
    "compress",
    "decode",
    "decompress",
    "is_zstd",
    "unzstd",
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dep-graph"><a class="header" href="#dep-graph">DEP-GRAPH</a></h1>
<p><img src="assets/dep-graph.svg" alt="ryo3-dep-graph"></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="food-4-thought"><a class="header" href="#food-4-thought">food-4-thought</a></h1>
<p>thinking out loud…</p>
<h2 id="staticmethod-vs-classmethod-2025-08-28"><a class="header" href="#staticmethod-vs-classmethod-2025-08-28">staticmethod vs classmethod [2025-08-28]</a></h2>
<p>Nowhere in ry are any of the <code>classmethod</code> functions actually used as
classmethods, they are effectively staticmethods; they don’t access the class or
instance in any way. Classes in <code>ry</code> do not (for the most part) support being
subclassed. Benchmarking shows that <code>staticmethod</code> is slightly faster than
<code>classmethod</code>, sooooo all classmethods will be removed, but added back in if
needed later…</p>
<p>Benchmarking code:</p>
<pre><code class="language-python">from __future__ import annotations

import json
from pathlib import Path
from typing import TYPE_CHECKING

import pytest

import ry as ry

if TYPE_CHECKING:
    from pytest_benchmark.fixture import BenchmarkFixture


def test_classmethod(benchmark: BenchmarkFixture):
    # this is the current (as of 2025-08-28) `#[staticmethod]` parse function
    benchmark(ry.Date.parse, "2023-03-15")


def test_staticmethod(benchmark: BenchmarkFixture):
    # This is a crudely copy-pasted version using `#[staticmethod]` instead
    benchmark(ry.Date.parse2, "2023-03-15")
</code></pre>
<p>Benchmark results:</p>
<pre><code>---------------------------------------------------------------------------------------- benchmark: 2 tests ---------------------------------------------------------------------------------------
Name (time in ns)         Min                    Max                Mean              StdDev              Median               IQR             Outliers  OPS (Mops/s)            Rounds  Iterations
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_staticmethod     57.5000 (1.0)       2,290.0000 (1.0)       63.4931 (1.0)       16.2941 (1.0)       62.0000 (1.0)      1.5000 (824.63)  1048;11454       15.7497 (1.0)      100000         200
test_classmethod      99.9989 (1.74)     29,200.0004 (12.75)    128.8420 (2.03)     146.9563 (9.02)     100.0008 (1.61)     0.0018 (1.0)      911;24504        7.7614 (0.49)     100000           1
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Legend:
  Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.
  OPS: Operations Per Second, computed as 1 / Mean
</code></pre>
<hr>
<h2 id="fugue-state-jesse-2025-08-18"><a class="header" href="#fugue-state-jesse-2025-08-18">fugue-state-jesse [2025-08-18]</a></h2>
<p>The most sophisticated rust code in this repository was written by
<code>fugue-state-jesse</code> (aka FSJ), not me (<code>normal-jesse</code>) and not an AI/LLM.
<code>fugue-state-jesse</code> only shows up at random about 1-2 times a week and seemingly
has a vastly better understanding of rust and rust-macro-rules than I do.</p>
<p>Throughout the repository I (normal-jesse) will sometimes leave notes to
<code>fugue-state-jesse</code> with the hope that he might do what I ask, but he tends to
do his own thing.</p>
<hr>
<h2 id="rydev"><a class="header" href="#rydev"><code>ry.dev</code></a></h2>
<p>For people who find <code>ry.dev</code> it is a module that exports all the things in ry as
well as can be used as a repl; <code>python -m ry.dev</code> will start a repl (with
ipython if installed else python-repl) with all of ry already imported. I
(jesse) use this super often for testing things out.</p>
<hr>
<h2 id="string-bridge"><a class="header" href="#string-bridge">string-bridge?</a></h2>
<p>The <code>jiter</code> crate uses a string-cache to store python-strings to avoid the
overhead of converting strings to python strings. A global string bridge and/or
caching setup for other types of structs that often convert to strings might be
worth considering?</p>
<hr>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Coming up with names is hard… I (jesse) want to strike a balance between being
clear but also close to the wrapped libraries…</p>
<ul>
<li>Should jiff’s <code>Zoned</code> be <code>Zoned</code> in python? or <code>ZonedDateTime</code>? (currently
<code>ZonedDateTime</code>)</li>
<li>Should jiff’s <code>Span</code> be <code>Span</code> in python? or <code>TimeSpan</code>? (currently
<code>TimeSpan</code>)</li>
<li>Should reqwest’s <code>Client</code> be <code>Client</code> in python? or <code>HttpClient</code>? (currently
<code>HttpClient</code>)</li>
</ul>
<hr>
<h2 id="flat-nested-submodules"><a class="header" href="#flat-nested-submodules">Flat? Nested submodules?</a></h2>
<p>I like flat more, but nesting submodules might be preferable for some people and
would allow for more flexibility in naming…</p>
<p>pros &amp; cons:</p>
<ul>
<li>flat:
<ul>
<li>pros:
<ul>
<li>easier to import</li>
<li>easier to work on</li>
<li>no need to remember where things are</li>
<li>type annotations are easier to setup/dist</li>
</ul>
</li>
<li>cons:
<ul>
<li>name conflicts</li>
<li>type annotations are harder to read bc of huge file</li>
<li>harder to remember where things are</li>
</ul>
</li>
</ul>
</li>
<li>nested:
<ul>
<li>pros:
<ul>
<li>no name conflicts</li>
<li>easier to remember where things are</li>
<li>type annotations are easier to read</li>
<li>importing <code>ry.jiff</code> (or <code>ry.ryo3.jiff</code> tbd) is more explicitly the <code>jiff</code>
wrapper(s)</li>
</ul>
</li>
<li>cons:
<ul>
<li>Don’t know how type annotations should be laid out… if there is a
submodule called <code>ry.ryo3.reqwest</code>, do you import from <code>ry.ryo3.reqwest</code>
or do we reexport from <code>ry.reqwest</code>? Then were doe the type-annotations
live and how are they laid out without having to duplicate/shim them?</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="pypi-size-limit"><a class="header" href="#pypi-size-limit">pypi size limit</a></h2>
<p>The pypi project size limit of 10gb was reached. I (jesse) won’t request a limit
raise until the package is more stable and hits some sort of <code>v0.1.x</code>, SOOOOOO
for now I will be:</p>
<ul>
<li>deleting older versions of ry from pypi as needed</li>
<li>update the release gh-action to push the built wheels to the releases page so
they are not lost into the ether…</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="jiff"><a class="header" href="#jiff">jiff</a></h1>
<p>docs.rs: <a href="https://docs.rs/jiff">https://docs.rs/jiff</a></p>
<p>crates: <a href="https://crates.io/crates/jiff">https://crates.io/crates/jiff</a></p>
<hr>
<p>The <code>jiff</code> crate has a super excellent API that is very ergonomic to use and
<code>ry</code> provides a nearly complete wrapper around it.</p>
<p>A good amount of time, and a greater amount of thought has gone into balancing
the <code>jiff</code> python api to be both ergonomic and performant.</p>
<h2 id="python-conversions"><a class="header" href="#python-conversions">python-conversions</a></h2>
<p>The structs under <code>ryo3-jiff</code> are convertible to/from python’s <code>datetime.*</code>
types and the conversions are pretty well tested (ty hypothesis).</p>
<h3 id="pyo3-v0240--jiff-02"><a class="header" href="#pyo3-v0240--jiff-02"><code>pyo3-v0.24.0</code> &amp; <code>jiff-02</code></a></h3>
<p>The conversions to/from python <code>datetime.*</code> types were originally hand rolled (
by me (jesse)) using the ‘new-type’ pattern, HOWEVER <code>pyo3-v0.24.0</code> provides
conversions via the <code>jiff-02</code> feature flag, which is what is used now.</p>
<p><code>ry-v0.0.37</code> will be the last version with the mostly hand rolled conversions.</p>
<p><code>ry-v0.0.38</code> will be the first version with the <code>jiff-02</code> feature flag.</p>
<p>As of 2025-03-12 <code>pyo3</code> does not seem to support converting <code>Span</code> -&gt;
<code>datetime.timedelta</code>, so that is still hand rolled.</p>
<hr>
<h2 id="ry-vs-whenever"><a class="header" href="#ry-vs-whenever"><code>ry</code> vs <code>whenever</code></a></h2>
<p>There is another library called
<a href="https://github.com/ariebovenberg/whenever"><code>whenever</code></a> that provides a similar
datetime library to that of <code>ryo3-jiff</code> (both <code>jiff</code> and <code>whenever</code> are based on
the <a href="https://tc39.es/proposal-temporal/docs/">temporal</a> API).</p>
<p>No formal benchmarks between <code>ry</code> and <code>whenever</code> have been done, but I have
copy-pasta-ed some of the benchmarks from the <code>whenever</code> repo and translated
them to <code>ry</code> and the results were pretty similar; <code>whenever</code> is faster for some
things, <code>ry</code> is faster for others, but both are wildly more performant than
python’s built in <code>datetime</code> module and <code>pendulum</code> – differences in performance
are almost all measured in nanoseconds.</p>
<p>Big shoutout to “Mr. Dutch Airlines” guy
(<a href="https://github.com/ariebovenberg">@ariebovenberg</a>) who wrote <code>whenever</code>! Love
the name of the library too!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
