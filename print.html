<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ry(o3) docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ry(o3) docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jessekrubin/ry" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><strong>updated:</strong> <code>{{#RY_DOCS_BUILD_TIMESTAMP}}</code></p>
<hr />
<h1 id="readme"><a class="header" href="#readme">README</a></h1>
<h1 id="ry"><a class="header" href="#ry">ry</a></h1>
<p>A growing collection of Python shims around Rust crates — fast, async-first, and
ergonomic.</p>
<p><a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/v/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/pyversions/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Python Version" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/wheel/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Wheel" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/dm/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Downloads" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/status/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Status" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/l/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - License" /></a></p>
<p><strong>DOCS:</strong> <a href="https://ryo3.dev">ryo3.dev</a> (WIP)</p>
<p><strong>API:</strong> <a href="https://ryo3.dev/api">ryo3.dev/api</a></p>
<p><strong>This is a work in progress — feedback and PRs are welcome.</strong></p>
<h2 id="highlights"><a class="header" href="#highlights">Highlights</a></h2>
<ul>
<li>
<p><strong>Async-first HTTP client</strong> Built on <code>reqwest</code>, with a <code>fetch</code>-like API.
Supports streaming, zero-copy IO via the buffer protocol, timeouts, retries,
and native JSON parsing via <code>jiter</code>.</p>
</li>
<li>
<p><strong>Async file I/O</strong> Built on <code>tokio</code>, with an <code>AsyncFile</code> API similar to
<code>aiofiles</code> and <code>anyio</code>’s async-file api. Supports buffered reads/writes,
truncation, streaming reads, and <code>anyio</code> compatibility.</p>
</li>
<li>
<p><strong>(de)compression</strong> (de)compression tools for <code>zstd</code>, <code>brotli</code>, <code>gzip</code>, and
<code>bzip2</code>.</p>
</li>
<li>
<p><strong>Datetime utilities via <code>jiff</code></strong> Fast, accurate, timezone-aware datetime
parsing and formatting, with <code>datetime</code> interop and much more</p>
</li>
<li>
<p><strong>Miscellaneous bindings</strong> Includes crates like <code>globset</code>, <code>walkdir</code>,
<code>sqlformat</code>, <code>unindent</code>, <code>xxhash</code>, and more.</p>
</li>
<li>
<p><strong>Designed for ergonomics</strong> Async where it matters. Simple where possible.
Python-native behavior with minimal friction.</p>
</li>
<li>
<p><strong>Type Annotated</strong> Type annotations for all public APIs, with <code>mypy</code> support.</p>
</li>
</ul>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-bash">pip install ry
uv add ry

# check install
python -m ry
</code></pre>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Check out the <a href="https://github.com/jessekrubin/ry/tree/main/examples">examples</a>
directory for some quickstart examples.</p>
<hr />
<h2 id="what"><a class="header" href="#what">What?</a></h2>
<ul>
<li><code>ry</code> – the python package</li>
<li><code>ryo3-*</code> – the rust crates that are used by <code>ry</code> and possibly your own
<code>pyo3</code>-based python package</li>
</ul>
<h2 id="who"><a class="header" href="#who">Who?</a></h2>
<ul>
<li>jessekrubin <a href="mailto:jessekrubin@gmail.com">jessekrubin@gmail.com</a></li>
<li>possibly you!?</li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><em>(aka: questions that I have been asking myself)</em></p>
<ul>
<li><strong>Q:</strong> Why?
<ul>
<li><strong>A:</strong> I (jesse) needed several hashing functions for python and then kept
adding things as I needed them</li>
</ul>
</li>
<li><strong>Q:</strong> Does this have anything to do with the (excellent) package manager
<code>rye</code>?
<ul>
<li><strong>A:</strong> short answer: no. long answer: no, it does not.</li>
</ul>
</li>
<li><strong>Q:</strong> Why is the repo split into <code>ry</code> and <code>ryo3</code>?
<ul>
<li><strong>A:</strong> <code>ry</code> is the python package, <code>ryo3</code> is a rust crate setup to let you
“register” functions you may want if you were writing your own pyo3-python
bindings library; maybe someday the <code>ryo3::libs</code> module will be split up
into separate packages</li>
</ul>
</li>
</ul>
<h2 id="crate-bindings"><a class="header" href="#crate-bindings">Crate bindings</a></h2>
<ul>
<li>wrapped crates:
<ul>
<li><code>std</code> - many stdlib types and apis</li>
<li><code>bytes</code></li>
<li><code>dirs</code></li>
<li><code>glob</code></li>
<li><code>heck</code></li>
<li><code>http</code></li>
<li><code>jiter</code></li>
<li><code>reqwest</code></li>
<li><code>shlex</code></li>
<li><code>size</code></li>
<li><code>sqlformat</code></li>
<li><code>tokio</code> (<code>fs</code> and <code>process</code>)</li>
<li><code>unindent</code></li>
<li><code>url</code></li>
<li><code>uuid</code></li>
<li><code>which</code></li>
<li>compression:
<ul>
<li><code>brotli</code></li>
<li><code>bzip2</code></li>
<li><code>flate2</code></li>
<li><code>zstd</code></li>
</ul>
</li>
<li>hashing:
<ul>
<li><code>fnv</code></li>
<li><code>xxhash</code></li>
</ul>
</li>
<li>burnt-sushi:
<ul>
<li><code>globset</code> (formerly <a href="https://pypi.org/project/globsters/">globsters</a>)</li>
<li><code>jiff</code></li>
<li><code>regex</code> (WIP ~ very incomplete)</li>
<li><code>same-file</code></li>
<li><code>walkdir</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="dev"><a class="header" href="#dev">DEV</a></h2>
<ul>
<li><code>just</code> is used to run tasks</li>
<li>Do not use the phrase <code>blazing fast</code> or any emojis in any PRs or issues or
docs</li>
<li>type annotations are required</li>
<li><code>ruff</code> used for formatting and linting</li>
</ul>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<ul>
<li>utiles (web-map tile utils): https://github.com/jessekrubin/utiles</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">DEVELOPMENT</a></h1>
<p><strong>OPEN TO PRS!</strong></p>
<h2 id="goals"><a class="header" href="#goals">goals</a></h2>
<ol>
<li>Provide a really nice ergonomic API to work with (this is the highest
priority)</li>
<li>Get naming right (this is a hard one!)</li>
<li>Be fast</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">development-setup</a></h2>
<ul>
<li>clone repo</li>
<li>install <code>just</code> (<code>cargo install just</code>)</li>
<li>create a virtual env (using ye olde <code>venv</code> or <code>uv</code> or dare I say <code>conda</code>) – I
am still working out the kinks of using <code>uv</code> with maturin</li>
<li>install the dev-requirements (<code>pip install -r requirements.dev.txt</code>)</li>
<li>run <code>just dev</code> to build and test the library</li>
<li>run <code>just fmt</code> to format the python and rust code</li>
</ul>
<h2 id="style-guide"><a class="header" href="#style-guide">style guide</a></h2>
<ul>
<li><strong>NO UNWRAPPING</strong></li>
<li><strong>NO PANICS</strong></li>
<li><strong>NO <code>blazingly-fast</code></strong> – <code>ry</code> is fast and does not need an adverb</li>
<li><strong>USE CLIPPY</strong> <code>just clippy</code> or <code>just ci</code></li>
<li><strong>USE RUSTFMT AND RUFF</strong> <code>just fmt</code></li>
<li>avoid using macros as they are not as easy to reason about and/or debug, but
feel free to say ‘yolo’</li>
<li>library style guide:
<ul>
<li>python objects/structs/classes defined in the library should be named either
<code>Py&lt;CLASSNAME&gt;</code> or <code>Ry&lt;CLASSNAME&gt;</code> and the prefix should be consistent
throughout the library (eg <code>ryo3-jiff</code> uses <code>Ry</code> as the internal prefix to
not conflict with the <code>Py&lt;CLASSNAME&gt;</code> structs provided by <code>pyo3</code>)</li>
<li>if a <code>pyclass</code> or <code>pyfunction</code> is not mirroring a rust function prefer names
that are puns but also semi-descriptive (eg <code>Globsters</code> in <code>ryo3-globset</code>)</li>
<li>attempt to mirror the structure of the og library as much as possible</li>
<li>wrapper libraries should be of the form <code>ryo3-&lt;LIB_NAME&gt;</code> where <code>&lt;LIB_NAME&gt;</code>
is the name of the library they</li>
<li>library directories should be <code>kebab-case</code> and should be <code>ryo3-&lt;LIB_NAME&gt;</code></li>
<li>MUST PROVIDE TYPE ANNOTATIONS</li>
</ul>
</li>
</ul>
<h2 id="creating-a-new-librarywrapper-thing"><a class="header" href="#creating-a-new-librarywrapper-thing">Creating a new library/wrapper-thing</a></h2>
<ul>
<li>copy the template library <code>ryo3-quick-maths</code> library to your new library name</li>
<li>refer to the above style guide for naming conventions</li>
</ul>
<h2 id="tools"><a class="header" href="#tools">tools</a></h2>
<h3 id="python"><a class="header" href="#python">python</a></h3>
<ul>
<li>we use <code>maturin</code> for building the python wheels</li>
<li>we support <code>python-3.9+</code></li>
<li>we use <code>pytest</code> for testing as well as the following plugins:
<ul>
<li><code>pytest-benchmark</code></li>
<li><code>pytest-asyncio</code> (may switch to <code>anyio</code> in the future)</li>
<li><code>hypothesis</code></li>
</ul>
</li>
</ul>
<h3 id="just"><a class="header" href="#just">just</a></h3>
<p><strong><code>cargo install just</code></strong></p>
<ul>
<li>we use <code>just</code> for task running</li>
<li>to see all tasks run <code>just</code> or <code>just --list</code> (our default task echos the list
of tasks)</li>
</ul>
<p>tasks as of 2024-12-03:</p>
<pre><code class="language-aiignore">Available recipes:
    dev            # dev run build + tests
    develop        # maturin develop
    cargo-test     # cargo test
    build          # build
    build-release  # build release
    dev-rel        # maturin develop release
    pytest         # run pytest
    pytestv        # run pytest (printing captured output)
    test           # run all test
    test-release   # test ry package
    bench          # benchmark ry python package
    ci             # ci rust checks
    cargo-fmt      # cargo format
    cargo-fmtc     # cargo format check
    sort-all-check # ruff check sorting of '__all__'
    sort-all       # ruff sort '__all__'
    ruff-fmt       # ruff format
    ruff-fmtc      # ruff format check
    black          # python format black
    fmtpy          # python format
    fmtcpy         # python format check
    justfilefmt    # justfile format
    justfilefmtc   # justfile format check
    fmt            # format
    fmtc           # format check
    ruff           # run ruff linter
    ruffix         # run ruff + fix
    clippy         # run clippy
    lint           # lint python and rust
    mypy           # run mypy type checker
    pyright        # run pyright
    pip-compile    # pip compile requirements
    gen            # generate code tasks
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>This project would not be possible without the incredible work of many others.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">THANK YOU</a></h2>
<ul>
<li>pyo3 developers</li>
<li>all authors of all libraries used in this project!</li>
<li>burnt-sushi for the incredible set of libraries</li>
<li>Kyle Barron for working on <code>pyo3-bytes</code> and letting me contribute to it</li>
<li>The academy and the hollywood foreign press</li>
</ul>
<hr />
<p>If you want to be added to this list, please open an issue or PR! Happy to add
you if you’ve helped in any way!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">CHANGELOG</a></h1>
<h2 id="v0048-unreleased"><a class="header" href="#v0048-unreleased">v0.0.48 [unreleased]</a></h2>
<ul>
<li><code>ryo3-json</code>
<ul>
<li><code>pybytes</code> bool kwargs to return <code>builtins.bytes</code> if <code>True</code> and <code>ry.Bytes</code> if
<code>False</code>; default is <code>False</code></li>
</ul>
</li>
<li><code>ryo3-serde</code>
<ul>
<li>support for types defined in <code>ryo3-http</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0047-2025-06-17"><a class="header" href="#v0047-2025-06-17">v0.0.47 [2025-06-17]</a></h2>
<ul>
<li>pyo3 v0.25.1</li>
<li><code>ryo3-serde</code> (wip)
<ul>
<li>serializers for <code>PyAny</code> and more</li>
<li>this should theoretically allow for serializing any python object that is
<code>serde</code> serializable with almost any <code>serde</code> serializer… that is the goal</li>
</ul>
</li>
<li><code>ryo3-json</code>
<ul>
<li>Where json stuff + ry is going to live in the near future (may consolodate
<code>ryo3-jiter</code> into this newer crate)</li>
<li><code>ry.stringify()</code> uses <code>ryo3-serde</code> + <code>serde_json</code> to write json bytes/bufs
and it is pretty fast, faster than ujson and rapidjson (not tested yyjson),
BUT orjson is still fastest (read a bunch of their code and it is remarkably
advanced and optimized)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0046-2025-06-06"><a class="header" href="#v0046-2025-06-06">v0.0.46 [2025-06-06]</a></h2>
<ul>
<li>version 0.0.46</li>
<li><code>ryo3-reqwest</code>
<ul>
<li><code>ResponseStream</code>
<ul>
<li>Added <code>__repr__</code> method</li>
<li>Added <code>async def take(self, n: int=1): ...</code> method returns n chunks as a
list</li>
<li>Added <code>async def collect(self: join = False) -&gt; ...:</code> method that collects
the stream into a single <code>ry.Bytes</code> object if <code>join=True</code> or a list of
<code>ry.Bytes</code> objects if <code>join=False</code></li>
<li>Added <code>async def take(self, n: int=1): ...</code> which returns n chunks as a
list</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>add <code>dtype</code> kwarg that takes either <code>dtype=str | ry.FsPath | pathlib.Path</code>
as type of obj yielded by the iterable; something about this feels really
icky, the default may be changed to <code>str</code> (from <code>pathlib.Path</code>)</li>
</ul>
</li>
<li><code>ryo3-ulid</code>
<ul>
<li>Added mostly as a way to test how much pydantic + ry integration would be</li>
</ul>
</li>
<li><code>ryo3-which</code>
<ul>
<li>upgrade which to version 8</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0045-2025-05-30"><a class="header" href="#v0045-2025-05-30">v0.0.45 [2025-05-30]</a></h2>
<ul>
<li>
<p>added <code>__target__</code> to python package metadata in <code>ry.__about__</code> with the
target triple of the current build</p>
</li>
<li>
<p><code>ryo3-std</code></p>
<ul>
<li>Buffering for <code>FileReadStream</code></li>
</ul>
</li>
<li>
<p><code>ryo3-jiter</code></p>
<ul>
<li>Add function <code>parse_jsonl</code> for parsing json lines</li>
<li>Add <code>lines</code> kwarg to <code>read_json</code> for parsing/reading json lines</li>
</ul>
</li>
<li>
<p><code>ryo3-jiff</code></p>
<ul>
<li>
<p><code>ZonedDateTime.__new__</code> takes more python-datetime like args/kwargs, old
version of constructor moved to classmethod
<code>ZonedDateTime.from_parts(timestamp: ry.Timestamp, tz: ry.TimeZone) -&gt; ZonedDateTime</code></p>
</li>
<li>
<p><code>zoned</code> top level function</p>
<ul>
<li>if <code>tz</code> is <code>None</code> then it uses the system timezone</li>
<li>SIGNATURE</li>
</ul>
<pre><code class="language-python">def zoned(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
    tz: str | None = None,
) -&gt; ZonedDateTime: ...
</code></pre>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0044-2025-05-23"><a class="header" href="#v0044-2025-05-23">v0.0.44 [2025-05-23]</a></h2>
<ul>
<li>internal:
<ul>
<li>renamed <code>ryo3-macros</code> to <code>ryo3-macro-rules</code></li>
</ul>
</li>
<li>docs
<ul>
<li>Cleaned up <code>./README.md</code></li>
<li>Removed type-annotations from <code>./README.md</code></li>
</ul>
</li>
<li>pyo3-v0.25.0</li>
<li>py-types
<ul>
<li>reqwest-request functions use <code>TypedDict</code> and <code>Unpack</code></li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>serde serialization features/support</li>
<li><code>ry.ZonedDateTime.replace</code> method mirroring <code>ZonedWith</code> – <code>with</code> is a
python keyword, so used <code>replace</code> instead</li>
<li>example script based on jiff-docs examples</li>
<li><code>test_jiff_examples_v2.py</code> test script (basis for example script)
<ul>
<li>Was tired/fried so I copy-pasta-ed the <code>ry/ryo3/_jiff.pyi</code> type
annotations, the jiff-v2-docs-examples, and the jiff-v1-hand-translated
<code>test_jiff_examples_v1.py</code> file into Chad-Gippity who was able to do most
of the translation from <code>rust</code> to <code>ry</code>…</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-xxhash</code>
<ul>
<li>Align with <code>xxhash</code> pypi library w/ respect to naming conventions</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0043-2025-05-17"><a class="header" href="#v0043-2025-05-17">v0.0.43 [2025-05-17]</a></h2>
<ul>
<li><code>ryo3-jiff</code>
<ul>
<li>panic-able functions to create new/altered (time)spans moved to use <code>try_*</code></li>
</ul>
</li>
<li>fix: anyio marker flat issue in pytests for cicd</li>
<li><code>ryo3-uuid</code>
<ul>
<li>added <code>uuid</code> wrapper for <code>uuid</code> crate; ty to the maintainers of <code>uuid-utils</code>
and <code>fastuuid</code> for helping figure out some of the nitty gritty bits and bobs</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>AsyncFile</code> and <code>aiopen</code> experiment(s) added for async file reading/writing
etc</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0042-2025-05-12"><a class="header" href="#v0042-2025-05-12">v0.0.42 [2025-05-12]</a></h2>
<ul>
<li>panic=abort
<ul>
<li>panic is now (maybe will go back) <code>abort</code> for release builds</li>
<li>means smaller binaries and faster error handling (in theory)</li>
</ul>
</li>
<li><code>ryo3-reqwest</code>
<ul>
<li>more type fixes to response</li>
<li>Got response type more inline with other python http-client libraries</li>
<li>try <code>parking_lot</code> for default <code>reqwest</code> client mutex</li>
<li>include missing kwargs for fetch functions</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>freeze struct(s) to be frozen</li>
</ul>
</li>
<li><code>ryo3-http</code>
<ul>
<li>http version python conversions to/from string/int</li>
<li>crude-ish serde implementation for <code>HeadersMap</code> for json
encoding/decoding… was a lot of googling</li>
<li>status code reason(s) interned</li>
<li>intern all standard http header-names</li>
</ul>
</li>
<li><code>ryo3-fnv</code>
<ul>
<li>align with hashlib style hashing</li>
</ul>
</li>
<li>deps-up
<ul>
<li>pyo3 version 0.24.2</li>
<li>brotli 8</li>
<li>jiff patch</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0041-2025-04-18"><a class="header" href="#v0041-2025-04-18">v0.0.41 [2025-04-18]</a></h2>
<ul>
<li><code>ryo3-jiter</code>
<ul>
<li>added <code>read_json</code> function to read from path-like obj</li>
</ul>
</li>
<li><code>ryo3-bytes</code>
<ul>
<li>misc small improvements and tests</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>ry.IpAddr</code> added to handle both ipv4/ipv6</li>
<li><code>ry.read_dir</code> implemented</li>
</ul>
</li>
<li><code>ryo3-walkdir</code>
<ul>
<li>added <code>objects</code> impl and example script</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>ry.read_dir_async</code> implemented; also contains fancy async take/collect</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0040-2025-04-11"><a class="header" href="#v0040-2025-04-11">v0.0.40 [2025-04-11]</a></h2>
<ul>
<li>scripts
<ul>
<li><code>dl_versions.py</code> script to download all versions of ry while ry is still
pre-1-point-oh and old version(s) are being nuked from pypi as needed</li>
</ul>
</li>
<li>types
<ul>
<li>fix types for few packages</li>
</ul>
</li>
<li>Updated several dependencies ~ most notably <code>pyo3</code> to <code>0.24.1</code></li>
<li>Fixed several new clippy lints that appear in CI stable rust builds</li>
<li><code>ryo3-std</code>
<ul>
<li><code>std::net</code> ipv4/ipv6 wrappers speed run impl</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0039-2025-03-14"><a class="header" href="#v0039-2025-03-14">v0.0.39 [2025-03-14]</a></h2>
<ul>
<li>internal
<ul>
<li>cleaned up several dependencies and features</li>
</ul>
</li>
<li><code>ryo3-zstd</code>
<ul>
<li>actually changed to use py buffer protocol this time… I dont know how it
got missed before…</li>
<li>re-factored a decent bit and made submodule with future plans to expand
encoding/decoding dictionary support</li>
<li>submodule is <code>ry.zstd</code> and/or <code>ry.ryo3.zstd</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0038-2025-03-13"><a class="header" href="#v0038-2025-03-13">v0.0.38 [2025-03-13]</a></h2>
<ul>
<li><code>ryo3-reqwest</code>
<ul>
<li>client configuration for pickling</li>
<li>allow buffer-protocol for <code>body</code> fetching methods (should add string maybe?)</li>
</ul>
</li>
<li><code>ryo3-walkdir</code>
<ul>
<li>Few more options added</li>
</ul>
</li>
<li><code>ryo3-glob</code>
<ul>
<li>new wrapper around <code>glob</code> crate</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li>Switched to use conversions from <code>jiff</code> feature of <code>pyo3-v24</code> as opposed to
hand-rolled conversions we had before</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0037-2025-03-11"><a class="header" href="#v0037-2025-03-11">v0.0.37 [2025-03-11]</a></h2>
<ul>
<li>pyo3 version <code>0.24.0</code></li>
<li><code>ryo3-which</code> functions return <code>pathlib.Path</code> now due to changes in pyo3-v24;
this may change in the near future…</li>
</ul>
<hr />
<h2 id="v0036-2025-03-11"><a class="header" href="#v0036-2025-03-11">v0.0.36 [2025-03-11]</a></h2>
<ul>
<li>dependencies updated</li>
<li>pickling support and tests for several types</li>
<li>bytes/buffer-protocol support for several sub-packages/packages:
<ul>
<li><code>ryo3-brotli</code></li>
<li><code>ryo3-bzip2</code></li>
<li><code>ryo3-flate2</code></li>
<li><code>ryo3-fnv</code></li>
<li><code>ryo3-xxhash</code></li>
<li><code>ryo3-zstd</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0035-2025-03-06"><a class="header" href="#v0035-2025-03-06">v0.0.35 [2025-03-06]</a></h2>
<ul>
<li>internal
<ul>
<li>types split up and cleaned up</li>
</ul>
</li>
<li><code>ryo3-size</code>
<ul>
<li><code>ry.Size</code> object</li>
</ul>
</li>
<li><code>ryo3-jiff</code>
<ul>
<li><code>series</code> iterators have <code>take</code> function that takes a <code>usize</code> returns a list
of size <code>usize</code></li>
<li>updated series types to be <code>JiffSeries</code> class</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0034-2025-02-28"><a class="header" href="#v0034-2025-02-28">v0.0.34 [2025-02-28]</a></h2>
<ul>
<li><code>ryo3-std</code>
<ul>
<li><code>fs</code>:
<ul>
<li><code>read_stream</code> function that returns an iterator of <code>ry.Bytes</code> objects from
a <code>PathLike</code> object</li>
<li>Several more fs functions added</li>
</ul>
</li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li>Several more tokio fs functions added</li>
</ul>
</li>
<li>internal
<ul>
<li>reorganized type annotations to be not a HUGE file…</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0033-2025-02-26"><a class="header" href="#v0033-2025-02-26">v0.0.33 [2025-02-26]</a></h2>
<ul>
<li>update to pyo3 v0.23.5</li>
</ul>
<hr />
<h2 id="v0032-2025-02-25"><a class="header" href="#v0032-2025-02-25">v0.0.32 [2025-02-25]</a></h2>
<ul>
<li><code>ryo3-jiter</code>
<ul>
<li>Allow <code>PyBytes</code> wrapper/buffer protocol to be given</li>
<li>renamed <code>jiter_cache_clear</code> to <code>json_cache_clear</code> and <code>jiter_cache_usage</code> to
<code>json_cache_usage</code></li>
<li>Removed <code>parse_json_str</code> just use <code>parse_json</code> with <code>str</code> input</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>Allow read/write to take <code>ry.Bytes</code> or <code>Bytes</code> objects</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0031-2025-02-21"><a class="header" href="#v0031-2025-02-21">v0.0.31 [2025-02-21]</a></h2>
<ul>
<li><code>ryo3-core</code>
<ul>
<li>got rid of <code>ryo3-types</code> and moved into <code>ryo3-core</code></li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>read_async</code> and <code>write_async</code> async functions</li>
</ul>
</li>
<li><code>ryo3-which</code>
<ul>
<li><code>which_re</code> functions accepts <code>ry.Regex</code> or <code>str</code> now</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>read</code> and <code>write</code> functions which take/return <code>ry.Bytes</code> objects</li>
</ul>
</li>
<li><code>internal</code>
<ul>
<li>Changed many many many of the structs/classes to be pyo3 <code>frozen</code> behaviour
should not be different</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0030-2025-02-18"><a class="header" href="#v0030-2025-02-18">v0.0.30 [2025-02-18]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Upgraded jiff to version 2</li>
</ul>
</li>
<li>internal
<ul>
<li>Switch all lints from <code>#[allow(...)]</code>/<code>#![allow(...)]</code> to
<code>#[expect(...)]</code>/<code>#![expect(...)]</code></li>
<li>Removed a bunch o commented out code</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>added several <code>std::fs</code> structs</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>conversion to <code>pathlib.Path</code> by way of <code>FsPath.to_pathlib()</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0029-2025-02-03"><a class="header" href="#v0029-2025-02-03">v0.0.29 [2025-02-03]</a></h2>
<ul>
<li>internal
<ul>
<li>Made sure each <code>ryo3-*</code> crate has a <code>README.md</code></li>
</ul>
</li>
<li><code>ryo3-bytes</code> &amp; <code>ryo3-fspath</code>
<ul>
<li>added <code>__hash__</code> dunders to both <code>Bytes</code> and <code>FsPath</code> structs</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0028-2025-01-31"><a class="header" href="#v0028-2025-01-31">v0.0.28 [2025-01-31]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Per Mr. Sushi’s thoughts changed all <code>until</code>/<code>since</code> methods to use kwargs
instead of the rust-like tuples that impl <code>From</code>/<code>Into</code> as it does not
translate well to python</li>
<li>Gets rid of the following inane types:</li>
</ul>
</li>
</ul>
<pre><code class="language-python">IntoDateDifference = (
  DateDifference
  | Date
  | DateTime
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Date]
  | tuple[JIFF_UNIT_STRING, DateTime]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimeDifference = (
  TimeDifference
  | Time
  | DateTime
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Time]
  | tuple[JIFF_UNIT_STRING, DateTime]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoDateTimeDifference = (
  DateTimeDifference
  | Date
  | Time
  | DateTime
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Date]
  | tuple[JIFF_UNIT_STRING, Time]
  | tuple[JIFF_UNIT_STRING, DateTime]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimestampDifference = (
  TimestampDifference
  | Timestamp
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Timestamp]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
</code></pre>
<hr />
<h2 id="v0027-2025-01-23"><a class="header" href="#v0027-2025-01-23">v0.0.27 [2025-01-23]</a></h2>
<ul>
<li><code>ry</code>
<ul>
<li>Warning on <code>debug</code> build</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>headers-property response returns <code>Headers</code> object instead of python dict</li>
</ul>
</li>
<li><code>same-file</code>
<ul>
<li>wrapper module added with <code>is_same_file</code> py-fn (yet another piece of burnt
sushi)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>jiff-version <code>0.1.25</code> ~ add <code>in_tz</code> methods and point old <code>intz</code> at new
<code>in_tz</code> methods and raise <code>DeprecationWarning</code> for old <code>intz</code> methods</li>
<li>Continued adding implementations that previously raised
<code>NotImplementedError</code>
<ul>
<li><code>Date.nth_weekday_of_month</code></li>
<li><code>Date.nth_weekday</code></li>
<li><code>DateTime.nth_weekday_of_month</code></li>
<li><code>DateTime.nth_weekday</code></li>
<li><code>TimeSpan.compare</code></li>
<li><code>TimeSpan.total</code></li>
<li><code>ZonedDateTime.nth_weekday_of_month</code></li>
<li><code>ZonedDateTime.nth_weekday</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0026-2025-01-13"><a class="header" href="#v0026-2025-01-13">v0.0.26 [2025-01-13]</a></h2>
<ul>
<li><code>reqwest</code>
<ul>
<li><code>AsyncClient</code> renamed to <code>HttpClient</code></li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>human timespan strings for <code>TimeSpan</code> and <code>SignedDuration</code> objects:
<ul>
<li><code>ry.TimeSpan.parse("P2M10DT2H30M").string(human=True) == "2mo 10d 2h 30m"</code></li>
<li><code>ry.SignedDuration.parse("PT2H30M").string(human=True) == "2h 30m"</code></li>
</ul>
</li>
</ul>
</li>
<li>internal
<ul>
<li>workspace-ified all the deps</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0025-2024-01-07-25-for-2025"><a class="header" href="#v0025-2024-01-07-25-for-2025">v0.0.25 [2024-01-07] (25 for 2025)</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Updated to <code>0.1.21</code> which has span and signed duration strings with capital
letters</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0024-2024-12-24-the-night-b4-xmas"><a class="header" href="#v0024-2024-12-24-the-night-b4-xmas">v0.0.24 [2024-12-24] (the night b4 xmas…)</a></h2>
<ul>
<li><code>http</code>
<ul>
<li>basic headers struct/obj – WIP</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>reqwest client (currently root-export)</li>
<li>default client + root <code>fetch</code> function likely needs work…</li>
<li>response <code>byte_stream</code>!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0023-2024-12-19"><a class="header" href="#v0023-2024-12-19">v0.0.23 [2024-12-19]</a></h2>
<ul>
<li><code>python -m ry.dev</code> repl for ipython/python repl ~ handy nifty secret tool
makes it into repo</li>
<li>internal
<ul>
<li>in process of renaming all python-rust <code>#[new]</code> functions to be named
<code>fn py_new(...)</code></li>
</ul>
</li>
<li><code>unindent</code>
<ul>
<li>Added <code>unindent</code> module for unindenting strings will move to <code>ryo3-unindent</code></li>
</ul>
</li>
<li><code>FsPath</code>
<ul>
<li>creeping ever closer to being a full-fledged pathlib.Path replacement</li>
<li>Added bindings to all rust <code>std::path::Path(buf)</code> methods for <code>FsPath</code></li>
</ul>
</li>
<li>sub-packaging
<ul>
<li><code>xxhash</code> is own sub package now <code>ry.xxhash</code></li>
<li><code>JSON</code> is own subpackage right now – named <code>ry.JSON</code> to avoid conflict with
<code>json</code> module but maybe will change…</li>
<li>food-for-thought-ing how <code>ryo3</code> and <code>ry</code> should be organized w/ respsect to
sub-packages and where that organization should be</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>required to break up the type annotations due to migration to sub-packages</li>
<li>breaking up the type annotations file into smaller files under
<code>&lt;REPO&gt;/python/ry/ryo3/*.pyi</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0022-2024-12-16"><a class="header" href="#v0022-2024-12-16">v0.0.22 [2024-12-16]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Super simple regex wrapper (must to do here, but was added for
<code>ryo3-which::which_re</code>)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li><code>until</code>/<code>since</code>
<ul>
<li>Basic <code>until</code>/<code>since</code> implementation but I do not like them and they
confusingly named <code>*Difference</code> structs/py-objects, so I may change how
they work…</li>
</ul>
</li>
<li><code>jiff</code> seems to be about as performant as <code>whenever</code> ~ yay! also the
whenever dude appears to be watching this repo (as of 2024-12-16)</li>
</ul>
</li>
<li><code>walkdir</code>
<ul>
<li><code>collect</code> added to <code>WalkdirGen</code> to collect the results into a list</li>
</ul>
</li>
<li>deps
<ul>
<li><code>thiserror</code> version <code>2.0.7</code> -&gt; <code>2.0.8</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0021-2024-12-13-friday-the-13th-spoogidy-oogidity"><a class="header" href="#v0021-2024-12-13-friday-the-13th-spoogidy-oogidity">v0.0.21 [2024-12-13] (friday the 13th… spoogidy oogidity)</a></h2>
<ul>
<li><code>walkdir</code>
<ul>
<li>add <code>glob</code> kwarg that takes a <code>ry.Glob</code> or <code>ry.GlobSet</code> or <code>ry.Globster</code> obj
to filter the walk on</li>
</ul>
</li>
<li><code>globset</code>
<ul>
<li>Internal refactoring</li>
<li>added <code>globster()</code> method to <code>ry.Glob</code> and <code>ry.GlobSet</code> to return a
<code>ry.Globster</code> obj</li>
<li>added <code>globset()</code> method to <code>ry.Glob</code> to return a <code>ry.GlobSet</code> obj from a
<code>ry.Glob</code> obj</li>
</ul>
</li>
<li><code>url</code>
<ul>
<li>python <code>Url</code> changed name <code>URL</code>; aligns with jawascript and other python
libs</li>
</ul>
</li>
<li><code>bzip2</code>
<ul>
<li>update to v5</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>conversions for jiff-round-mode/unit/weekday</li>
<li>not-implemented placeholders and new impls
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDateTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDate</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyOffset</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySignedDuration</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySpan</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTimeZone</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyZoned</code></li>
</ul>
</li>
<li>span builder functions use form <code>s._hours(1)</code> for panic-inducing building,
and <code>s.try_hours(1)</code> for non-panic-inducing building</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>fixes and updates and a hacky script I wrote to check for discrepancies</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0020-2024-12-10"><a class="header" href="#v0020-2024-12-10">v0.0.20 [2024-12-10]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Templated out regex package but nothing added</li>
</ul>
</li>
<li><code>ry</code>
<ul>
<li>python 3.13 yay!</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated jiter version thanks depbot!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0019-2024-12-05"><a class="header" href="#v0019-2024-12-05">v0.0.19 [2024-12-05]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>py-conversions
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDateTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDate</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffOffset</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSignedDuration</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSpan</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTimeZone</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffZoned</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0018-2024-12-03"><a class="header" href="#v0018-2024-12-03">v0.0.18 [2024-12-03]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Renamed <code>ry.Span</code> to <code>ry.TimeSpan</code></li>
<li>Renamed <code>ry.Zoned</code> to <code>ry.ZonedDateTime</code></li>
<li>Updated type stubs to reflect renames</li>
</ul>
</li>
<li>docs
<ul>
<li>init-ed the docs</li>
<li>style guide under <code>DEVELOPMENT.md</code> file</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0017-2024-12-02"><a class="header" href="#v0017-2024-12-02">v0.0.17 [2024-12-02]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li><code>ry.TimeZone</code> testing and to/from <code>datetime.tzinfo</code> conversions</li>
<li>Using nu-types for <code>jiff</code> intermediate types bc of the classic orphans
problem (aka batman) w/ traits</li>
<li>hypothesis tests</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated to <code>jiter</code> v0.8.1</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0016-2024-11-29"><a class="header" href="#v0016-2024-11-29">v0.0.16 [2024-11-29]</a></h2>
<ul>
<li>Moved walkdir to <code>ryo3-walkdir</code></li>
<li>added <code>ryo3-types</code> for custom and shared types</li>
<li><code>heck</code> wrapper(s)</li>
<li>jiff
<ul>
<li>Added operators <code>+</code>/<code>+=</code>/<code>-</code>/<code>-=</code> to date/time/datetime/etc</li>
<li>TODO: figure out how to take refs in the union enum for the operators</li>
</ul>
</li>
<li>fspath
<ul>
<li>further beefing out as well as testing</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0015-2024-11-20"><a class="header" href="#v0015-2024-11-20">v0.0.15 [2024-11-20]</a></h2>
<ul>
<li><code>from __future__ import annotations</code> added to all modules</li>
<li>cicd updated to include more targets</li>
</ul>
<hr />
<h2 id="v0014-2024-11-20"><a class="header" href="#v0014-2024-11-20">v0.0.14 [2024-11-20]</a></h2>
<ul>
<li>Primitive/crude wrappers around Mr. Sushi’s <code>jiff</code> library</li>
<li>Updated to use pyo3 (had to use jiter git repo dep)</li>
<li><code>ry.FsPath</code> beefed out</li>
<li>Added iterdir gen wrapper</li>
<li>(todo undo when jiter + pyo3 23 is public)</li>
</ul>
<hr />
<h2 id="v0013-2024-11-20"><a class="header" href="#v0013-2024-11-20">v0.0.13 [2024-11-20]</a></h2>
<ul>
<li><strong>VERSION SKIPPED DUE TO <code>13</code> BEING SPOOKY AND ME BEING MODERATELY-STITCHOUS
(AKA fully ‘superstitchous’)</strong></li>
</ul>
<hr />
<h2 id="v0012-2024-11-14"><a class="header" href="#v0012-2024-11-14">v0.0.12 [2024-11-14]</a></h2>
<ul>
<li>sqlformat wrapper(s) (this is the first <code>ryo3-*</code> sub-crate)</li>
</ul>
<hr />
<h2 id="v0011-2024-09-22"><a class="header" href="#v0011-2024-09-22">v0.0.11 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
<li>prepare for python 3.13</li>
</ul>
<hr />
<h2 id="v0010-2024-09-22"><a class="header" href="#v0010-2024-09-22">v0.0.10 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
</ul>
<hr />
<h2 id="v009-2024-08-22"><a class="header" href="#v009-2024-08-22">v0.0.9 [2024-08-22]</a></h2>
<ul>
<li>Added <code>globset</code> wrapper(s)</li>
<li>Added <code>__init__.py</code> generator</li>
</ul>
<hr />
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<h2 id="v008-2024-06-25"><a class="header" href="#v008-2024-06-25">v0.0.8 [2024-06-25]</a></h2>
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<hr />
<h2 id="v007-2024-06-08"><a class="header" href="#v007-2024-06-08">v0.0.7 [2024-06-08]</a></h2>
<ul>
<li>internal refactoring</li>
</ul>
<hr />
<h2 id="v006-2024-06-05"><a class="header" href="#v006-2024-06-05">v0.0.6 [2024-06-05]</a></h2>
<ul>
<li>Added zstd (<code>zstd_encode</code>/<code>zstd</code> and <code>zstd_decode</code>)</li>
<li>Added gzip (<code>gzip_encode</code>/<code>gzip</code> and <code>gzip_decode</code>/<code>gunzip</code>)</li>
<li>Added bzip2 (<code>bzip2_encode</code>/<code>bzip2</code> and <code>bzip2_decode</code>)</li>
<li>Added walkdir</li>
<li>Reorg libs</li>
</ul>
<hr />
<h2 id="v005-2024-04-19"><a class="header" href="#v005-2024-04-19">v0.0.5 [2024-04-19]</a></h2>
<ul>
<li>Added brotli (<code>brotli_encode</code> and <code>brotli_decode</code>)</li>
<li>xxhash
<ul>
<li>const functions</li>
<li>hasher streaming objects</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fspath"><a class="header" href="#fspath">fspath</a></h1>
<pre><code class="language-python">import ry

# get current directory
current_dir = ry.FsPath.cwd()

# write file
(current_dir / "test.txt").write_text("data!")

# read file
data = (current_dir / "test.txt").read_text()
print(data)

</code></pre>
<h1 id="http_fetch"><a class="header" href="#http_fetch">http_fetch</a></h1>
<pre><code class="language-python">"""Example of using the `ry.fetch` function to make http requests

The stuff at the top of this file is a simple http server for example purposes
"""

from __future__ import annotations

import asyncio
import json
from http.server import BaseHTTPRequestHandler, HTTPServer
from threading import Thread

# =============================================================================
import ry


def _print_break() -&gt; None:
    print("\n" + "=" * 79 + "\n")


async def main(server_url: str = "http://127.0.0.1:8000") -&gt; None:
    # -------------------------------------------------------------------------
    # GET
    # -------------------------------------------------------------------------
    _print_break()
    response = await ry.fetch(server_url)
    print("Raw response:", response)
    json_data = await response.json()
    print("JSON data:\n", json.dumps(json_data, indent=2))

    # **THE RESPONSE HAS BEEN CONSUMED**
    # No you cannot get the json again.... You are responsible for storing
    # The response has been consumed. This is how http requests really work.
    # Libraries like requests, httpx, aiohttp, etc. store the response data
    # in memory so you can access it multiple times, ry mirrors how fetch
    # works in reqwest which is also kinda how fetch works in
    # jawascript/interface-script.
    try:
        _json_data = await response.json()
    except ValueError as e:
        print("Error:", e)

    # -------------------------------------------------------------------------
    # POST
    # -------------------------------------------------------------------------
    _print_break()
    post_response = await ry.fetch(
        server_url, method="POST", body=b"post post post... dumb as a post"
    )
    print("Raw post response:", post_response)
    post_response_data = await post_response.json()
    print("JSON post response:\n", json.dumps(post_response_data, indent=2))

    # -------------------------------------------------------------------------
    # STREAMING
    # -------------------------------------------------------------------------
    _print_break()
    long_body = "\n".join([f"dingo{i}" for i in range(1000)]).encode()
    response = await ry.fetch(server_url, method="POST", body=long_body)

    async for chunk in response.bytes_stream():
        assert isinstance(chunk, ry.Bytes)  # tis a bytes
        py_bytes = bytes(chunk)
        assert isinstance(py_bytes, bytes)
        assert py_bytes == chunk
        print("chunk this! len =:", len(chunk))


# -----------------------------------------------------------------------------
# HTTP SERVER THAT DOES SUPER SIMPLE JSON RESPONSES
# -----------------------------------------------------------------------------
class HTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self) -&gt; None:
        self.send_response(200)
        self.send_header("Content-type", "application/json")
        self.end_headers()
        res_data = {
            "path": self.path,
            "method": "GET",
            "data": {
                "dog": "dingo",
                "oreo": "mcflurry",
            },
        }
        res_bytes = json.dumps(res_data).encode()
        self.wfile.write(res_bytes)

    def do_POST(self) -&gt; None:
        self.send_response(200)
        self.send_header("Content-type", "application/json")
        self.end_headers()
        body = self.rfile.read(int(self.headers["Content-Length"]))

        res_data = {
            "path": self.path,
            "method": "POST",
            "body": body.decode(),
            "data": {
                "dog": "dingo",
                "oreo": "mcflurry",
            },
        }
        res_bytes = json.dumps(res_data).encode()
        self.wfile.write(res_bytes)


def start_server(
    host: str = "127.0.0.1", port: int = 8888, logging: bool = False
) -&gt; HTTPServer:
    class HttpRequestHandlerNoLog(HTTPRequestHandler):
        def log_message(self, format, *args):  # type: ignore[no-untyped-def]
            ...

    server_address = (host, port)
    handler = HttpRequestHandlerNoLog if not logging else HTTPRequestHandler
    httpd = HTTPServer(server_address, handler)
    Thread(target=httpd.serve_forever, daemon=True).start()
    return httpd


if __name__ == "__main__":
    server = start_server(logging=True)
    try:
        asyncio.run(
            main(server_url=f"http://{server.server_name}:{server.server_port}")
        )
    except KeyboardInterrupt:
        print("KeyboardInterrupt")
    finally:
        server.shutdown()

</code></pre>
<h1 id="jiff_examples"><a class="header" href="#jiff_examples">jiff_examples</a></h1>
<pre><code class="language-python">"""Jiff examples (v2)

Translated jiff-examples from jiff-v2's docs

REF: https://docs.rs/jiff/latest/jiff/#examples
DATE: 2025-05-23
"""

from __future__ import annotations

import json
from dataclasses import dataclass

import ry


def test_get_current_time_in_system_tz() -&gt; None:
    now = ry.ZonedDateTime.now()
    assert isinstance(now, ry.ZonedDateTime)
    assert now.tz.name


def test_print_current_time_rounded_to_second() -&gt; None:
    rounded = ry.ZonedDateTime.now().round("second")
    # nanoseconds should be zero after rounding to second
    assert rounded.nanosecond == 0


def test_print_todays_date_at_specific_time() -&gt; None:
    zdt = ry.ZonedDateTime.now().replace(
        hour=14, minute=0, second=0, nanosecond=0
    )
    assert zdt.hour == 14 and zdt.minute == 0 and zdt.second == 0
    assert zdt.nanosecond == 0


def test_print_current_unix_timestamp() -&gt; None:
    ts = ry.Timestamp.now()
    sec = ts.as_second()
    ns = ts.as_nanosecond()
    assert isinstance(sec, int) and sec &gt; 1_600_000_000
    # nanosecond count divided by 1e9 should equal seconds
    assert ns // 1_000_000_000 == sec


def test_print_datetime_for_a_timestamp() -&gt; None:
    ts = ry.Timestamp.from_millisecond(1_720_646_365_567)
    zdt = ts.to_zoned(ry.TimeZone("America/New_York"))
    assert zdt.string() == "2024-07-10T17:19:25.567-04:00[America/New_York]"
    assert ts.string() == "2024-07-10T21:19:25.567Z"


def test_create_zoned_datetime_from_civil_time() -&gt; None:
    zdt = ry.date(2023, 12, 31).at(18, 30, 0, 0).in_tz("America/New_York")
    assert zdt.string() == "2023-12-31T18:30:00-05:00[America/New_York]"


def test_change_an_instant_from_one_timezone_to_another() -&gt; None:
    paris = ry.date(1918, 11, 11).at(11, 0, 0, 0).in_tz("Europe/Paris")
    nyc = paris.in_tz("America/New_York")
    assert nyc.string() == "1918-11-11T06:00:00-05:00[America/New_York]"


def test_find_duration_between_two_zoned_datetimes() -&gt; None:
    a = ry.date(2020, 8, 26).at(6, 27, 0, 0).in_tz("America/New_York")
    b = ry.date(2023, 12, 31).at(18, 30, 0, 0).in_tz("America/New_York")
    span = b - a
    assert str(span) == "PT29341H3M"
    # until: specify largest unit via helper
    span2 = a.until(b, largest="year")
    assert str(span2) == "P3Y4M5DT12H3M"


def test_add_duration_to_a_zoned_datetime() -&gt; None:
    start = ry.date(2020, 8, 26).at(6, 27, 0, 0).in_tz("America/New_York")
    span = ry.TimeSpan()._years(3)._months(4)._days(5)._hours(12)._minutes(3)
    finish = start.checked_add(span)
    assert finish.string() == "2023-12-31T18:30:00-05:00[America/New_York]"


def test_dealing_with_ambiguity() -&gt; None:
    gap = ry.date(2024, 3, 10).at(2, 30, 0, 0).in_tz("America/New_York")
    assert gap.string() == "2024-03-10T03:30:00-04:00[America/New_York]"

    fold = ry.date(2024, 11, 3).at(1, 30, 0, 0).in_tz("America/New_York")
    assert fold.string() == "2024-11-03T01:30:00-04:00[America/New_York]"


def test_parsing_a_span() -&gt; None:
    iso = ry.TimeSpan.parse("P5y1w10dT5h59m")
    expected = (
        ry.TimeSpan()._years(5)._weeks(1)._days(10)._hours(5)._minutes(59)
    )
    assert iso == expected
    assert str(iso) == "P5Y1W10DT5H59M"

    friendly = ry.TimeSpan.parse(
        "5 years, 1 week, 10 days, 5 hours, 59 minutes"
    )
    assert iso == friendly
    assert friendly.string(human=True) == "5y 1w 10d 5h 59m"
    assert str(friendly) == "P5Y1W10DT5H59M"


def test_parsing_an_rfc2822_datetime_string() -&gt; None:
    base = ry.ZonedDateTime.parse_rfc2822("Thu, 29 Feb 2024 05:34 -0500")
    tas = base.in_tz("Australia/Tasmania")
    kol = base.in_tz("Asia/Kolkata")
    assert tas.format_rfc2822() == "Thu, 29 Feb 2024 21:34:00 +1100"
    assert kol.format_rfc2822() == "Thu, 29 Feb 2024 16:04:00 +0530"


def test_using_strftime_and_strptime() -&gt; None:
    zdt = ry.ZonedDateTime.strptime(
        "%A, %B %d, %Y at %I:%M%p %Q",
        "Monday, July 15, 2024 at 5:30pm US/Eastern",
    )
    assert zdt.string() == "2024-07-15T17:30:00-04:00[US/Eastern]"

    tas = ry.date(2024, 7, 15).at(17, 30, 59, 0).in_tz("Australia/Tasmania")
    formatted = tas.strftime("%A, %B %d, %Y at %-I:%M%P %Q")
    assert formatted == "Monday, July 15, 2024 at 5:30pm Australia/Tasmania"


@dataclass
class Record:
    timestamp: ry.Timestamp

    def to_json(self) -&gt; str:
        return json.dumps({"timestamp": self.timestamp.as_second()})

    @classmethod
    def from_json(cls, raw: str) -&gt; Record:
        data = json.loads(raw)
        return cls(timestamp=ry.Timestamp.from_second(data["timestamp"]))


def test_serializing_and_deserializing_integer_timestamps() -&gt; None:
    src = Record(timestamp=ry.Timestamp.from_second(1_517_644_800))
    wire = src.to_json()
    got = Record.from_json(wire)
    assert got.timestamp == src.timestamp
    assert wire == '{"timestamp": 1517644800}'


def main() -&gt; None:
    test_get_current_time_in_system_tz()
    test_print_current_time_rounded_to_second()
    test_print_todays_date_at_specific_time()
    test_print_current_unix_timestamp()
    test_print_datetime_for_a_timestamp()
    test_create_zoned_datetime_from_civil_time()
    test_change_an_instant_from_one_timezone_to_another()
    test_find_duration_between_two_zoned_datetimes()
    test_add_duration_to_a_zoned_datetime()
    test_dealing_with_ambiguity()
    test_parsing_a_span()
    test_parsing_an_rfc2822_datetime_string()
    test_using_strftime_and_strptime()
    test_serializing_and_deserializing_integer_timestamps()


if __name__ == "__main__":
    main()

</code></pre>
<h1 id="walking"><a class="header" href="#walking">walking</a></h1>
<pre><code class="language-python">"""
ry.walkdir example
"""

from __future__ import annotations

import os

import ry

PWD = os.path.dirname(os.path.abspath(__file__))


def _print_br(s: str | None = None) -&gt; None:
    print("_" * 79)
    if s:
        print(s)


def main() -&gt; None:
    dir2walk = PWD

    _print_br("Walking the directory tree")
    # Walking the directory tree
    for filepath in ry.walkdir(dir2walk):
        print(filepath)

    _print_br("Walking the directory tree with entries")
    # Walking the directory tree
    for direntry in ry.walkdir(dir2walk, objects=True):
        print(direntry, type(direntry))

    _print_br("Walking the directory tree with depth 1")
    # walking only files
    for filepath in ry.walkdir(dir2walk, dirs=False):
        print(filepath)
        assert ry.FsPath(filepath).is_file()

    # walking only directories
    for filepath in ry.walkdir(dir2walk, files=False):
        print(filepath)
        assert ry.FsPath(filepath).is_dir()

    # globset/globster
    for filepath in ry.walkdir(
        dir2walk,
        glob=ry.globster(
            [
                "*.py",
            ]
        ),
    ):
        assert filepath.endswith(".py")


if __name__ == "__main__":
    main()

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="api.html#ry.ryo3.__init__"><code>ry.ryo3.__init__</code></a></li>
<li><a href="api.html#ry.ryo3.errors"><code>ry.ryo3.errors</code></a></li>
<li><a href="api.html#ry.ryo3.JSON"><code>ry.ryo3.JSON</code></a></li>
<li><a href="api.html#ry.ryo3.sh"><code>ry.ryo3.sh</code></a></li>
<li><a href="api.html#ry.ryo3._brotli"><code>ry.ryo3._brotli</code></a></li>
<li><a href="api.html#ry.ryo3._bytes"><code>ry.ryo3._bytes</code></a></li>
<li><a href="api.html#ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></a></li>
<li><a href="api.html#ry.ryo3._dev"><code>ry.ryo3._dev</code></a></li>
<li><a href="api.html#ry.ryo3._flate2"><code>ry.ryo3._flate2</code></a></li>
<li><a href="api.html#ry.ryo3._fnv"><code>ry.ryo3._fnv</code></a></li>
<li><a href="api.html#ry.ryo3._fspath"><code>ry.ryo3._fspath</code></a></li>
<li><a href="api.html#ry.ryo3._glob"><code>ry.ryo3._glob</code></a></li>
<li><a href="api.html#ry.ryo3._globset"><code>ry.ryo3._globset</code></a></li>
<li><a href="api.html#ry.ryo3._heck"><code>ry.ryo3._heck</code></a></li>
<li><a href="api.html#ry.ryo3._jiff"><code>ry.ryo3._jiff</code></a></li>
<li><a href="api.html#ry.ryo3._jiter"><code>ry.ryo3._jiter</code></a></li>
<li><a href="api.html#ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></a></li>
<li><a href="api.html#ry.ryo3._regex"><code>ry.ryo3._regex</code></a></li>
<li><a href="api.html#ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></a></li>
<li><a href="api.html#ry.ryo3._same_file"><code>ry.ryo3._same_file</code></a></li>
<li><a href="api.html#ry.ryo3._shlex"><code>ry.ryo3._shlex</code></a></li>
<li><a href="api.html#ry.ryo3._size"><code>ry.ryo3._size</code></a></li>
<li><a href="api.html#ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></a></li>
<li><a href="api.html#ry.ryo3._std"><code>ry.ryo3._std</code></a></li>
<li><a href="api.html#ry.ryo3._tokio"><code>ry.ryo3._tokio</code></a></li>
<li><a href="api.html#ry.ryo3._unindent"><code>ry.ryo3._unindent</code></a></li>
<li><a href="api.html#ry.ryo3._url"><code>ry.ryo3._url</code></a></li>
<li><a href="api.html#ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></a></li>
<li><a href="api.html#ry.ryo3._which"><code>ry.ryo3._which</code></a></li>
<li><a href="api.html#ry.dirs"><code>ry.dirs</code></a></li>
<li><a href="api.html#ry.http"><code>ry.http</code></a></li>
<li><a href="api.html#ry.ulid"><code>ry.ulid</code></a></li>
<li><a href="api.html#ry.uuid"><code>ry.uuid</code></a></li>
<li><a href="api.html#ry.xxhash"><code>ry.xxhash</code></a></li>
<li><a href="api.html#ry.zstd"><code>ry.zstd</code></a></li>
</ul>
<h2 id="ry.ryo3.__init__"><a class="header" href="#ry.ryo3.__init__"><code>ry.ryo3.__init__</code></a></h2>
<pre><code class="language-python">"""ry api ~ type annotations"""

from ry import dirs as dirs  # noqa: RUF100
from ry import http as http  # noqa: RUF100
from ry import ulid as ulid  # noqa: RUF100
from ry import uuid as uuid  # noqa: RUF100
from ry import xxhash as xxhash  # noqa: RUF100
from ry import zstd as zstd  # noqa: RUF100
from ry._types import Buffer as Buffer  # noqa: RUF100
from ry.http import Headers as Headers  # noqa: RUF100
from ry.http import HttpStatus as HttpStatus  # noqa: RUF100
from ry.zstd import is_zstd as is_zstd
from ry.zstd import zstd_compress as zstd_compress
from ry.zstd import zstd_decode as zstd_decode
from ry.zstd import zstd_decompress as zstd_decompress
from ry.zstd import zstd_encode as zstd_encode
from ._brotli import brotli as brotli
from ._brotli import brotli_decode as brotli_decode
from ._brotli import brotli_encode as brotli_encode
from ._bytes import Bytes as Bytes
from ._bzip2 import bzip2 as bzip2
from ._bzip2 import bzip2_decode as bzip2_decode
from ._bzip2 import bzip2_encode as bzip2_encode
from ._flate2 import gunzip as gunzip
from ._flate2 import gzip as gzip
from ._flate2 import gzip_decode as gzip_decode
from ._flate2 import gzip_encode as gzip_encode
from ._flate2 import is_gzipped as is_gzipped
from ._fnv import FnvHasher as FnvHasher
from ._fnv import fnv1a as fnv1a
from ._fspath import FsPath as FsPath
from ._glob import Pattern as Pattern
from ._glob import glob as glob
from ._globset import Glob as Glob
from ._globset import GlobSet as GlobSet
from ._globset import Globster as Globster
from ._globset import globster as globster
from ._heck import camel_case as camel_case
from ._heck import kebab_case as kebab_case
from ._heck import pascal_case as pascal_case
from ._heck import shouty_kebab_case as shouty_kebab_case
from ._heck import shouty_snake_case as shouty_snake_case
from ._heck import snake_case as snake_case
from ._heck import snek_case as snek_case
from ._heck import title_case as title_case
from ._heck import train_case as train_case
from ._jiff import Date as Date
from ._jiff import DateDifference as DateDifference
from ._jiff import DateTime as DateTime
from ._jiff import DateTimeDifference as DateTimeDifference
from ._jiff import DateTimeRound as DateTimeRound
from ._jiff import ISOWeekDate as ISOWeekDate
from ._jiff import Offset as Offset
from ._jiff import SignedDuration as SignedDuration
from ._jiff import Time as Time
from ._jiff import TimeDifference as TimeDifference
from ._jiff import TimeSpan as TimeSpan
from ._jiff import Timestamp as Timestamp
from ._jiff import TimestampDifference as TimestampDifference
from ._jiff import TimestampRound as TimestampRound
from ._jiff import TimeZone as TimeZone
from ._jiff import TimeZoneDatabase as TimeZoneDatabase
from ._jiff import ZonedDateTime as ZonedDateTime
from ._jiff import ZonedDateTimeDifference as ZonedDateTimeDifference
from ._jiff import ZonedDateTimeRound as ZonedDateTimeRound
from ._jiff import date as date
from ._jiff import datetime as datetime
from ._jiff import offset as offset
from ._jiff import time as time
from ._jiff import timespan as timespan
from ._jiff import zoned as zoned
from ._jiter import JsonParseKwargs as JsonParseKwargs
from ._jiter import JsonPrimitive as JsonPrimitive
from ._jiter import JsonValue as JsonValue
from ._jiter import json_cache_clear as json_cache_clear
from ._jiter import json_cache_usage as json_cache_usage
from ._jiter import parse_json as parse_json
from ._jiter import parse_json_bytes as parse_json_bytes
from ._jiter import parse_jsonl as parse_jsonl
from ._jiter import read_json as read_json
from ._quick_maths import quick_maths as quick_maths
from ._regex import Regex as Regex
from ._reqwest import HttpClient as HttpClient
from ._reqwest import ReqwestError as ReqwestError
from ._reqwest import Response as Response
from ._reqwest import ResponseStream as ResponseStream
from ._reqwest import fetch as fetch
from ._same_file import is_same_file as is_same_file
from ._shlex import shplit as shplit
from ._size import Size as Size
from ._size import SizeFormatter as SizeFormatter
from ._size import fmt_size as fmt_size
from ._size import parse_size as parse_size
from ._sqlformat import SqlfmtQueryParams as SqlfmtQueryParams
from ._sqlformat import sqlfmt as sqlfmt
from ._sqlformat import sqlfmt_params as sqlfmt_params
from ._std import Duration as Duration
from ._std import FileReadStream as FileReadStream
from ._std import FileType as FileType
from ._std import Instant as Instant
from ._std import IpAddr as IpAddr
from ._std import Ipv4Addr as Ipv4Addr
from ._std import Ipv6Addr as Ipv6Addr
from ._std import Metadata as Metadata
from ._std import canonicalize as canonicalize
from ._std import copy as copy
from ._std import create_dir as create_dir
from ._std import create_dir_all as create_dir_all
from ._std import exists as exists
from ._std import instant as instant
from ._std import is_dir as is_dir
from ._std import is_file as is_file
from ._std import is_symlink as is_symlink
from ._std import metadata as metadata
from ._std import read as read
from ._std import read_bytes as read_bytes
from ._std import read_dir as read_dir
from ._std import read_stream as read_stream
from ._std import read_text as read_text
from ._std import remove_dir as remove_dir
from ._std import remove_dir_all as remove_dir_all
from ._std import remove_file as remove_file
from ._std import rename as rename
from ._std import sleep as sleep
from ._std import write as write
from ._std import write_bytes as write_bytes
from ._std import write_text as write_text
from ._tokio import AsyncFile as AsyncFile
from ._tokio import aiopen as aiopen
from ._tokio import asleep as asleep
from ._tokio import canonicalize_async as canonicalize_async
from ._tokio import copy_async as copy_async
from ._tokio import create_dir_all_async as create_dir_all_async
from ._tokio import create_dir_async as create_dir_async
from ._tokio import exists_async as exists_async
from ._tokio import hard_link_async as hard_link_async
from ._tokio import metadata_async as metadata_async
from ._tokio import read_async as read_async
from ._tokio import read_dir_async as read_dir_async
from ._tokio import read_link_async as read_link_async
from ._tokio import read_to_string_async as read_to_string_async
from ._tokio import remove_dir_all_async as remove_dir_all_async
from ._tokio import remove_dir_async as remove_dir_async
from ._tokio import remove_file_async as remove_file_async
from ._tokio import rename_async as rename_async
from ._tokio import sleep_async as sleep_async
from ._tokio import try_exists_async as try_exists_async
from ._tokio import write_async as write_async
from ._unindent import unindent as unindent
from ._unindent import unindent_bytes as unindent_bytes
from ._url import URL as URL
from ._walkdir import WalkDirEntry as WalkDirEntry
from ._walkdir import WalkdirGen as WalkdirGen
from ._walkdir import walkdir as walkdir
from ._which import which as which
from ._which import which_all as which_all
from ._which import which_re as which_re
from .errors import FeatureNotEnabledError as FeatureNotEnabledError
from .JSON import stringify as stringify
from .sh import cd as cd
from .sh import home as home
from .sh import ls as ls
from .sh import mkdir as mkdir
from .sh import pwd as pwd

# =============================================================================
# CONSTANTS
# =============================================================================
__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str
__target__: str

</code></pre>
<h2 id="ry.ryo3.errors"><a class="header" href="#ry.ryo3.errors"><code>ry.ryo3.errors</code></a></h2>
<pre><code class="language-python">class FeatureNotEnabledError(RuntimeError):
    """Raised when a feature is not enabled in the current build."""

</code></pre>
<h2 id="ry.ryo3.JSON"><a class="header" href="#ry.ryo3.JSON"><code>ry.ryo3.JSON</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.JSON"""

from typing import Any, Literal

import typing_extensions

from ry.ryo3._bytes import Bytes

JsonPrimitive: typing_extensions.TypeAlias = None | bool | int | float | str
JsonValue: typing_extensions.TypeAlias = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


def stringify(
    data: Any, *, fmt: bool = False, sort_keys: bool = False
) -&gt; Bytes: ...
def parse_json(
    data: bytes | str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def json_cache_clear() -&gt; None: ...
def json_cache_usage() -&gt; int: ...

</code></pre>
<h2 id="ry.ryo3.sh"><a class="header" href="#ry.ryo3.sh"><code>ry.ryo3.sh</code></a></h2>
<pre><code class="language-python">import typing as t
from os import PathLike

from ry.ryo3._fspath import FsPath


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: str | PathLike[str]) -&gt; None: ...
@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[False] = False,
) -&gt; list[str]:
    """List directory contents - returns list of strings"""


@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[True] = True,
) -&gt; list[FsPath]:
    """List directory contents - returns list of FsPath objects"""


def mkdir(path: str | PathLike[str]) -&gt; None: ...

</code></pre>
<h2 id="ry.ryo3._brotli"><a class="header" href="#ry.ryo3._brotli"><code>ry.ryo3._brotli</code></a></h2>
<pre><code class="language-python">"""ryo3-brotli types"""


# =============================================================================
# BROTLI
# =============================================================================
def brotli_encode(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(input: bytes) -&gt; bytes: ...
def brotli(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""

</code></pre>
<h2 id="ry.ryo3._bytes"><a class="header" href="#ry.ryo3._bytes"><code>ry.ryo3._bytes</code></a></h2>
<pre><code class="language-python">import sys
from typing import overload

import typing_extensions

if sys.version_info &gt;= (3, 12):
    from collections.abc import Buffer as Buffer
else:
    from typing_extensions import Buffer as Buffer


class Bytes(Buffer):
    """
    A buffer implementing the Python buffer protocol, allowing zero-copy access
    to underlying Rust memory.

    You can pass this to `memoryview` for a zero-copy view into the underlying
    data or to `bytes` to copy the underlying data into a Python `bytes`.

    Many methods from the Python `bytes` class are implemented on this,
    """

    def __init__(self, buf: Buffer = b"") -&gt; None:
        """Construct a new Bytes object.

        This will be a zero-copy view on the Python byte slice.
        """

    def __add__(self, other: Buffer) -&gt; Bytes: ...
    def __buffer__(self, flags: int) -&gt; memoryview[int]: ...
    def __contains__(self, other: Buffer) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @overload
    def __getitem__(self, other: int) -&gt; int: ...
    @overload
    def __getitem__(self, other: slice) -&gt; Bytes: ...
    def __mul__(self, other: Buffer) -&gt; int: ...
    def __len__(self) -&gt; int: ...
    def removeprefix(self, prefix: Buffer, /) -&gt; Bytes:
        """
        If the binary data starts with the prefix string, return `bytes[len(prefix):]`.
        Otherwise, return the original binary data.
        """

    def removesuffix(self, suffix: Buffer, /) -&gt; Bytes:
        """
        If the binary data ends with the suffix string and that suffix is not empty,
        return `bytes[:-len(suffix)]`. Otherwise, return the original binary data.
        """

    def isalnum(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetical ASCII characters or
        ASCII decimal digits and the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal digits
        are those byte values in the sequence `b'0123456789'`.
        """

    def isalpha(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetic ASCII characters and
        the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
        """

    def isascii(self) -&gt; bool:
        """
        Return `True` if the sequence is empty or all bytes in the sequence are ASCII,
        `False` otherwise.

        ASCII bytes are in the range `0-0x7F`.
        """

    def isdigit(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII decimal digits and the
        sequence is not empty, `False` otherwise.

        ASCII decimal digits are those byte values in the sequence `b'0123456789'`.
        """

    def islower(self) -&gt; bool:
        """
        Return `True` if there is at least one lowercase ASCII character in the sequence
        and no uppercase ASCII characters, `False` otherwise.
        """

    def isspace(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII whitespace and the sequence
        is not empty, `False` otherwise.

        ASCII whitespace characters are those byte values
        in the sequence `b' \t\n\r\x0b\f'` (space, tab, newline, carriage return,
        vertical tab, form feed).
        """

    def isupper(self) -&gt; bool:
        """
        Return `True` if there is at least one uppercase alphabetic ASCII character in
        the sequence and no lowercase ASCII characters, `False` otherwise.
        """

    def lower(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the uppercase ASCII characters converted
        to their corresponding lowercase counterpart.
        """

    def upper(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the lowercase ASCII characters converted
        to their corresponding uppercase counterpart.
        """

    def to_bytes(self) -&gt; bytes:
        """Copy this buffer's contents into a Python `bytes` object."""

    # =========================================================================
    # IMPL IN RY
    # =========================================================================

    def istitle(self) -&gt; bool:
        """
        Return `True` if the sequence is non-empty and contains only ASCII letters,
        digits, underscores, and hyphens, and starts with an ASCII letter or underscore.
        Otherwise, return `False`.
        """

    def decode(self, encoding: str = "utf-8", errors: str = "strict") -&gt; str:
        """Decode the binary data using the given encoding."""

    def hex(
        self, sep: str | None = None, bytes_per_sep: int | None = None
    ) -&gt; str:
        """Return a hexadecimal representation of the binary data."""

    @classmethod
    def fromhex(cls, hexstr: str) -&gt; Bytes:
        """Construct a `Bytes` object from a hexadecimal string."""

    def startswith(self, prefix: Buffer) -&gt; bool:
        """Return `True` if the binary data starts with the prefix string, `False` otherwise."""

    def endswith(self, suffix: Buffer) -&gt; bool:
        """Return `True` if the binary data ends with the suffix string, `False` otherwise."""


BytesLike: typing_extensions.TypeAlias = (
    Buffer | bytes | bytearray | memoryview | Bytes
)

</code></pre>
<h2 id="ry.ryo3._bzip2"><a class="header" href="#ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></a></h2>
<pre><code class="language-python">"""ryo3-bzip2 types"""

from ry._types import Buffer


# =============================================================================
# BZIP2
# =============================================================================
def bzip2_encode(input: Buffer, quality: int = 9) -&gt; bytes: ...
def bzip2_decode(input: Buffer) -&gt; bytes: ...
def bzip2(input: Buffer, quality: int = 9) -&gt; bytes:
    """Alias for bzip2_encode"""

</code></pre>
<h2 id="ry.ryo3._dev"><a class="header" href="#ry.ryo3._dev"><code>ry.ryo3._dev</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.dev"""

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...

</code></pre>
<h2 id="ry.ryo3._flate2"><a class="header" href="#ry.ryo3._flate2"><code>ry.ryo3._flate2</code></a></h2>
<pre><code class="language-python">"""ryo3-flate2 types"""

from ry import Bytes
from ry._types import Buffer


# =============================================================================
# GZIP
# =============================================================================
def gzip_encode(input: Buffer, quality: int = 9) -&gt; Bytes: ...
def gzip_decode(input: Buffer) -&gt; Bytes: ...
def gzip(input: Buffer, quality: int = 9) -&gt; Bytes:
    """Alias for gzip_encode"""


def gunzip(input: Buffer) -&gt; Bytes:
    """Alias for gzip_decode"""


def is_gzipped(input: Buffer) -&gt; bool: ...

</code></pre>
<h2 id="ry.ryo3._fnv"><a class="header" href="#ry.ryo3._fnv"><code>ry.ryo3._fnv</code></a></h2>
<pre><code class="language-python">"""ryo3-fnv types"""

import typing as t

from ry._types import Buffer
from ry.ryo3._bytes import Bytes


class FnvHasher:
    name: t.Literal["fnv1a"]
    digest_size: t.Literal[8]
    block_size: t.Literal[1]

    def __init__(
        self, input: Buffer | None = None, key: int | None = None
    ) -&gt; None: ...
    def update(self, input: Buffer) -&gt; None: ...
    def digest(self) -&gt; Bytes: ...
    def intdigest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; FnvHasher: ...


def fnv1a(input: Buffer, key: int | None = None) -&gt; FnvHasher: ...

</code></pre>
<h2 id="ry.ryo3._fspath"><a class="header" href="#ry.ryo3._fspath"><code>ry.ryo3._fspath</code></a></h2>
<pre><code class="language-python">"""ryo3-fspath types"""

import typing as t
from os import PathLike
from pathlib import Path

from ry._types import Buffer, ToPy
from ry.ryo3._bytes import Bytes
from ry.ryo3._std import Metadata


# =============================================================================
# FSPATH
# =============================================================================
class FsPath(ToPy[Path]):
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __truediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def __bytes__(self) -&gt; bytes: ...
    def to_py(self) -&gt; Path: ...
    def to_pathlib(self) -&gt; Path: ...
    # =========================================================================
    # IO
    # =========================================================================
    def read(self) -&gt; Bytes: ...
    def read_bytes(self) -&gt; bytes: ...
    def read_text(self) -&gt; str: ...
    def write(self, data: Buffer | bytes) -&gt; None: ...
    def write_bytes(self, data: Buffer | bytes) -&gt; None: ...
    def write_text(self, data: str) -&gt; None: ...

    # =========================================================================
    # METHODS
    # =========================================================================
    def absolute(self) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...
    def as_uri(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def exists(self) -&gt; bool: ...
    def iterdir(self) -&gt; FsPathReaddir: ...
    def join(self, *paths: str) -&gt; FsPath: ...
    def joinpath(self, *paths: str) -&gt; FsPath: ...
    def metadata(self) -&gt; Metadata: ...
    def read_dir(self) -&gt; FsPathReaddir: ...
    def read_link(self) -&gt; FsPath: ...
    def relative_to(self, other: PathLike[str] | str | FsPath) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def string(self) -&gt; str: ...
    def with_name(self, name: str) -&gt; FsPath: ...
    def with_suffix(self, suffix: str) -&gt; FsPath: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; FsPath: ...
    @classmethod
    def home(cls) -&gt; FsPath: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; FsPath: ...
    @property
    def parents(self) -&gt; t.Sequence[FsPath]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; str: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; t.Iterator[FsPath]: ...
    def canonicalize(self) -&gt; FsPath: ...
    def components(self) -&gt; t.Iterator[FsPath]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; FsPath: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, prefix: PathLike[str] | str) -&gt; FsPath: ...
    def with_extension(self, ext: str) -&gt; FsPath: ...
    def with_file_name(self, name: str) -&gt; FsPath: ...

    # =========================================================================
    # MISC
    # =========================================================================
    def samefile(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def symlink_metadata(self) -&gt; Metadata: ...


class FsPathReaddir:
    def __init__(self) -&gt; t.NoReturn: ...
    def __iter__(self) -&gt; t.Iterator[FsPath]: ...
    def __next__(self) -&gt; FsPath: ...
    def collect(self) -&gt; list[FsPath]: ...
    def take(self, n: int) -&gt; list[FsPath]: ...

</code></pre>
<h2 id="ry.ryo3._glob"><a class="header" href="#ry.ryo3._glob"><code>ry.ryo3._glob</code></a></h2>
<pre><code class="language-python">"""ryo3-glob types"""

import typing as t
from os import PathLike
from pathlib import Path

import typing_extensions as te

from ._fspath import FsPath

_T = t.TypeVar("_T", bound=str | Path | FsPath)


class _MatchOptions(t.TypedDict, total=False):
    case_sensitive: bool
    require_literal_separator: bool
    require_literal_leading_dot: bool


class GlobPaths(t.Generic[_T]):
    """glob::Paths iterable wrapper"""

    def __next__(self) -&gt; _T: ...
    def __iter__(self) -&gt; GlobPaths[_T]: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = False,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
) -&gt; GlobPaths[Path]: ...
@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = False,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
    dtype: type[_T],
) -&gt; GlobPaths[_T]: ...


class Pattern:
    def __init__(self, pattern: str) -&gt; None: ...
    def __call__(
        self,
        ob: str | PathLike[str],
        **kwargs: te.Unpack[_MatchOptions],
    ) -&gt; bool: ...
    def matches(self, s: str) -&gt; bool: ...
    def matches_path(self, path: PathLike[str]) -&gt; bool: ...
    def matches_with(
        self,
        s: str,
        **kwargs: te.Unpack[_MatchOptions],
    ) -&gt; bool: ...
    def matches_path_with(
        self,
        path: PathLike[str],
        **kwargs: te.Unpack[_MatchOptions],
    ) -&gt; bool: ...
    @staticmethod
    def escape(pattern: str) -&gt; str: ...
    @property
    def pattern(self) -&gt; str: ...

</code></pre>
<h2 id="ry.ryo3._globset"><a class="header" href="#ry.ryo3._globset"><code>ry.ryo3._globset</code></a></h2>
<pre><code class="language-python">"""ryo3-globset types"""

from os import PathLike


class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def regex(self) -&gt; str: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def globster(self) -&gt; Globster: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


def globster(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Globster: ...

</code></pre>
<h2 id="ry.ryo3._heck"><a class="header" href="#ry.ryo3._heck"><code>ry.ryo3._heck</code></a></h2>
<pre><code class="language-python">"""ryo3-heck types"""


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...

</code></pre>
<h2 id="ry.ryo3._jiff"><a class="header" href="#ry.ryo3._jiff"><code>ry.ryo3._jiff</code></a></h2>
<pre><code class="language-python">"""jiff types"""

import datetime as pydt
import typing as t
from typing import Protocol

import typing_extensions as te

from ry._types import (
    DateTimeTypedDict,
    DateTypedDict,
    TimeSpanTypedDict,
    TimeTypedDict,
    ToPy,
)
from ry.ryo3 import Duration

_T = t.TypeVar("_T")
# =============================================================================
# JIFF
# =============================================================================
JIFF_UNIT: te.TypeAlias = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JIFF_ROUND_MODE: te.TypeAlias = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half_ceil",
    "half_floor",
    "half_expand",
    "half_trunc",
    "half_even",
]

WEEKDAY_STR: te.TypeAlias = t.Literal[
    "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
]

WEEKDAY_INT: te.TypeAlias = t.Literal[
    1,  # Monday
    2,  # Tuesday
    3,  # Wednesday
    4,  # Thursday
    5,  # Friday
    6,  # Saturday
    7,  # Sunday
]

WEEKDAY: te.TypeAlias = WEEKDAY_STR | WEEKDAY_INT


class ToPyDate(Protocol):
    def to_pydate(self) -&gt; pydt.date: ...


class ToPyTime(Protocol):
    def to_pytime(self) -&gt; pydt.time: ...


class ToPyDateTime(Protocol):
    def to_pydatetime(self) -&gt; pydt.datetime: ...


class ToPyTimeDelta(Protocol):
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...


class ToPyTzInfo(Protocol):
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...


class Date(ToPy[pydt.date], ToPyDate):
    MIN: Date
    MAX: Date
    ZERO: Date

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.date: ...
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls: type[Date], date: pydt.date) -&gt; Date: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(
        cls: type[Date], year: int, week: int, weekday: int
    ) -&gt; Date: ...
    @classmethod
    def today(cls: type[Date]) -&gt; Date: ...
    @classmethod
    def parse(cls: type[Date], s: str) -&gt; Date: ...
    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls: type[Date], format: str, string: str) -&gt; Date: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __isub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int
    ) -&gt; DateTime: ...
    def asdict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: Date) -&gt; Date: ...
    def duration_until(self, other: Date) -&gt; Date: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; Date: ...
    def first_of_year(self) -&gt; Date: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; Date: ...
    def last_of_year(self) -&gt; Date: ...
    def nth_weekday(self, nth: int, weekday: WEEKDAY) -&gt; Date: ...
    def nth_weekday_of_month(self, nth: int, weekday: WEEKDAY) -&gt; Date: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[Date]: ...
    def to_datetime(self, t: Time) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; Date: ...
    def yesterday(self) -&gt; Date: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...


class DateDifference:
    def __init__(
        self,
        date: Date,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; DateDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; DateDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateDifference: ...
    def increment(self, increment: int) -&gt; DateDifference: ...


class Time(ToPy[pydt.time], ToPyTime):
    MIN: Time
    MAX: Time

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __isub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls: type[Time], format: str, string: str) -&gt; Time: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.time: ...
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls: type[Time], t: pydt.time) -&gt; Time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def now(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def parse(cls: type[Time], s: str) -&gt; Time: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; None: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def asdict(self) -&gt; TimeTypedDict: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[Time]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    @t.overload
    def checked_sub(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; Time: ...
    def to_datetime(self, d: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class TimeDifference:
    def __init__(
        self,
        date: Time,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; TimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; TimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimeDifference: ...
    def increment(self, increment: int) -&gt; TimeDifference: ...


class DateTime(ToPy[pydt.datetime], ToPyDate, ToPyTime, ToPyDateTime):
    MIN: DateTime
    MAX: DateTime
    ZERO: DateTime

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls: type[DateTime], format: str, string: str) -&gt; DateTime: ...
    @classmethod
    def parse(cls: type[DateTime], s: str) -&gt; DateTime: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls: type[DateTime], dt: pydt.datetime) -&gt; DateTime: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls: type[DateTime]) -&gt; DateTime: ...
    @classmethod
    def from_parts(cls: type[DateTime], date: Date, time: Time) -&gt; DateTime: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __sub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __isub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def asdict(self) -&gt; DateTimeTypedDict: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def date(self) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: DateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: DateTime) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; DateTime: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; DateTime: ...
    def first_of_year(self) -&gt; DateTime: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def last_of_month(self) -&gt; DateTime: ...
    def last_of_year(self) -&gt; DateTime: ...
    def nth_weekday(self, nth: int, weekday: WEEKDAY) -&gt; DateTime: ...
    def nth_weekday_of_month(self, nth: int, weekday: WEEKDAY) -&gt; DateTime: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        *,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; DateTime: ...
    def _round(self, options: DateTimeRound) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[DateTime]: ...
    def start_of_day(self) -&gt; DateTime: ...
    def time(self) -&gt; Time: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; DateTime: ...
    def yesterday(self) -&gt; DateTime: ...
    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def saturating_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class DateTimeDifference:
    def __init__(
        self,
        date: DateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; DateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; DateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeDifference: ...
    def increment(self, increment: int) -&gt; DateTimeDifference: ...


class TimeZone(ToPy[pydt.tzinfo], ToPyTzInfo):
    def __init__(self, name: str) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __call__(self) -&gt; te.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================

    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    @classmethod
    def from_pytzinfo(cls: type[TimeZone], tz: pydt.tzinfo) -&gt; TimeZone: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...
    @property
    def is_unknown(self) -&gt; bool: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls: type[TimeZone], offset: Offset) -&gt; TimeZone: ...
    @classmethod
    def get(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def posix(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def try_system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def tzif(cls: type[TimeZone], name: str, data: bytes) -&gt; TimeZone: ...
    @classmethod
    def utc(cls: type[TimeZone]) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, dt: Timestamp) -&gt; DateTime: ...
    def to_offset(self, timestamp: Timestamp) -&gt; Offset: ...
    def to_timestamp(self, dt: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, other: DateTime) -&gt; ZonedDateTime: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


class SignedDuration(ToPy[pydt.timedelta], ToPyTimeDelta):
    MIN: SignedDuration
    MAX: SignedDuration
    ZERO: SignedDuration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __mul__(self, other: int) -&gt; SignedDuration: ...
    def __rmul__(self, other: int) -&gt; SignedDuration: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; SignedDuration: ...
    def __add__(self, other: SignedDuration) -&gt; SignedDuration: ...
    def __abs__(self) -&gt; SignedDuration: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __div__(self, other: int) -&gt; SignedDuration: ...
    def abs(self) -&gt; SignedDuration: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(
        self, other: SignedDuration | pydt.timedelta, op: int
    ) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self, human: bool = False) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[SignedDuration], td: pydt.timedelta
    ) -&gt; SignedDuration: ...
    def to_py(self) -&gt; pydt.timedelta: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls: type[SignedDuration], s: str) -&gt; SignedDuration: ...
    @classmethod
    def from_hours(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_micros(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_millis(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_mins(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_nanos(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def checked_div(self, other: int) -&gt; SignedDuration | None: ...
    def checked_mul(self, other: int) -&gt; SignedDuration | None: ...
    def checked_neg(self) -&gt; SignedDuration | None: ...
    def checked_sub(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def div_duration_f32(self, other: SignedDuration) -&gt; float: ...
    def div_duration_f64(self, other: SignedDuration) -&gt; float: ...
    def div_f32(self, other: int) -&gt; float: ...
    def div_f64(self, other: int) -&gt; float: ...
    def is_positive(self) -&gt; bool: ...
    def mul_f32(self, other: int) -&gt; SignedDuration: ...
    def mul_f64(self, other: int) -&gt; SignedDuration: ...
    def saturating_add(self, other: SignedDuration) -&gt; SignedDuration: ...
    def saturating_mul(self, other: int) -&gt; SignedDuration: ...
    def saturating_sub(self, other: SignedDuration) -&gt; SignedDuration: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def subsec_micros(self) -&gt; int: ...
    def subsec_millis(self) -&gt; int: ...
    def subsec_nanos(self) -&gt; int: ...
    def to_timespan(self) -&gt; TimeSpan: ...


# put in quotes to avoid ruff F821 - undefined name
_TimeSpanArithmeticSingle: te.TypeAlias = TimeSpan | Duration | SignedDuration
_TimeSpanArithmeticTuple: te.TypeAlias = tuple[
    _TimeSpanArithmeticSingle, ZonedDateTime | Date | DateTime
]
TimeSpanArithmetic: te.TypeAlias = (
    _TimeSpanArithmeticSingle | _TimeSpanArithmeticTuple
)


class TimeSpan(ToPy[pydt.timedelta], ToPyTimeDelta):
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self, human: bool = False) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, td: pydt.timedelta) -&gt; TimeSpan: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls, s: str) -&gt; TimeSpan: ...
    @classmethod
    def parse_common_iso(cls, s: str) -&gt; TimeSpan: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; te.Self: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; te.Self: ...
    def __mul__(self, other: int) -&gt; te.Self: ...
    def __neg__(self) -&gt; te.Self: ...
    def __abs__(self) -&gt; te.Self: ...
    def __invert__(self) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: TimeSpan) -&gt; bool: ...
    def __gt__(self, other: TimeSpan) -&gt; bool: ...
    def __le__(self, other: TimeSpan) -&gt; bool: ...
    def __lt__(self, other: TimeSpan) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: TimeSpan) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; te.Self: ...
    def asdict(self) -&gt; TimeSpanTypedDict: ...
    def checked_add(self, val: TimeSpanArithmetic) -&gt; te.Self: ...
    def checked_mul(self, other: int) -&gt; te.Self: ...
    def checked_sub(self, val: TimeSpanArithmetic) -&gt; te.Self: ...
    def compare(
        self,
        other: TimeSpan,
        relative: ZonedDateTime | DateTime | Date | None = None,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def negate(self) -&gt; te.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; te.Self: ...
    def round(
        self,
        smallest: JIFF_UNIT,
        increment: int = 1,
        *,
        relative: ZonedDateTime | Date | DateTime | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
    ) -&gt; te.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self, relative: ZonedDateTime | Date | DateTime
    ) -&gt; SignedDuration: ...
    def total(
        self,
        unit: JIFF_UNIT,
        relative: ZonedDateTime | Date | DateTime | None = None,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def total_seconds(self) -&gt; int: ...
    def try_years(self, years: int) -&gt; te.Self: ...
    def try_months(self, months: int) -&gt; te.Self: ...
    def try_weeks(self, weeks: int) -&gt; te.Self: ...
    def try_days(self, days: int) -&gt; te.Self: ...
    def try_hours(self, hours: int) -&gt; te.Self: ...
    def try_minutes(self, minutes: int) -&gt; te.Self: ...
    def try_seconds(self, seconds: int) -&gt; te.Self: ...
    def try_milliseconds(self, milliseconds: int) -&gt; te.Self: ...
    def try_microseconds(self, microseconds: int) -&gt; te.Self: ...
    def try_nanoseconds(self, nanoseconds: int) -&gt; te.Self: ...

    # -------------------------------------------------------------------------
    # PANIC-INDUCING METHODS
    # -------------------------------------------------------------------------
    def _years(self, years: int) -&gt; te.Self: ...
    def _months(self, months: int) -&gt; te.Self: ...
    def _weeks(self, weeks: int) -&gt; te.Self: ...
    def _days(self, days: int) -&gt; te.Self: ...
    def _hours(self, hours: int) -&gt; te.Self: ...
    def _minutes(self, minutes: int) -&gt; te.Self: ...
    def _seconds(self, seconds: int) -&gt; te.Self: ...
    def _milliseconds(self, milliseconds: int) -&gt; te.Self: ...
    def _microseconds(self, microseconds: int) -&gt; te.Self: ...
    def _nanoseconds(self, nanoseconds: int) -&gt; te.Self: ...


class Timestamp(ToPy[pydt.datetime], ToPyDate, ToPyTime, ToPyDateTime):
    """
    A representation of a timestamp with second and nanosecond precision.
    """

    MIN: Timestamp
    MAX: Timestamp
    UNIX_EPOCH: Timestamp

    def __init__(
        self, second: int | None = None, nanosecond: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; Timestamp: ...
    @classmethod
    def parse(cls, s: str) -&gt; Timestamp: ...
    @classmethod
    def from_millisecond(cls, millisecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_microsecond(cls, microsecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_nanosecond(cls, nanosecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_second(cls, second: int) -&gt; Timestamp: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: Timestamp) -&gt; bool: ...
    def __gt__(self, other: Timestamp) -&gt; bool: ...
    def __le__(self, other: Timestamp) -&gt; bool: ...
    def __lt__(self, other: Timestamp) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: Timestamp, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def __sub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, dt: pydt.datetime) -&gt; Timestamp: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls, format: str, input: str) -&gt; Timestamp: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...
    def as_second(self) -&gt; int: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    @t.overload
    def checked_sub(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def display_with_offset(self, offset: Offset) -&gt; str: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime:
        """Deprecated ~ use `in_tz`"""

    def is_zero(self) -&gt; bool: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def series(self, span: TimeSpan) -&gt; JiffSeries[Timestamp]: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def string(self) -&gt; str: ...
    def subsec_microsecond(self) -&gt; int: ...
    def subsec_millisecond(self) -&gt; int: ...
    def subsec_nanosecond(self) -&gt; int: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def duration_since(self, other: Timestamp) -&gt; SignedDuration: ...
    def duration_until(self, other: Timestamp) -&gt; SignedDuration: ...
    def round(
        self,
        unit: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; Timestamp: ...
    def _round(self, options: TimestampRound) -&gt; Timestamp: ...


class TimestampDifference:
    def __init__(
        self,
        date: Timestamp,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; TimestampDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; TimestampDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimestampDifference: ...
    def increment(self, increment: int) -&gt; TimestampDifference: ...


class ZonedDateTime(
    ToPy[pydt.datetime], ToPyDate, ToPyTime, ToPyDateTime, ToPyTzInfo
):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
        tz: str | None = None,
    ) -&gt; None: ...
    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(
        cls: type[ZonedDateTime], dt: pydt.datetime
    ) -&gt; ZonedDateTime: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(
        cls: type[ZonedDateTime], tz: str | None = None
    ) -&gt; ZonedDateTime: ...
    @classmethod
    def utcnow(cls: type[ZonedDateTime]) -&gt; ZonedDateTime: ...
    @classmethod
    def parse(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
    @classmethod
    def from_rfc2822(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
    @classmethod
    def parse_rfc2822(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
    @classmethod
    def from_parts(
        cls: type[ZonedDateTime], timestamp: Timestamp, time_zone: TimeZone
    ) -&gt; ZonedDateTime: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(
        cls: type[ZonedDateTime], format: str, input: str
    ) -&gt; ZonedDateTime: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...
    @property
    def timezone(self) -&gt; TimeZone: ...
    @property
    def tz(self) -&gt; TimeZone: ...

    # =========================================================================
    # STRING/FORMAT
    # =========================================================================
    def string(self) -&gt; str: ...
    def to_rfc2822(self) -&gt; str: ...
    def format_rfc2822(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: ZonedDateTime) -&gt; bool: ...
    def __gt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: ZonedDateTime) -&gt; bool: ...
    def __lt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: ZonedDateTime, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def __sub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; ZonedDateTime: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def checked_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; ZonedDateTime: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; ZonedDateTime: ...
    def first_of_year(self) -&gt; ZonedDateTime: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: str) -&gt; te.Self: ...
    def intz(self, tz: str) -&gt; te.Self: ...
    def inutc(self) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; ZonedDateTime: ...
    def last_of_year(self) -&gt; ZonedDateTime: ...
    def nth_weekday(self, nth: int, weekday: WEEKDAY) -&gt; Date: ...
    def nth_weekday_of_month(self, nth: int, weekday: WEEKDAY) -&gt; Date: ...
    def offset(self) -&gt; Offset: ...
    def replace(
        self,
        obj: Date | DateTime | Offset | None = None,
        *,
        date: Date | None = None,
        time: Time | None = None,
        year: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        month: int | None = None,
        day: int | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
        offset: Offset | None = None,
        offset_conflict: t.Any = None,
        disambiguation: t.Any = None,
    ) -&gt; ZonedDateTime: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        *,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; DateTime: ...
    def _round(self, options: ZonedDateTimeRound) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def saturating_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def start_of_day(self) -&gt; ZonedDateTime: ...
    def time(self) -&gt; Time: ...
    def timestamp(self) -&gt; Timestamp: ...
    def tomorrow(self) -&gt; ZonedDateTime: ...
    def with_time_zone(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def yesterday(self) -&gt; ZonedDateTime: ...
    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self,
        other: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class ZonedDateTimeDifference:
    def __init__(
        self,
        date: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; ZonedDateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; ZonedDateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; ZonedDateTimeDifference: ...
    def increment(self, increment: int) -&gt; ZonedDateTimeDifference: ...


class ISOWeekDate:
    MIN: ISOWeekDate
    MAX: ISOWeekDate
    ZERO: ISOWeekDate

    def __init__(self, year: int, week: int, weekday: WEEKDAY) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================

    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __le__(self, other: ISOWeekDate) -&gt; bool: ...
    def __gt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __ge__(self, other: ISOWeekDate) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_date(cls: type[ISOWeekDate], date: Date) -&gt; ISOWeekDate: ...
    @classmethod
    def today(cls: type[ISOWeekDate]) -&gt; ISOWeekDate: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def week(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; WEEKDAY_INT: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...


class TimestampRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimestampRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; TimestampRound: ...
    def increment(self, increment: int) -&gt; TimestampRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; TimestampRound: ...


class DateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class ZonedDateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class Offset(ToPy[pydt.tzinfo], ToPyTzInfo):
    MIN: Offset
    MAX: Offset
    UTC: Offset
    ZERO: Offset

    def __init__(
        self, hours: int | None = None, seconds: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; Offset: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    # __FROM__
    @classmethod
    def from_pytzinfo(cls: type[Offset], tz: pydt.tzinfo) -&gt; Offset: ...
    # __TO__
    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls: type[Offset]) -&gt; Offset: ...
    @classmethod
    def from_hours(cls: type[Offset], hours: int) -&gt; Offset: ...
    @classmethod
    def from_seconds(cls: type[Offset], seconds: int) -&gt; Offset: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def checked_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def negate(self) -&gt; Offset: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def since(self, other: Offset) -&gt; TimeSpan: ...
    def until(self, other: Offset) -&gt; TimeSpan: ...


class JiffSeries(
    t.Generic[_T],
):
    def __iter__(self) -&gt; t.Iterator[_T]: ...
    def __next__(self) -&gt; _T: ...
    def take(self, n: int) -&gt; list[_T]: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def zoned(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
    tz: str | None = None,
) -&gt; ZonedDateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...


# =============================================================================
# TIMEZONE-DATABASE
# =============================================================================
class TimeZoneDatabase:
    def __init__(self) -&gt; None:
        """Defaults to using the `self.from_env`"""

    @t.overload
    def get(self, name: str, err: t.Literal[False]) -&gt; TimeZone | None:
        """Returns TimeZone or None if the timezone is not found"""

    @t.overload
    def get(self, name: str, err: t.Literal[True] = True) -&gt; TimeZone:
        """Returns TimeZone, if not found raises a ValueError"""

    def available(self) -&gt; list[str]: ...
    def __getitem__(self, name: str) -&gt; TimeZone: ...
    def __len__(self) -&gt; int: ...
    def is_definitively_empty(self) -&gt; bool: ...
    @classmethod
    def from_env(cls) -&gt; TimeZoneDatabase: ...
    @classmethod
    def from_dir(cls, path: str) -&gt; TimeZoneDatabase: ...
    @classmethod
    def from_concatenated_path(cls, path: str) -&gt; TimeZoneDatabase: ...
    @classmethod
    def bundled(cls) -&gt; TimeZoneDatabase: ...

</code></pre>
<h2 id="ry.ryo3._jiter"><a class="header" href="#ry.ryo3._jiter"><code>ry.ryo3._jiter</code></a></h2>
<pre><code class="language-python">import typing as t
from os import PathLike

import typing_extensions as te

from ry._types import Buffer

# =============================================================================
# JSON
# =============================================================================
JsonPrimitive: te.TypeAlias = None | bool | int | float | str
JsonValue: te.TypeAlias = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


class JsonParseKwargs(t.TypedDict, total=False):
    allow_inf_nan: bool
    """Allow parsing of `Infinity`, `-Infinity`, `NaN` ~ default: True"""
    cache_mode: t.Literal[True, False, "all", "keys", "none"]
    """Cache mode for JSON parsing ~ default: `all` """
    partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"]
    """Partial mode for JSON parsing ~ default: False"""
    catch_duplicate_keys: bool
    """Catch duplicate keys in JSON objects ~ default: False"""
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool
    """Mode for parsing JSON floats ~ default: False"""


def parse_json(
    data: Buffer | bytes | str,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_jsonl(
    data: Buffer | bytes | str,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; list[JsonValue]: ...
def parse_json_bytes(
    data: bytes,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def read_json(
    p: str | PathLike[str],
    /,
    lines: bool = False,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def json_cache_clear() -&gt; None: ...
def json_cache_usage() -&gt; int: ...

</code></pre>
<h2 id="ry.ryo3._quick_maths"><a class="header" href="#ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></a></h2>
<pre><code class="language-python">"""ryo3-quick-maths types"""

import typing as t


def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """

</code></pre>
<h2 id="ry.ryo3._regex"><a class="header" href="#ry.ryo3._regex"><code>ry.ryo3._regex</code></a></h2>
<pre><code class="language-python">"""ryo3-regex types"""

# =============================================================================
# Regex
# =============================================================================


class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: str | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def is_match(self, string: str) -&gt; bool: ...
    def find(self, string: str) -&gt; str | None: ...
    def find_all(self, string: str) -&gt; list[tuple[int, int]]: ...
    def findall(self, string: str) -&gt; list[tuple[int, int]]: ...
    def replace(self, string: str, replacement: str) -&gt; str: ...
    def replace_all(self, string: str, replacement: str) -&gt; str: ...
    def split(self, string: str) -&gt; list[str]: ...
    def splitn(self, string: str, n: int) -&gt; list[str]: ...

</code></pre>
<h2 id="ry.ryo3._reqwest"><a class="header" href="#ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></a></h2>
<pre><code class="language-python">import typing as t

import typing_extensions as te

import ry
from ry._types import Buffer
from ry.http import Headers, HttpStatus, HttpVersionLike
from ry.ryo3 import URL, Duration

HeadersLike: te.TypeAlias = Headers | dict[str, str]


class RequestKwargs(t.TypedDict, total=False):
    body: Buffer | None
    headers: HeadersLike | None
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None
    multipart: t.Any
    form: t.Any
    timeout: Duration | None
    version: HttpVersionLike | None


class HttpClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | None = None,
        cookies: bool = False,
        user_agent: str | None = None,  # default ~ 'ry-reqwest/&lt;VERSION&gt; ...'
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
    ) -&gt; None: ...
    async def get(
        self,
        url: str | URL,
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def post(
        self,
        url: str | URL,
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def put(
        self,
        url: str | URL,
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def delete(
        self,
        url: str | URL,
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def patch(
        self,
        url: str | URL,
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def head(
        self,
        url: str | URL,
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: str | URL,
        *,
        method: str = "GET",
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def __call__(
        self,
        url: str | URL,
        *,
        method: str = "GET",
        **kwargs: te.Unpack[RequestKwargs],
    ) -&gt; Response: ...


class ReqwestError(Exception):
    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None: ...
    def __dbg__(self) -&gt; str: ...
    def is_body(self) -&gt; bool: ...
    def is_builder(self) -&gt; bool: ...
    def is_connect(self) -&gt; bool: ...
    def is_decode(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_request(self) -&gt; bool: ...
    def is_status(self) -&gt; bool: ...
    def is_timeout(self) -&gt; bool: ...
    def status(self) -&gt; HttpStatus | None: ...
    def url(self) -&gt; URL | None: ...


class Response:
    @property
    def headers(self) -&gt; Headers: ...
    async def text(self) -&gt; str: ...
    async def json(self) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(self) -&gt; ResponseStream: ...
    def stream(self) -&gt; ResponseStream: ...
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    @property
    def redirected(self) -&gt; bool: ...


class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...
    async def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    @t.overload
    async def collect(
        self, join: t.Literal[False] = False
    ) -&gt; list[ry.Bytes]: ...
    @t.overload
    async def collect(self, join: t.Literal[True] = True) -&gt; ry.Bytes: ...


async def fetch(
    url: str | URL,
    *,
    client: HttpClient | None = None,
    method: str = "GET",
    **kwargs: te.Unpack[RequestKwargs],
) -&gt; Response: ...

</code></pre>
<h2 id="ry.ryo3._same_file"><a class="header" href="#ry.ryo3._same_file"><code>ry.ryo3._same_file</code></a></h2>
<pre><code class="language-python">"""ryo3-same-file types"""

from os import PathLike


def is_same_file(a: PathLike[str], b: PathLike[str]) -&gt; bool: ...

</code></pre>
<h2 id="ry.ryo3._shlex"><a class="header" href="#ry.ryo3._shlex"><code>ry.ryo3._shlex</code></a></h2>
<pre><code class="language-python">"""ryo3-shlex types"""


def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""

</code></pre>
<h2 id="ry.ryo3._size"><a class="header" href="#ry.ryo3._size"><code>ry.ryo3._size</code></a></h2>
<pre><code class="language-python">from typing import Literal

import typing_extensions

FORMAT_SIZE_BASE: typing_extensions.TypeAlias = Literal[2, 10]  # default=2
FORMAT_SIZE_STYLE: typing_extensions.TypeAlias = Literal[  # default="default"
    "default",
    "abbreviated",
    "abbreviated_lowercase",
    "abbreviated-lowercase",
    "full",
    "full-lowercase",
    "full_lowercase",
]


def fmt_size(
    n: int,
    *,
    base: FORMAT_SIZE_BASE | None = 2,
    style: FORMAT_SIZE_STYLE | None = "default",
) -&gt; str:
    """Return human-readable string representation of bytes-size."""


def parse_size(s: str) -&gt; int:
    """Return integer representation of human-readable bytes-size string.

    Raises:
        ValueError: If string is not a valid human-readable bytes-size string.
    """


class SizeFormatter:
    """Human-readable bytes-size formatter."""

    def __init__(
        self,
        base: FORMAT_SIZE_BASE | None = 2,
        style: FORMAT_SIZE_STYLE | None = "default",
    ) -&gt; None:
        """Initialize human-readable bytes-size formatter."""

    def format(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __call__(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""


class Size:
    """Bytes-size object."""

    def __init__(self, size: int) -&gt; None: ...
    def __int__(self) -&gt; int: ...
    def __hash__(self) -&gt; int: ...
    def __abs__(self) -&gt; Size: ...
    def __neg__(self) -&gt; Size: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Size | float) -&gt; bool: ...
    def __le__(self, other: Size | float) -&gt; bool: ...
    def __gt__(self, other: Size | float) -&gt; bool: ...
    def __ge__(self, other: Size | float) -&gt; bool: ...
    def __bool__(self) -&gt; bool: ...
    def __pos__(self) -&gt; Size: ...
    def __invert__(self) -&gt; Size: ...
    def __add__(self, other: Size | float) -&gt; Size: ...
    def __sub__(self, other: Size | float) -&gt; Size: ...
    def __mul__(self, other: Size | float) -&gt; Size: ...
    def __rmul__(self, other: Size | float) -&gt; Size: ...
    @property
    def bytes(self) -&gt; int: ...
    def format(
        self,
        base: FORMAT_SIZE_BASE | None = 2,
        style: FORMAT_SIZE_STYLE | None = "default",
    ) -&gt; str: ...

    # =========================================================================
    # CLASS-METHODS
    # =========================================================================

    # -------------------------------------------------------------------------
    # PARSING
    # -------------------------------------------------------------------------
    @classmethod
    def parse(cls: type[Size], size: str) -&gt; Size: ...
    @classmethod
    def from_str(cls: type[Size], size: str) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # BYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_bytes(cls: type[Size], size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # KILOBYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_kb(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_kib(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_kibibytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_kilobytes(cls: type[Size], size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # MEGABYTES
    # -------------------------------------------------------------------------

    @classmethod
    def from_mb(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_mebibytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_megabytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_mib(cls: type[Size], size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # GIGABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_gb(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_gib(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_gibibytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_gigabytes(cls: type[Size], size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # TERABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_tb(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_tebibytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_terabytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_tib(cls: type[Size], size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # PETABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_pb(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_pebibytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_petabytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_pib(cls: type[Size], size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # EXABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_eb(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_eib(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_exabytes(cls: type[Size], size: float) -&gt; Size: ...
    @classmethod
    def from_exbibytes(cls: type[Size], size: float) -&gt; Size: ...

</code></pre>
<h2 id="ry.ryo3._sqlformat"><a class="header" href="#ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></a></h2>
<pre><code class="language-python">import typing as t

import typing_extensions

# =============================================================================
# SQLFORMAT
# =============================================================================
SqlfmtParamValue: typing_extensions.TypeAlias = str | int | float | bool
_TSqlfmtParamValue_co = t.TypeVar(
    "_TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike: typing_extensions.TypeAlias = (
    dict[str, _TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, _TSqlfmtParamValue_co]]
    | t.Sequence[_TSqlfmtParamValue_co]
)


class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    ) -&gt; None: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co] | SqlfmtQueryParams,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int = 2,  # -1 or any negative value will use tabs
    uppercase: bool | None = True,
    lines_between_statements: int = 1,
) -&gt; str: ...

</code></pre>
<h2 id="ry.ryo3._std"><a class="header" href="#ry.ryo3._std"><code>ry.ryo3._std</code></a></h2>
<pre><code class="language-python">"""ryo3-std types"""

import datetime as pydt
import ipaddress
import pathlib
import typing as t

import typing_extensions as te

from ry._types import Buffer, FsPathLike, ToPy
from ry.ryo3._bytes import Bytes


# =============================================================================
# STD::TIME
# =============================================================================
class Duration(ToPy[pydt.timedelta]):
    ZERO: Duration
    MIN: Duration
    MAX: Duration
    NANOSECOND: Duration
    MICROSECOND: Duration
    MILLISECOND: Duration
    SECOND: Duration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Duration) -&gt; bool: ...
    def __le__(self, other: Duration) -&gt; bool: ...
    def __gt__(self, other: Duration) -&gt; bool: ...
    def __ge__(self, other: Duration) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(
        self, other: Duration | pydt.timedelta, op: int
    ) -&gt; bool: ...
    def __bool__(self) -&gt; bool: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    @t.overload
    def __truediv__(self, other: Duration | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __truediv__(self, other: float) -&gt; Duration: ...
    def __mul__(self, other: float) -&gt; Duration: ...
    def abs_diff(self, other: Duration) -&gt; Duration: ...
    def sleep(self) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[Duration], td: pydt.timedelta
    ) -&gt; Duration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; Duration: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; Duration: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; Duration: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; Duration: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; Duration: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; Duration: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_days(cls, days: int) -&gt; Duration: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; Duration: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Duration | None: ...
    def checked_div(self, other: Duration) -&gt; Duration | None: ...
    def checked_mul(self, other: Duration) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Duration | None: ...
    def div_duration_f32(self, other: Duration) -&gt; float: ...
    def div_duration_f64(self, other: Duration) -&gt; float: ...
    def div_f32(self, other: float) -&gt; Duration: ...
    def div_f64(self, other: float) -&gt; Duration: ...
    def mul_f32(self, other: float) -&gt; Duration: ...
    def mul_f64(self, other: float) -&gt; Duration: ...
    def saturating_add(self, other: Duration) -&gt; Duration: ...
    def saturating_mul(self, other: Duration) -&gt; Duration: ...
    def saturating_sub(self, other: Duration) -&gt; Duration: ...


class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Instant) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Instant | None: ...
    def checked_duration_since(self, earlier: Instant) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Instant | None: ...
    def duration_since(self, earlier: Instant) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: Instant) -&gt; Duration: ...


def instant() -&gt; Instant: ...
def sleep(seconds: float) -&gt; float: ...


# =============================================================================
# STD::FS
# =============================================================================
class FileType:
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...


class Metadata:
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def len(self) -&gt; int: ...
    @property
    def is_empty(self) -&gt; bool: ...
    @property
    def modified(self) -&gt; pydt.datetime: ...
    @property
    def accessed(self) -&gt; pydt.datetime: ...
    @property
    def created(self) -&gt; pydt.datetime: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...


class DirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def basename(self) -&gt; str: ...
    @property
    def metadata(self) -&gt; Metadata: ...
    @property
    def file_type(self) -&gt; FileType: ...


_T = t.TypeVar("_T")


class RyIterable(t.Generic[_T]):
    def __iter__(self) -&gt; te.Self: ...
    def __next__(self) -&gt; _T: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


class ReadDir(RyIterable[DirEntry]): ...


class FileReadStream:
    def __init__(
        self,
        path: FsPathLike,
        *,
        chunk_size: int = 65536,
        offset: int = 0,
        buffered: bool = True,
    ) -&gt; None: ...
    def __iter__(self) -&gt; te.Self: ...
    def __next__(self) -&gt; Bytes: ...
    def collect(self) -&gt; list[Bytes]: ...
    def take(self, n: int = 1) -&gt; list[Bytes]: ...


# ============================================================================
# STD::FS ~ functions
# =============================================================================
def read(path: FsPathLike) -&gt; Bytes: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def read_dir(
    path: FsPathLike,
) -&gt; ReadDir: ...
def read_text(path: FsPathLike) -&gt; str: ...
def read_stream(
    path: FsPathLike,
    chunk_size: int = 65536,
    *,
    offset: int = 0,
) -&gt; FileReadStream: ...
def write(path: FsPathLike, data: Buffer | str) -&gt; int: ...
def write_bytes(path: FsPathLike, data: bytes) -&gt; int: ...
def write_text(path: FsPathLike, data: str) -&gt; int: ...
def canonicalize(path: FsPathLike) -&gt; pathlib.Path: ...
def copy(from_path: FsPathLike, to_path: FsPathLike) -&gt; int: ...
def create_dir(path: FsPathLike) -&gt; None: ...
def create_dir_all(path: FsPathLike) -&gt; None: ...
def exists(path: FsPathLike) -&gt; bool: ...
def is_dir(path: FsPathLike) -&gt; bool: ...
def is_file(path: FsPathLike) -&gt; bool: ...
def is_symlink(path: FsPathLike) -&gt; bool: ...
def metadata(path: FsPathLike) -&gt; Metadata: ...
def remove_dir(path: FsPathLike) -&gt; None: ...
def remove_dir_all(path: FsPathLike) -&gt; None: ...
def remove_file(path: FsPathLike) -&gt; None: ...
def rename(from_path: FsPathLike, to_path: FsPathLike) -&gt; None: ...


# =============================================================================
# STD::NET
# =============================================================================


class Ipv4Addr:
    BROADCAST: Ipv4Addr
    LOCALHOST: Ipv4Addr
    UNSPECIFIED: Ipv4Addr

    @t.overload
    def __init__(self, a: int, b: int, c: int, d: int) -&gt; None: ...
    @t.overload
    def __init__(self, iplike: int | str | bytes | Ipv4Addr) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __le__(self, other: Ipv4Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv4Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv4Address: ...

    # ========================================================================
    # PROPERTIES
    # ========================================================================
    @property
    def version(self) -&gt; int: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_link_local(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_reserved(self) -&gt; t.NoReturn: ...
    @property
    def is_shared(self) -&gt; t.NoReturn: ...

    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def parse(cls, s: str) -&gt; Ipv4Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; Ipv4Addr: ...
    @classmethod
    def from_octets(cls, b: bytes) -&gt; Ipv4Addr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...


class Ipv6Addr:
    LOCALHOST: Ipv6Addr
    UNSPECIFIED: Ipv6Addr

    @t.overload
    def __init__(
        self, a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int
    ) -&gt; None: ...
    @t.overload
    def __init__(self, iplike: int | str | bytes | Ipv6Addr) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __le__(self, other: Ipv6Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv6Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv6Address: ...

    # ========================================================================
    # PROPERTIES
    # ========================================================================
    @property
    def version(self) -&gt; int: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_unicast_link_local(self) -&gt; bool: ...
    @property
    def is_unique_local(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_documentation(self) -&gt; t.NoReturn: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4_mapped(self) -&gt; t.NoReturn: ...
    @property
    def is_unicast(self) -&gt; t.NoReturn: ...
    @property
    def is_unicast_global(self) -&gt; t.NoReturn: ...

    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def parse(cls, s: str) -&gt; Ipv4Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; IpAddr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...


class IpAddr:
    BROADCAST: IpAddr
    LOCALHOST_V4: IpAddr
    UNSPECIFIED_V4: IpAddr
    LOCALHOST_V6: IpAddr
    UNSPECIFIED_V6: IpAddr

    def __init__(
        self,
        iplike: int
        | str
        | bytes
        | ipaddress.IPv4Address
        | ipaddress.IPv6Address,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: IpAddr) -&gt; bool: ...
    def __le__(self, other: IpAddr) -&gt; bool: ...
    def __gt__(self, other: IpAddr) -&gt; bool: ...
    def __ge__(self, other: IpAddr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv4Address | ipaddress.IPv6Address: ...
    def to_ipv4(self) -&gt; Ipv4Addr: ...
    def to_ipv6(self) -&gt; Ipv6Addr: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, ip: str) -&gt; IpAddr: ...

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def version(self) -&gt; int: ...
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; bool: ...
    @property
    def is_ipv6(self) -&gt; bool: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_canonical(self) -&gt; IpAddr: ...

</code></pre>
<h2 id="ry.ryo3._tokio"><a class="header" href="#ry.ryo3._tokio"><code>ry.ryo3._tokio</code></a></h2>
<pre><code class="language-python">"""ryo4-tokio types"""

import pathlib
import typing as t
from collections.abc import Generator
from types import TracebackType

import typing_extensions as te

from ry import Bytes
from ry._types import Buffer, FsPathLike
from ry.ryo3._std import FileType, Metadata


# =============================================================================
# FS
# =============================================================================
async def canonicalize_async(path: FsPathLike) -&gt; FsPathLike: ...
async def copy_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def create_dir_async(path: FsPathLike) -&gt; None: ...
async def create_dir_all_async(path: FsPathLike) -&gt; None: ...
async def hard_link_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def metadata_async(path: FsPathLike) -&gt; None: ...
async def read_async(path: FsPathLike) -&gt; Bytes: ...
async def remove_dir_async(path: FsPathLike) -&gt; None: ...
async def remove_dir_all_async(path: FsPathLike) -&gt; None: ...
async def remove_file_async(path: FsPathLike) -&gt; None: ...
async def read_link_async(path: FsPathLike) -&gt; FsPathLike: ...
async def read_to_string_async(path: FsPathLike) -&gt; str: ...
async def rename_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def write_async(path: FsPathLike, data: Buffer) -&gt; None: ...
async def try_exists_async(path: FsPathLike) -&gt; bool: ...
async def exists_async(path: FsPathLike) -&gt; bool: ...


class DirEntryAsync:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def basename(self) -&gt; str: ...
    @property
    async def metadata(self) -&gt; Metadata: ...
    @property
    async def file_type(self) -&gt; FileType: ...


class ReadDirAsync:
    """Async iterator for read_dir_async"""

    def __aiter__(self) -&gt; ReadDirAsync: ...
    async def __anext__(self) -&gt; DirEntryAsync: ...
    async def collect(self) -&gt; list[DirEntryAsync]: ...
    async def take(self, n: int) -&gt; list[DirEntryAsync]: ...


async def read_dir_async(path: FsPathLike) -&gt; ReadDirAsync: ...


# =============================================================================
# SLEEP
# =============================================================================
async def sleep_async(seconds: float) -&gt; float: ...
async def asleep(seconds: float) -&gt; float:
    """Alias for sleep_async"""


class AsyncFile:
    def __init__(
        self, path: FsPathLike, mode: str = "r", buffering: int = -1
    ) -&gt; None: ...
    def __aiter__(self) -&gt; te.Self: ...
    def __await__(self) -&gt; Generator[t.Any, t.Any, te.Self]: ...
    async def __anext__(self) -&gt; Bytes: ...
    async def __aenter__(self) -&gt; te.Self: ...
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -&gt; None: ...
    async def close(self) -&gt; None: ...
    async def flush(self) -&gt; None: ...
    async def isatty(self) -&gt; te.NoReturn: ...
    async def open(self) -&gt; None: ...
    async def peek(self, size: int = ..., /) -&gt; Bytes: ...
    async def read(self, size: int = ..., /) -&gt; Bytes: ...
    async def readable(self) -&gt; bool: ...
    async def readall(self) -&gt; Bytes: ...
    async def readline(self, size: int | None = ..., /) -&gt; Bytes: ...
    async def readlines(self, hint: int = ..., /) -&gt; list[Bytes]: ...
    async def seek(self, offset: int, whence: int = ..., /) -&gt; int: ...
    async def seekable(self) -&gt; bool: ...
    async def tell(self) -&gt; int: ...
    async def truncate(self, size: int | None = ..., /) -&gt; int: ...
    async def writable(self) -&gt; bool: ...
    async def write(self, b: Buffer, /) -&gt; int: ...
    @property
    def closed(self) -&gt; bool: ...


def aiopen(
    path: FsPathLike, mode: str = "r", buffering: int = -1
) -&gt; AsyncFile: ...

</code></pre>
<h2 id="ry.ryo3._unindent"><a class="header" href="#ry.ryo3._unindent"><code>ry.ryo3._unindent</code></a></h2>
<pre><code class="language-python">"""ryo3-unindent types"""


def unindent(string: str) -&gt; str: ...
def unindent_bytes(string: bytes) -&gt; bytes: ...

</code></pre>
<h2 id="ry.ryo3._url"><a class="header" href="#ry.ryo3._url"><code>ry.ryo3._url</code></a></h2>
<pre><code class="language-python">from ipaddress import IPv4Address, IPv6Address


class URL:
    def __init__(
        self, url: str | URL, *, params: dict[str, str] | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, url: str) -&gt; URL: ...
    @classmethod
    def parse_with_params(cls, url: str, params: dict[str, str]) -&gt; URL: ...
    @classmethod
    def from_directory_path(cls, path: str) -&gt; URL: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __fspath__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: URL) -&gt; bool: ...
    def __gt__(self, other: URL) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: URL) -&gt; bool: ...
    def __lt__(self, other: URL) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rtruediv__(self, relative: str) -&gt; URL: ...
    def __truediv__(self, relative: str) -&gt; URL: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None: ...
    @property
    def port_or_known_default(self) -&gt; int | None: ...
    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_pairs(self) -&gt; tuple[tuple[str, str], ...]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def username(self) -&gt; str: ...
    @property
    def origin(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def make_relative(self, u: URL) -&gt; URL: ...
    def to_filepath(self) -&gt; str: ...
    def replace_fragment(self, fragment: str | None = None) -&gt; URL: ...
    def replace_host(self, host: str | None = None) -&gt; URL: ...
    def replace_ip_host(self, host: IPv4Address | IPv6Address) -&gt; URL: ...
    def replace_password(self, password: str | None = None) -&gt; URL: ...
    def replace_path(self, path: str) -&gt; URL: ...
    def replace_port(self, port: int | None = None) -&gt; URL: ...
    def replace_query(self, query: str | None = None) -&gt; URL: ...
    def replace_scheme(self, scheme: str) -&gt; URL: ...
    def replace_username(self, username: str) -&gt; URL: ...
    def socket_addrs(self) -&gt; None: ...
    def replace(
        self,
        *,
        fragment: str | None = None,
        host: str | None = None,
        ip_host: IPv4Address | None = None,
        password: str | None = None,
        path: str | None = None,
        port: int | None = None,
        query: str | None = None,
        scheme: str | None = None,
        username: str | None = None,
    ) -&gt; URL: ...

</code></pre>
<h2 id="ry.ryo3._walkdir"><a class="header" href="#ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></a></h2>
<pre><code class="language-python">"""ryo3-walkdir types"""

import typing as t
from os import PathLike

from ry import FileType, FsPath, Glob, GlobSet, Globster


class WalkDirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; FsPath: ...
    @property
    def file_name(self) -&gt; str: ...
    @property
    def depth(self) -&gt; int: ...
    @property
    def path_is_symlink(self) -&gt; bool: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def len(self) -&gt; int: ...


_T_walkdir = t.TypeVar(
    "_T_walkdir",
    bound=WalkDirEntry | str,
)


class WalkdirGen(t.Generic[_T_walkdir]):
    """walkdir::Walkdir iterable wrapper"""

    def __next__(self) -&gt; _T_walkdir: ...
    def __iter__(self) -&gt; t.Iterator[_T_walkdir]: ...
    def collect(self) -&gt; list[_T_walkdir]: ...
    def take(self, n: int = 1) -&gt; list[_T_walkdir]: ...


@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    *,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
    objects: t.Literal[True],
) -&gt; WalkdirGen[WalkDirEntry]: ...
@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    *,
    objects: t.Literal[False] = False,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
) -&gt; WalkdirGen[str]: ...

</code></pre>
<h2 id="ry.ryo3._which"><a class="header" href="#ry.ryo3._which"><code>ry.ryo3._which</code></a></h2>
<pre><code class="language-python">"""ryo3-which types"""

from pathlib import Path

from ry.ryo3._regex import Regex


def which(cmd: str, path: None | str = None) -&gt; Path | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[Path]: ...
def which_re(regex: str | Regex, path: None | str = None) -&gt; list[Path]: ...

</code></pre>
<h2 id="ry.dirs"><a class="header" href="#ry.dirs"><code>ry.dirs</code></a></h2>
<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...

</code></pre>
<h2 id="ry.http"><a class="header" href="#ry.http"><code>ry.http</code></a></h2>
<pre><code class="language-python">import typing as t
from collections.abc import Mapping

import typing_extensions

# fmt: off
HttpVersionLike: typing_extensions.TypeAlias = t.Literal[
    "HTTP/0.9", "0.9", 0,
    "HTTP/1.0", "1.0", 1, 10,
    "HTTP/1.1", "1.1", 11,
    "HTTP/2.0", "2.0", 2, 20,
    "HTTP/3.0", "3.0", 3, 30,
]
# fmt: on

_VT = t.TypeVar("_VT", bound=str | t.Sequence[str])


class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(
        self,
        headers: Mapping[str, _VT] | Headers | None = None,
        /,
        **kwargs: _VT,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: str) -&gt; str: ...
    def __setitem__(self, key: str, value: str) -&gt; None: ...
    def __delitem__(self, key: str) -&gt; None: ...
    def __contains__(self, key: str) -&gt; bool: ...
    def __or__(self, other: Headers | dict[str, str]) -&gt; Headers: ...
    def __ror__(self, other: Headers | dict[str, str]) -&gt; Headers: ...
    def __iter__(self) -&gt; t.Iterator[str]: ...
    def __bool__(self) -&gt; bool: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def to_py(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def asdict(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def stringify(self, *, fmt: bool = False) -&gt; str: ...
    def append(self, key: str, value: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def contains_key(self, key: str) -&gt; bool: ...
    def get(self, key: str) -&gt; str | None: ...
    def get_all(self, key: str) -&gt; list[str]: ...
    def insert(self, key: str, value: str) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def keys(self) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def pop(self, key: str) -&gt; str: ...
    def remove(self, key: str) -&gt; None: ...
    def update(self, headers: Headers | dict[str, str]) -&gt; None: ...
    def values(self) -&gt; list[str]: ...
    @property
    def is_flat(self) -&gt; bool: ...


class HttpStatus:
    def __init__(self, code: int) -&gt; None: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: HttpStatus | int) -&gt; bool: ...
    def __le__(self, other: HttpStatus | int) -&gt; bool: ...
    def __gt__(self, other: HttpStatus | int) -&gt; bool: ...
    def __ge__(self, other: HttpStatus | int) -&gt; bool: ...
    def to_py(self) -&gt; int: ...
    @property
    def reason(self) -&gt; str: ...
    @property
    def canonical_reason(self) -&gt; str: ...
    @property
    def is_informational(self) -&gt; bool: ...
    @property
    def is_success(self) -&gt; bool: ...
    @property
    def is_redirect(self) -&gt; bool: ...
    @property
    def is_redirection(self) -&gt; bool: ...
    @property
    def is_client_error(self) -&gt; bool: ...
    @property
    def is_server_error(self) -&gt; bool: ...
    @property
    def is_error(self) -&gt; bool: ...
    @property
    def is_ok(self) -&gt; bool: ...
    @property
    def ok(self) -&gt; bool: ...

    # =========================================================================
    # CONST STATUS CODES
    # =========================================================================
    CONTINUE: HttpStatus  # 100 ~ Continue
    SWITCHING_PROTOCOLS: HttpStatus  # 101 ~ Switching Protocols
    PROCESSING: HttpStatus  # 102 ~ Processing
    OK: HttpStatus  # 200 ~ OK
    CREATED: HttpStatus  # 201 ~ Created
    ACCEPTED: HttpStatus  # 202 ~ Accepted
    NON_AUTHORITATIVE_INFORMATION: (
        HttpStatus  # 203 ~ Non Authoritative Information
    )
    NO_CONTENT: HttpStatus  # 204 ~ No Content
    RESET_CONTENT: HttpStatus  # 205 ~ Reset Content
    PARTIAL_CONTENT: HttpStatus  # 206 ~ Partial Content
    MULTI_STATUS: HttpStatus  # 207 ~ Multi-Status
    ALREADY_REPORTED: HttpStatus  # 208 ~ Already Reported
    IM_USED: HttpStatus  # 226 ~ IM Used
    MULTIPLE_CHOICES: HttpStatus  # 300 ~ Multiple Choices
    MOVED_PERMANENTLY: HttpStatus  # 301 ~ Moved Permanently
    FOUND: HttpStatus  # 302 ~ Found
    SEE_OTHER: HttpStatus  # 303 ~ See Other
    NOT_MODIFIED: HttpStatus  # 304 ~ Not Modified
    USE_PROXY: HttpStatus  # 305 ~ Use Proxy
    TEMPORARY_REDIRECT: HttpStatus  # 307 ~ Temporary Redirect
    PERMANENT_REDIRECT: HttpStatus  # 308 ~ Permanent Redirect
    BAD_REQUEST: HttpStatus  # 400 ~ Bad Request
    UNAUTHORIZED: HttpStatus  # 401 ~ Unauthorized
    PAYMENT_REQUIRED: HttpStatus  # 402 ~ Payment Required
    FORBIDDEN: HttpStatus  # 403 ~ Forbidden
    NOT_FOUND: HttpStatus  # 404 ~ Not Found
    METHOD_NOT_ALLOWED: HttpStatus  # 405 ~ Method Not Allowed
    NOT_ACCEPTABLE: HttpStatus  # 406 ~ Not Acceptable
    PROXY_AUTHENTICATION_REQUIRED: (
        HttpStatus  # 407 ~ Proxy Authentication Required
    )
    REQUEST_TIMEOUT: HttpStatus  # 408 ~ Request Timeout
    CONFLICT: HttpStatus  # 409 ~ Conflict
    GONE: HttpStatus  # 410 ~ Gone
    LENGTH_REQUIRED: HttpStatus  # 411 ~ Length Required
    PRECONDITION_FAILED: HttpStatus  # 412 ~ Precondition Failed
    PAYLOAD_TOO_LARGE: HttpStatus  # 413 ~ Payload Too Large
    URI_TOO_LONG: HttpStatus  # 414 ~ URI Too Long
    UNSUPPORTED_MEDIA_TYPE: HttpStatus  # 415 ~ Unsupported Media Type
    RANGE_NOT_SATISFIABLE: HttpStatus  # 416 ~ Range Not Satisfiable
    EXPECTATION_FAILED: HttpStatus  # 417 ~ Expectation Failed
    IM_A_TEAPOT: HttpStatus  # 418 ~ I'm a teapot
    MISDIRECTED_REQUEST: HttpStatus  # 421 ~ Misdirected Request
    UNPROCESSABLE_ENTITY: HttpStatus  # 422 ~ Unprocessable Entity
    LOCKED: HttpStatus  # 423 ~ Locked
    FAILED_DEPENDENCY: HttpStatus  # 424 ~ Failed Dependency
    TOO_EARLY: HttpStatus  # 425 ~ Too Early
    UPGRADE_REQUIRED: HttpStatus  # 426 ~ Upgrade Required
    PRECONDITION_REQUIRED: HttpStatus  # 428 ~ Precondition Required
    TOO_MANY_REQUESTS: HttpStatus  # 429 ~ Too Many Requests
    REQUEST_HEADER_FIELDS_TOO_LARGE: (
        HttpStatus  # 431 ~ Request Header Fields Too Large
    )
    UNAVAILABLE_FOR_LEGAL_REASONS: (
        HttpStatus  # 451 ~ Unavailable For Legal Reasons
    )
    INTERNAL_SERVER_ERROR: HttpStatus  # 500 ~ Internal Server Error
    NOT_IMPLEMENTED: HttpStatus  # 501 ~ Not Implemented
    BAD_GATEWAY: HttpStatus  # 502 ~ Bad Gateway
    SERVICE_UNAVAILABLE: HttpStatus  # 503 ~ Service Unavailable
    GATEWAY_TIMEOUT: HttpStatus  # 504 ~ Gateway Timeout
    HTTP_VERSION_NOT_SUPPORTED: HttpStatus  # 505 ~ HTTP Version Not Supported
    VARIANT_ALSO_NEGOTIATES: HttpStatus  # 506 ~ Variant Also Negotiates
    INSUFFICIENT_STORAGE: HttpStatus  # 507 ~ Insufficient Storage
    LOOP_DETECTED: HttpStatus  # 508 ~ Loop Detected
    NOT_EXTENDED: HttpStatus  # 510 ~ Not Extended
    NETWORK_AUTHENTICATION_REQUIRED: (
        HttpStatus  # 511 ~ Network Authentication Required
    )

</code></pre>
<h2 id="ry.ulid"><a class="header" href="#ry.ulid"><code>ry.ulid</code></a></h2>
<pre><code class="language-python">import builtins
import datetime as pydt
import typing as t
import uuid
from collections.abc import Callable as Callable

from pydantic import (
    GetCoreSchemaHandler as GetCoreSchemaHandler,
)
from pydantic import (
    ValidatorFunctionWrapHandler as ValidatorFunctionWrapHandler,
)
from pydantic_core import CoreSchema as CoreSchema
from ulid import base32 as base32
from ulid import constants as constants


class ULID:
    def __init__(self, value: builtins.bytes | str | None = None) -&gt; None: ...

    # ----------------
    # INSTANCE METHODS
    # ----------------
    def to_uuid(self) -&gt; uuid.UUID: ...
    def to_uuid4(self) -&gt; uuid.UUID: ...

    # -------
    # DUNDERS
    # -------
    def __int__(self) -&gt; int: ...
    def __bytes__(self) -&gt; builtins.bytes: ...
    def __lt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __ge__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __gt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __le__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...

    # ----------
    # PROPERTIES
    # ----------
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def timestamp(self) -&gt; float: ...
    @property
    def datetime(self) -&gt; pydt.datetime: ...
    @property
    def hex(self) -&gt; str: ...

    # -------------
    # CLASS METHODS
    # -------------
    @classmethod
    def from_datetime(cls, value: pydt.datetime) -&gt; ULID: ...
    @classmethod
    def from_timestamp(cls, value: float) -&gt; ULID: ...
    @classmethod
    def from_uuid(cls, value: uuid.UUID) -&gt; ULID: ...
    @classmethod
    def from_bytes(cls, bytes_: builtins.bytes) -&gt; ULID: ...
    @classmethod
    def from_hex(cls, value: str) -&gt; ULID: ...
    @classmethod
    def from_str(cls, string: str) -&gt; ULID: ...
    @classmethod
    def from_int(cls, value: int) -&gt; ULID: ...
    @classmethod
    def parse(cls, value: t.Any) -&gt; ULID: ...

    # --------
    # PYDANTIC
    # --------
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source: t.Any, handler: GetCoreSchemaHandler
    ) -&gt; CoreSchema: ...

</code></pre>
<h2 id="ry.uuid"><a class="header" href="#ry.uuid"><code>ry.uuid</code></a></h2>
<pre><code class="language-python">"""ryo3-uuid types

based on typeshed types for python's builtin uuid module

REF: https://github.com/python/typeshed/blob/main/stdlib/uuid.pyi
"""

import builtins
import uuid as pyuuid
from enum import Enum

from typing_extensions import TypeAlias

from ry._types import Buffer

_FieldsType: TypeAlias = tuple[int, int, int, int, int, int]


class SafeUUID(Enum):
    safe = 0
    unsafe = -1
    unknown = None


class UUID:
    # NAMESPACE_DNS: UUID
    # NAMESPACE_URL: UUID
    # NAMESPACE_OID: UUID
    # NAMESPACE_X500: UUID

    def __init__(
        self,
        hex: str | None = None,
        bytes: builtins.bytes | None = None,
        bytes_le: builtins.bytes | None = None,
        fields: _FieldsType | None = None,
        int: builtins.int | None = None,
        version: builtins.int | None = None,
        *,
        is_safe: SafeUUID = ...,
    ) -&gt; None: ...
    @property
    def is_safe(self) -&gt; SafeUUID: ...
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def bytes_le(self) -&gt; builtins.bytes: ...
    @property
    def clock_seq(self) -&gt; builtins.int: ...
    @property
    def clock_seq_hi_variant(self) -&gt; builtins.int: ...
    @property
    def clock_seq_low(self) -&gt; builtins.int: ...
    @property
    def fields(self) -&gt; _FieldsType: ...
    @property
    def hex(self) -&gt; str: ...
    @property
    def int(self) -&gt; builtins.int: ...
    @property
    def node(self) -&gt; builtins.int: ...
    @property
    def time(self) -&gt; builtins.int: ...
    @property
    def time_hi_version(self) -&gt; builtins.int: ...
    @property
    def time_low(self) -&gt; builtins.int: ...
    @property
    def time_mid(self) -&gt; builtins.int: ...
    @property
    def urn(self) -&gt; str: ...
    @property
    def variant(self) -&gt; str: ...
    @property
    def version(self) -&gt; builtins.int | None: ...
    def __int__(self) -&gt; builtins.int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: UUID) -&gt; bool: ...
    def __le__(self, other: UUID) -&gt; bool: ...
    def __gt__(self, other: UUID) -&gt; bool: ...
    def __ge__(self, other: UUID) -&gt; bool: ...
    def __hash__(self) -&gt; builtins.int: ...
    def to_py(self) -&gt; pyuuid.UUID: ...


def getnode() -&gt; builtins.int: ...
def uuid1(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid3(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid4() -&gt; UUID: ...
def uuid5(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid6(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid7(timestamp: int | None = None) -&gt; UUID: ...
def uuid8(data: Buffer) -&gt; UUID: ...


NAMESPACE_DNS: UUID
NAMESPACE_URL: UUID
NAMESPACE_OID: UUID
NAMESPACE_X500: UUID
RESERVED_NCS: str
RFC_4122: str
RESERVED_MICROSOFT: str
RESERVED_FUTURE: str

</code></pre>
<h2 id="ry.xxhash"><a class="header" href="#ry.xxhash"><code>ry.xxhash</code></a></h2>
<pre><code class="language-python">import typing as t

from ry._types import Buffer


@t.final
class Xxh32:
    name: t.Literal["xxh32"]
    digest_size: t.Literal[4]
    block_size: t.Literal[16]

    def __init__(self, input: Buffer = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh64:
    name: t.Literal["xxh64"]
    digest_size: t.Literal[8]
    block_size: t.Literal[32]

    def __init__(
        self, input: Buffer | None = None, seed: int | None = ...
    ) -&gt; None: ...
    def update(self, input: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh64: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh3:
    name: t.Literal["xxh3"]
    digest_size: int  # xxh3_64: 8, xxh3_128: 16
    block_size: int  # xxh3_64: 32, xxh3_128: 64

    def __init__(
        self,
        input: Buffer = ...,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, input: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def digest128(self) -&gt; bytes: ...
    def hexdigest128(self) -&gt; str: ...
    def intdigest128(self) -&gt; int: ...
    def copy(self) -&gt; Xxh3: ...
    def reset(self) -&gt; None: ...


def xxh32_digest(input: Buffer, seed: int | None = None) -&gt; bytes: ...
def xxh32_hexdigest(input: Buffer, seed: int | None = None) -&gt; str: ...
def xxh32_intdigest(input: Buffer, seed: int | None = None) -&gt; int: ...


# xxh64
def xxh64_digest(input: Buffer, seed: int | None = None) -&gt; bytes: ...
def xxh64_hexdigest(input: Buffer, seed: int | None = None) -&gt; str: ...
def xxh64_intdigest(input: Buffer, seed: int | None = None) -&gt; int: ...


# xxh128
def xxh128_digest(input: Buffer, seed: int | None = None) -&gt; bytes: ...
def xxh128_hexdigest(input: Buffer, seed: int | None = None) -&gt; str: ...
def xxh128_intdigest(input: Buffer, seed: int | None = None) -&gt; int: ...


# xxh3
def xxh3_64_digest(input: Buffer, seed: int | None = None) -&gt; bytes: ...
def xxh3_64_intdigest(input: Buffer, seed: int | None = None) -&gt; int: ...
def xxh3_64_hexdigest(input: Buffer, seed: int | None = None) -&gt; str: ...
def xxh3_digest(input: Buffer, seed: int | None = None) -&gt; bytes: ...
def xxh3_intdigest(input: Buffer, seed: int | None = None) -&gt; int: ...
def xxh3_hexdigest(input: Buffer, seed: int | None = None) -&gt; str: ...


# xxh128
def xxh3_128_digest(input: Buffer, seed: int | None = None) -&gt; bytes: ...
def xxh3_128_intdigest(input: Buffer, seed: int | None = None) -&gt; int: ...
def xxh3_128_hexdigest(input: Buffer, seed: int | None = None) -&gt; str: ...

</code></pre>
<h2 id="ry.zstd"><a class="header" href="#ry.zstd"><code>ry.zstd</code></a></h2>
<pre><code class="language-python">from ry import Bytes
from ry._types import Buffer

__zstd_version__: str  # zstd version string ("1.5.7" as of 2025-03-14)
BLOCKSIZELOG_MAX: int
BLOCKSIZE_MAX: int
CLEVEL_DEFAULT: int  # default=3 (as of 2025-03-14)
CONTENTSIZE_ERROR: int
CONTENTSIZE_UNKNOWN: int
MAGICNUMBER: int
MAGIC_DICTIONARY: int
MAGIC_SKIPPABLE_MASK: int
MAGIC_SKIPPABLE_START: int
VERSION_MAJOR: int
VERSION_MINOR: int
VERSION_NUMBER: int
VERSION_RELEASE: int


# =============================================================================
# PYFUNCTIONS
# =============================================================================
# __COMPRESSION__
def compress(data: Buffer, level: int = CLEVEL_DEFAULT) -&gt; Bytes: ...
def encode(data: Buffer, level: int = CLEVEL_DEFAULT) -&gt; Bytes: ...
def zstd(data: Buffer, level: int = CLEVEL_DEFAULT) -&gt; Bytes: ...
def zstd_compress(data: Buffer, level: int = CLEVEL_DEFAULT) -&gt; Bytes: ...
def zstd_encode(data: Buffer, level: int = CLEVEL_DEFAULT) -&gt; Bytes: ...


# __DECOMPRESSION__
def decode(data: Buffer) -&gt; Bytes: ...
def decompress(data: Buffer) -&gt; Bytes: ...
def unzstd(data: Buffer) -&gt; Bytes: ...
def zstd_decode(data: Buffer) -&gt; Bytes: ...
def zstd_decompress(data: Buffer) -&gt; Bytes: ...


# __MAGIC__
def is_zstd(data: Buffer) -&gt; bool: ...

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="food-4-thought"><a class="header" href="#food-4-thought">food-4-thought</a></h1>
<p>thinking out loud…</p>
<hr />
<h1 id="rydev"><a class="header" href="#rydev"><code>ry.dev</code></a></h1>
<p>For people who find <code>ry.dev</code> it is a module that exports all the things in ry as
well as can be used as a repl; <code>python -m ry.dev</code> will start a repl (with
ipython if installed else python-repl) with all of ry already imported. I
(jesse) use this super often for testing things out.</p>
<hr />
<h2 id="string-bridge"><a class="header" href="#string-bridge">string-bridge?</a></h2>
<p>The <code>jiter</code> crate uses a string-cache to store python-strings to avoid the
overhead of converting strings to python strings. A global string bridge and/or
caching setup for other types of structs that often convert to strings might be
worth considering?</p>
<hr />
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Coming up with names is hard… I (jesse) want to strike a balance between being
clear but also close to the wrapped libraries…</p>
<ul>
<li>Should jiff’s <code>Zoned</code> be <code>Zoned</code> in python? or <code>ZonedDateTime</code>? (currently
<code>ZonedDateTime</code>)</li>
<li>Should jiff’s <code>Span</code> be <code>Span</code> in python? or <code>TimeSpan</code>? (currently
<code>TimeSpan</code>)</li>
<li>Should reqwest’s <code>Client</code> be <code>Client</code> in python? or <code>HttpClient</code>? (currently
<code>HttpClient</code>)</li>
</ul>
<hr />
<h2 id="flat-nested-submodules"><a class="header" href="#flat-nested-submodules">Flat? Nested submodules?</a></h2>
<p>I like flat more, but nesting submodules might be preferable for some people and
would allow for more flexibility in naming…</p>
<p>pros &amp; cons:</p>
<ul>
<li>flat:
<ul>
<li>pros:
<ul>
<li>easier to import</li>
<li>easier to work on</li>
<li>no need to remember where things are</li>
<li>type annotations are easier to setup/dist</li>
</ul>
</li>
<li>cons:
<ul>
<li>name conflicts</li>
<li>type annotations are harder to read bc of huge file</li>
<li>harder to remember where things are</li>
</ul>
</li>
</ul>
</li>
<li>nested:
<ul>
<li>pros:
<ul>
<li>no name conflicts</li>
<li>easier to remember where things are</li>
<li>type annotations are easier to read</li>
<li>importing <code>ry.jiff</code> (or <code>ry.ryo3.jiff</code> tbd) is more explicitly the <code>jiff</code>
wrapper(s)</li>
</ul>
</li>
<li>cons:
<ul>
<li>Don’t know how type annotations should be laid out… if there is a
submodule called <code>ry.ryo3.reqwest</code>, do you import from <code>ry.ryo3.reqwest</code>
or do we reexport from <code>ry.reqwest</code>? Then were doe the type-annotations
live and how are they laid out without having to duplicate/shim them?</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="pypi-size-limit"><a class="header" href="#pypi-size-limit">pypi size limit</a></h2>
<p>The pypi project size limit of 10gb was reached. I (jesse) won’t request a limit
raise until the package is more stable and hits some sort of <code>v0.1.x</code>, SOOOOOO
for now I will be:</p>
<ul>
<li>deleting older versions of ry from pypi as needed</li>
<li>update the release gh-action to push the built wheels to the releases page so
they are not lost into the ether…</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jiff"><a class="header" href="#jiff">jiff</a></h1>
<p>docs.rs: <a href="https://docs.rs/jiff">https://docs.rs/jiff</a></p>
<p>crates: <a href="https://crates.io/crates/jiff">https://crates.io/crates/jiff</a></p>
<hr />
<p>The <code>jiff</code> crate has a super excellent API that is very ergonomic to use and
<code>ry</code> provides a nearly complete wrapper around it.</p>
<p>A good amount of time, and a greater amount of thought has gone into balancing
the <code>jiff</code> python api to be both ergonomic and performant.</p>
<h2 id="python-conversions"><a class="header" href="#python-conversions">python-conversions</a></h2>
<p>The structs under <code>ryo3-jiff</code> are convertible to/from python’s <code>datetime.*</code>
types and the conversions are pretty well tested (ty hypothesis).</p>
<h3 id="pyo3-v0240--jiff-02"><a class="header" href="#pyo3-v0240--jiff-02"><code>pyo3-v0.24.0</code> &amp; <code>jiff-02</code></a></h3>
<p>The conversions to/from python <code>datetime.*</code> types were originally hand rolled (
by me (jesse)) using the ‘new-type’ pattern, HOWEVER <code>pyo3-v0.24.0</code> provides
conversions via the <code>jiff-02</code> feature flag, which is what is used now.</p>
<p><code>ry-v0.0.37</code> will be the last version with the mostly hand rolled conversions.</p>
<p><code>ry-v0.0.38</code> will be the first version with the <code>jiff-02</code> feature flag.</p>
<p>As of 2025-03-12 <code>pyo3</code> does not seem to support converting <code>Span</code> -&gt;
<code>datetime.timedelta</code>, so that is still hand rolled.</p>
<hr />
<h2 id="ry-vs-whenever"><a class="header" href="#ry-vs-whenever"><code>ry</code> vs <code>whenever</code></a></h2>
<p>There is another library called
<a href="https://github.com/ariebovenberg/whenever"> <code>whenever</code></a> that provides a similar
datetime library to that of <code>ryo3-jiff</code> (both <code>jiff</code> and <code>whenever</code> are based on
the <a href="https://tc39.es/proposal-temporal/docs/">temporal</a> API).</p>
<p>No formal benchmarks between <code>ry</code> and <code>whenever</code> have been done, but I have
copy-pasta-ed some of the benchmarks from the <code>whenever</code> repo and translated
them to <code>ry</code> and the results were pretty similar; <code>whenever</code> is faster for some
things, <code>ry</code> is faster for others, but both are wildly more performant than
python’s built in <code>datetime</code> module and <code>pendulum</code> – differences in performance
are almost all measured in nanoseconds.</p>
<p>Big shoutout to “Mr. Dutch Airlines” guy
(<a href="https://github.com/ariebovenberg">@ariebovenberg</a>) who wrote <code>whenever</code>! Love
the name of the library too!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
