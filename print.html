<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ry(o3) docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ry(o3) docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jessekrubin/ry" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ry"><a class="header" href="#ry">ry</a></h1>
<p>ry = rust and python and bears, oh my!</p>
<p><a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/v/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/pyversions/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Python Version" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/wheel/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Wheel" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/dm/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Downloads" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/status/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Status" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/l/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - License" /></a></p>
<p><strong>DOCS:</strong> https://ryo3.dev (WIP)</p>
<p>python bindings for rust crates I wish existed in python</p>
<p><strong>THIS IS A WORK IN PROGRESS</strong></p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-bash">pip install ry
uv add ry
</code></pre>
<p><strong>Check install:</strong> <code>python -m ry</code></p>
<h2 id="what-and-why"><a class="header" href="#what-and-why">What and why?</a></h2>
<p>This is a collection of pyo3-wrappers for rust crates I wish existed in python.</p>
<p>It all started with me wanting a fast python <code>xxhash</code> and <code>fnv-64</code></p>
<h2 id="who"><a class="header" href="#who">Who?</a></h2>
<ul>
<li>jessekrubin <a href="mailto:jessekrubin@gmail.com">jessekrubin@gmail.com</a></li>
<li>possibly you!?</li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><em>(aka: questions that I have been asking myself)</em></p>
<ul>
<li><strong>Q:</strong> Why?
<ul>
<li><strong>A:</strong> I (jesse) needed several hashing functions for python and then kept
adding things as I needed them</li>
</ul>
</li>
<li><strong>Q:</strong> Does this have anything to do with the (excellent) package manager
<code>rye</code>?
<ul>
<li><strong>A:</strong> short answer: no. long answer: no, it does not.</li>
</ul>
</li>
<li><strong>Q:</strong> Why is the repo split into <code>ry</code> and <code>ryo3</code>?
<ul>
<li><strong>A:</strong> <code>ry</code> is the python package, <code>ryo3</code> is a rust crate setup to let you
“register” functions you may want if you were writing your own pyo3-python
bindings library; maybe someday the <code>ryo3::libs</code> module will be split up
into separate packages</li>
</ul>
</li>
</ul>
<h2 id="crate-bindings"><a class="header" href="#crate-bindings">Crate bindings</a></h2>
<p>ryo3-std</p>
<ul>
<li>wrapped crates:
<ul>
<li><code>heck</code></li>
<li><code>jiter</code></li>
<li><code>shlex</code></li>
<li><code>sqlformat</code></li>
<li><code>url</code></li>
<li><code>which</code></li>
<li>compression:
<ul>
<li><code>brotli</code></li>
<li><code>bzip2</code></li>
<li><code>flate2</code></li>
<li><code>zstd</code></li>
</ul>
</li>
<li>hashing:
<ul>
<li><code>fnv</code></li>
<li><code>xxhash</code></li>
</ul>
</li>
<li>burnt-sushi:
<ul>
<li><code>globset</code> (formerly <a href="https://pypi.org/project/globsters/">globsters</a>)</li>
<li><code>jiff</code></li>
<li><code>walkdir</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="future"><a class="header" href="#future">FUTURE?</a></h3>
<ul>
<li><code>subprocess.redo</code> (subprocesses that are lessy finicky and support tee-ing)</li>
<li>wrappers:
<ul>
<li><code>ignore</code></li>
<li><code>http</code></li>
<li><code>regex</code></li>
<li><code>reqwest</code> (async http client / waiting on pyo3 asyncio to stabilize and for me to have more time)</li>
<li><code>tokio</code> (<code>fs</code> and <code>process</code>)</li>
<li><code>tracing</code> (could be nicer than python’s awful logging lib – currently a part of ry/ryo3 for my dev purposes - currently has impl thingy in utiles)</li>
<li><code>tracing</code> (eg logging)</li>
<li><code>uuid</code></li>
</ul>
</li>
<li>organization
<ul>
<li>split up the <code>ryo3</code> type annotations?</li>
<li>chunk things into smaller sub-packages within the <code>ry</code> package?</li>
</ul>
</li>
</ul>
<hr />
<h2 id="api"><a class="header" href="#api">API</a></h2>
<!-- API-START -->
<h2 id="ry__init__"><a class="header" href="#ry__init__"><code>ry.__init__</code></a></h2>
<pre><code class="language-python">"""ry api ~ type annotations"""

import datetime as pydt
import typing as t
from os import PathLike

from ry.types import (
    DateTimeTypedDict,
    DateTypedDict,
    TimeSpanTypedDict,
    TimeTypedDict,
)

from . import http as http
from .reqwest import (
    AsyncClient as AsyncClient,
)
from .reqwest import (
    Response as Response,
)
from .reqwest import (
    ResponseStream as ResponseStream,
)
from .reqwest import (
    fetch as fetch,
)

__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str

# =============================================================================
# TYPE ALIASES
# =============================================================================
JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)

# =============================================================================
# STD
# =============================================================================


class Duration:
    ZERO: Duration
    MIN: Duration
    MAX: Duration
    NANOSECOND: Duration
    MICROSECOND: Duration
    MILLISECOND: Duration
    SECOND: Duration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Duration) -&gt; bool: ...
    def __le__(self, other: Duration) -&gt; bool: ...
    def __gt__(self, other: Duration) -&gt; bool: ...
    def __ge__(self, other: Duration) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(
        self, other: Duration | pydt.timedelta, op: int
    ) -&gt; bool: ...
    def __str__(self) -&gt; str: ...
    def abs_diff(self, other: Duration) -&gt; Duration: ...
    def sleep(self) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[Duration], td: pydt.timedelta
    ) -&gt; Duration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; Duration: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; Duration: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; Duration: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; Duration: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; Duration: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; Duration: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_days(cls, days: int) -&gt; Duration: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; Duration: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Duration | None: ...
    def checked_div(self, other: Duration) -&gt; Duration | None: ...
    def checked_mul(self, other: Duration) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Duration | None: ...
    def div_duration_f32(self, other: Duration) -&gt; float: ...
    def div_duration_f64(self, other: Duration) -&gt; float: ...
    def div_f32(self, other: float) -&gt; Duration: ...
    def div_f64(self, other: float) -&gt; Duration: ...
    def mul_f32(self, other: float) -&gt; Duration: ...
    def mul_f64(self, other: float) -&gt; Duration: ...
    def saturating_add(self, other: Duration) -&gt; Duration: ...
    def saturating_mul(self, other: Duration) -&gt; Duration: ...
    def saturating_sub(self, other: Duration) -&gt; Duration: ...


class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; Instant: ...
    def __iadd__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Instant) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Instant | None: ...
    def checked_duration_since(self, earlier: Instant) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Instant | None: ...
    def duration_since(self, earlier: Instant) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: Instant) -&gt; Duration: ...


def instant() -&gt; Instant: ...


# =============================================================================
# RY03-CORE
# =============================================================================


class FsPath:
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __truediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def read_text(self) -&gt; str: ...
    def read_bytes(self) -&gt; bytes: ...
    def absolute(self) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def write_text(self, data: str) -&gt; None: ...
    def write_bytes(self, data: bytes) -&gt; None: ...
    def joinpath(self, *paths: str) -&gt; FsPath: ...
    def exists(self) -&gt; bool: ...
    def with_name(self, name: str) -&gt; FsPath: ...
    def with_suffix(self, suffix: str) -&gt; FsPath: ...
    def iterdir(self) -&gt; t.Iterator[FsPath]: ...
    def relative_to(self, other: PathLike[str] | str | FsPath) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...

    # TODO
    def __bytes__(self) -&gt; bytes: ...
    def as_uri(self) -&gt; str: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def string(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; FsPath: ...
    @classmethod
    def home(cls) -&gt; FsPath: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; FsPath: ...
    @property
    def parents(self) -&gt; t.Sequence[t.Self]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; str: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf
    # =========================================================================
    def _pop(self) -&gt; FsPath: ...
    def _push(self, path: PathLike[str] | str) -&gt; FsPath: ...
    def _set_extension(self, ext: str) -&gt; FsPath: ...
    def _set_file_name(self, name: str) -&gt; FsPath: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; t.Iterator[FsPath]: ...
    def canonicalize(self) -&gt; FsPath: ...
    def components(self) -&gt; t.Iterator[FsPath]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; FsPath: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, prefix: PathLike[str] | str) -&gt; FsPath: ...
    def with_extension(self, ext: str) -&gt; FsPath: ...
    def with_file_name(self, name: str) -&gt; FsPath: ...


FsPathLike = str | FsPath | PathLike[str]


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: FsPathLike) -&gt; None: ...
def ls(path: FsPathLike | None = None) -&gt; list[FsPath]: ...
def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """


# =============================================================================
# SLEEP
# =============================================================================
def sleep(seconds: float) -&gt; float: ...
async def sleep_async(seconds: float) -&gt; float: ...


# =============================================================================
# FILESYSTEM
# =============================================================================
def read_text(path: FsPathLike) -&gt; str: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def write_text(path: FsPathLike, data: str) -&gt; None: ...
def write_bytes(path: FsPathLike, data: bytes) -&gt; None: ...


# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------
# |~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~|
# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------

# =============================================================================
# Regex
# =============================================================================


class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: str | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def is_match(self, string: str) -&gt; bool: ...


# =============================================================================
# WHICH
# =============================================================================
def which(cmd: str, path: None | str = None) -&gt; str | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[str]: ...
def which_re(regex: Regex, path: None | str = None) -&gt; list[str]: ...


# =============================================================================
# HECK
# =============================================================================


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...


# =============================================================================
# GLOBSET
# =============================================================================
class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def regex(self) -&gt; str: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globster(self) -&gt; Globster: ...


class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def glob(
    pattern: str,
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Glob: ...
def globs(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Globster: ...


# =============================================================================
# WALKDIR
# =============================================================================


class WalkdirGen:
    """walkdir::Walkdir iterable wrapper"""

    files: bool
    dirs: bool

    def __next__(self) -&gt; str: ...
    def __iter__(self) -&gt; t.Iterator[str]: ...
    def collect(self) -&gt; list[str]: ...


class FspathsGen:
    """walkdir iterable that yields FsPath objects"""

    files: bool
    dirs: bool

    def __next__(self) -&gt; FsPath: ...
    def __iter__(self) -&gt; t.Iterator[FsPath]: ...


def walkdir(
    path: FsPathLike | None = None,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | None = None,
) -&gt; WalkdirGen: ...
def fspaths(
    path: FsPathLike | None = None,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
) -&gt; WalkdirGen: ...


# =============================================================================
# SHLEX
# =============================================================================
def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""
    ...


# =============================================================================
# JSON
# =============================================================================
def parse_json(
    data: bytes | str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: t.Literal[
        True, False, "off", "on", "trailing-strings"
    ] = False,
    catch_duplicate_keys: bool = False,
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: t.Literal[
        True, False, "off", "on", "trailing-strings"
    ] = False,
    catch_duplicate_keys: bool = False,
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: t.Literal[
        True, False, "off", "on", "trailing-strings"
    ] = False,
    catch_duplicate_keys: bool = False,
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...


# =============================================================================
# FORMATTING
# =============================================================================
def fmt_nbytes(nbytes: int) -&gt; str: ...
def unindent(string: str) -&gt; str: ...
def unindent_bytes(string: bytes) -&gt; bytes: ...


# =============================================================================
# FNV
# =============================================================================
class FnvHasher:
    name: t.Literal["fnv1a"]

    def __init__(self, input: bytes | None = None) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; FnvHasher: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def fnv1a(input: bytes) -&gt; FnvHasher: ...


# =============================================================================
# BROTLI
# =============================================================================
def brotli_encode(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(input: bytes) -&gt; bytes: ...
def brotli(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""


# =============================================================================
# BZIP2
# =============================================================================
def bzip2_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def bzip2_decode(input: bytes) -&gt; bytes: ...
def bzip2(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for bzip2_encode"""


# =============================================================================
# GZIP
# =============================================================================
def gzip_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def gzip_decode(input: bytes) -&gt; bytes: ...
def gzip(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for gzip_encode"""


def gunzip(input: bytes) -&gt; bytes:
    """Alias for gzip_decode"""


# =============================================================================
# ZSTD
# =============================================================================
def zstd_encode(input: bytes, level: int = 3) -&gt; bytes: ...
def zstd(input: bytes, level: int = 3) -&gt; bytes:
    """Alias for zstd_encode"""


def zstd_decode(input: bytes) -&gt; bytes: ...


# =============================================================================
# SQLFORMAT
# =============================================================================
SqlfmtParamValue = str | int | float | bool
TSqlfmtParamValue_co = t.TypeVar(
    "TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike = (
    dict[str, TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, TSqlfmtParamValue_co]]
    | t.Sequence[TSqlfmtParamValue_co]
)


class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[TSqlfmtParamValue_co] | SqlfmtQueryParams,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int = 2,  # -1 or any negative value will use tabs
    uppercase: bool | None = True,
    lines_between_statements: int = 1,
) -&gt; str: ...


# =============================================================================
# URL
# =============================================================================


class URL:
    def __init__(
        self, url: str, *, params: dict[str, str] | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, url: str) -&gt; URL: ...
    @classmethod
    def parse_with_params(cls, url: str, params: dict[str, str]) -&gt; URL: ...
    @classmethod
    def from_directory_path(cls, path: str) -&gt; URL: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: URL) -&gt; bool: ...
    def __gt__(self, other: URL) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: URL) -&gt; bool: ...
    def __lt__(self, other: URL) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rtruediv__(self, relative: str) -&gt; URL: ...
    def __truediv__(self, relative: str) -&gt; URL: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None: ...
    @property
    def port_or_known_default(self) -&gt; int | None: ...
    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_pairs(self) -&gt; list[tuple[str, str]]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def username(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def to_filepath(self) -&gt; str: ...
    def set_fragment(self, fragment: str) -&gt; None: ...
    def set_host(self, host: str) -&gt; None: ...
    def set_ip_host(self, host: str) -&gt; None: ...
    def set_password(self, password: str) -&gt; None: ...
    def set_path(self, path: str) -&gt; None: ...
    def set_port(self, port: int) -&gt; None: ...
    def set_query(self, query: str) -&gt; None: ...
    def set_scheme(self, scheme: str) -&gt; None: ...
    def set_username(self, username: str) -&gt; None: ...
    def socket_addrs(self) -&gt; None: ...


# =============================================================================
# JIFF
# =============================================================================
JIFF_UNIT_STRING = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JIFF_ROUND_MODE_STRING = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half_ceil",
    "half_floor",
    "half_expand",
    "half_trunc",
    "half_even",
]


class Date:
    MIN: Date
    MAX: Date
    ZERO: Date

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls: type[Date], date: pydt.date) -&gt; Date: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(
        cls: type[Date], year: int, week: int, weekday: int
    ) -&gt; Date: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls: type[Date], format: str, string: str) -&gt; Date: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __isub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int
    ) -&gt; DateTime: ...
    def asdict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: Date) -&gt; Date: ...
    def duration_until(self, other: Date) -&gt; Date: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; Date: ...
    def first_of_year(self) -&gt; Date: ...
    def in_leap_year(self) -&gt; bool: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; Date: ...
    def last_of_year(self) -&gt; Date: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Date]: ...
    def to_datetime(self, time: Time) -&gt; DateTime: ...
    def tomorrow(self) -&gt; Date: ...
    def yesterday(self) -&gt; Date: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoDateDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoDateDifference) -&gt; TimeSpan: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================

    def nth_weekday(self) -&gt; t.NoReturn: ...
    def nth_weekday_of_month(self) -&gt; t.NoReturn: ...
    def to_zoned(self) -&gt; t.NoReturn: ...
    def weekday(self) -&gt; t.NoReturn: ...


IntoDateDifference = (
    DateDifference
    | Date
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class DateDifference:
    def __init__(
        self,
        date: Date,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; DateDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; DateDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; DateDifference: ...
    def increment(self, increment: int) -&gt; DateDifference: ...


class Time:
    MIN: Time
    MAX: Time

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __isub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls: type[Time], format: str, string: str) -&gt; Time: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls: type[Time], time: pydt.time) -&gt; Time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def now(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; None: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def asdict(self) -&gt; TimeTypedDict: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Time]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    @t.overload
    def checked_sub(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def round(
        self,
        smallest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; Time: ...
    def to_datetime(self, d: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoTimeDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoTimeDifference) -&gt; TimeSpan: ...


IntoTimeDifference = (
    TimeDifference
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class TimeDifference:
    def __init__(
        self,
        date: Time,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; TimeDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; TimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; TimeDifference: ...
    def increment(self, increment: int) -&gt; TimeDifference: ...


class DateTime:
    MIN: DateTime
    MAX: DateTime
    ZERO: DateTime

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls: type[DateTime], format: str, string: str) -&gt; DateTime: ...
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls: type[DateTime], dt: pydt.datetime) -&gt; DateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls: type[DateTime]) -&gt; DateTime: ...
    @classmethod
    def from_parts(cls: type[DateTime], date: Date, time: Time) -&gt; DateTime: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __repr__(self) -&gt; str: ...
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __sub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __isub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def date(self) -&gt; Date: ...
    def time(self) -&gt; Time: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[DateTime]: ...
    def asdict(self) -&gt; DateTimeTypedDict: ...
    def round(self, options: JIFF_UNIT_STRING | DateTimeRound) -&gt; t.Self: ...
    def yesterday(self) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def saturating_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; t.NoReturn: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================
    def first_of_month(self) -&gt; DateTime: ...
    def first_of_year(self) -&gt; DateTime: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def duration_since(self, other: DateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: DateTime) -&gt; SignedDuration: ...
    def in_leap_year(self) -&gt; bool: ...
    def end_of_day(self) -&gt; DateTime: ...
    def last_of_month(self) -&gt; DateTime: ...
    def last_of_year(self) -&gt; DateTime: ...
    def start_of_day(self) -&gt; DateTime: ...
    def tomorrow(self) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoDateTimeDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoDateTimeDifference) -&gt; TimeSpan: ...

    # =========================================================================
    def nth_weekday(self) -&gt; t.NoReturn: ...
    def nth_weekday_of_month(self) -&gt; t.NoReturn: ...


IntoDateTimeDifference = (
    DateTimeDifference
    | Date
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class DateTimeDifference:
    def __init__(
        self,
        date: DateTime,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; DateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; DateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; DateTimeDifference: ...
    def increment(self, increment: int) -&gt; DateTimeDifference: ...


class TimeZone:
    def __init__(self, name: str) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    @classmethod
    def from_pytzinfo(cls: type[TimeZone], tz: pydt.tzinfo) -&gt; TimeZone: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls: type[TimeZone], offset: Offset) -&gt; TimeZone: ...
    @classmethod
    def get(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def posix(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def try_system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def tzif(cls: type[TimeZone], name: str, data: bytes) -&gt; TimeZone: ...
    @classmethod
    def utc(cls: type[TimeZone]) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, dt: Timestamp) -&gt; DateTime: ...
    def to_offset(self, timestamp: Timestamp) -&gt; tuple[Offset, bool, str]: ...
    def to_timestamp(self, dt: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, other: DateTime) -&gt; ZonedDateTime: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


class SignedDuration:
    MIN: SignedDuration
    MAX: SignedDuration
    ZERO: SignedDuration

    def __init__(self, secs: int, nanos: int) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __mul__(self, other: int) -&gt; SignedDuration: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; t.Self: ...
    def __add__(self, other: t.Self) -&gt; SignedDuration: ...
    def __abs__(self) -&gt; t.Self: ...
    def __div__(self, other: int) -&gt; SignedDuration: ...
    def abs(self) -&gt; t.Self: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(
        self, other: SignedDuration | pydt.timedelta, op: int
    ) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[SignedDuration], td: pydt.timedelta
    ) -&gt; SignedDuration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls: type[SignedDuration], s: str) -&gt; SignedDuration: ...
    @classmethod
    def from_hours(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_micros(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_millis(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_mins(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_nanos(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def checked_div(self, other: int) -&gt; SignedDuration | None: ...
    def checked_mul(self, other: int) -&gt; SignedDuration | None: ...
    def checked_neg(self) -&gt; SignedDuration | None: ...
    def checked_sub(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def div_duration_f32(self, other: SignedDuration) -&gt; float: ...
    def div_duration_f64(self, other: SignedDuration) -&gt; float: ...
    def div_f32(self, other: int) -&gt; float: ...
    def div_f64(self, other: int) -&gt; float: ...
    def is_positive(self) -&gt; bool: ...
    def mul_f32(self, other: int) -&gt; SignedDuration: ...
    def mul_f64(self, other: int) -&gt; SignedDuration: ...
    def saturating_add(self, other: SignedDuration) -&gt; SignedDuration: ...
    def saturating_mul(self, other: int) -&gt; SignedDuration: ...
    def saturating_sub(self, other: SignedDuration) -&gt; SignedDuration: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def subsec_micros(self) -&gt; int: ...
    def subsec_millis(self) -&gt; int: ...
    def subsec_nanos(self) -&gt; int: ...
    def to_timespan(self) -&gt; TimeSpan: ...


# put in quotes to avoid ruff F821 - undefined name
_TimeSpanArithmeticSingle = "TimeSpan" | Duration | SignedDuration
_TimeSpanArithmeticTuple = tuple[
    _TimeSpanArithmeticSingle, ZonedDateTime | Date | DateTime
]
TimeSpanArithmetic = _TimeSpanArithmeticSingle | _TimeSpanArithmeticTuple


class TimeSpan:
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls: type[t.Self], td: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __neg__(self) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __invert__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: TimeSpan) -&gt; bool: ...
    def __gt__(self, other: TimeSpan) -&gt; bool: ...
    def __le__(self, other: TimeSpan) -&gt; bool: ...
    def __lt__(self, other: TimeSpan) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: TimeSpan) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; t.Self: ...
    def asdict(self) -&gt; TimeSpanTypedDict: ...
    def checked_add(self, val: TimeSpanArithmetic) -&gt; t.Self: ...
    def checked_mul(self, other: int) -&gt; t.Self: ...
    def checked_sub(self, val: TimeSpanArithmetic) -&gt; t.Self: ...
    def compare(self, other: TimeSpan) -&gt; int: ...
    def negate(self) -&gt; t.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; t.Self: ...
    def round(self, options: JIFF_UNIT_STRING) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self, relative: ZonedDateTime | Date | DateTime
    ) -&gt; SignedDuration: ...
    def total(self) -&gt; int: ...
    def total_seconds(self) -&gt; int: ...
    def try_years(self, years: int) -&gt; t.Self: ...
    def try_months(self, months: int) -&gt; t.Self: ...
    def try_weeks(self, weeks: int) -&gt; t.Self: ...
    def try_days(self, days: int) -&gt; t.Self: ...
    def try_hours(self, hours: int) -&gt; t.Self: ...
    def try_minutes(self, minutes: int) -&gt; t.Self: ...
    def try_seconds(self, seconds: int) -&gt; t.Self: ...
    def try_milliseconds(self, milliseconds: int) -&gt; t.Self: ...
    def try_microseconds(self, microseconds: int) -&gt; t.Self: ...
    def try_nanoseconds(self, nanoseconds: int) -&gt; t.Self: ...

    # -------------------------------------------------------------------------
    # PANIC-INDUCING METHODS
    # -------------------------------------------------------------------------
    def _years(self, years: int) -&gt; t.Self: ...
    def _months(self, months: int) -&gt; t.Self: ...
    def _weeks(self, weeks: int) -&gt; t.Self: ...
    def _days(self, days: int) -&gt; t.Self: ...
    def _hours(self, hours: int) -&gt; t.Self: ...
    def _minutes(self, minutes: int) -&gt; t.Self: ...
    def _seconds(self, seconds: int) -&gt; t.Self: ...
    def _milliseconds(self, milliseconds: int) -&gt; t.Self: ...
    def _microseconds(self, microseconds: int) -&gt; t.Self: ...
    def _nanoseconds(self, nanoseconds: int) -&gt; t.Self: ...


class Timestamp:
    """
    A representation of a timestamp with second and nanosecond precision.
    """

    def __init__(
        self, second: int | None = None, nanosecond: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls: type[t.Self]) -&gt; t.Self: ...
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...
    @classmethod
    def from_millisecond(cls: type[t.Self], millisecond: int) -&gt; t.Self: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: Timestamp) -&gt; bool: ...
    def __gt__(self, other: Timestamp) -&gt; bool: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __le__(self, other: Timestamp) -&gt; bool: ...
    def __lt__(self, other: Timestamp) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: Timestamp, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def series(self, span: TimeSpan) -&gt; t.Iterator[Timestamp]: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...
    def string(self) -&gt; str: ...
    def as_second(self) -&gt; int: ...
    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoTimestampDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoTimestampDifference) -&gt; TimeSpan: ...


IntoTimestampDifference = (
    TimestampDifference
    | Timestamp
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Timestamp]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class TimestampDifference:
    def __init__(
        self,
        date: Timestamp,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; TimestampDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; TimestampDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; TimestampDifference: ...
    def increment(self, increment: int) -&gt; TimestampDifference: ...


class ZonedDateTime:
    def __init__(self, timestamp: Timestamp, time_zone: TimeZone) -&gt; None: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(
        cls: type[ZonedDateTime], dt: pydt.datetime
    ) -&gt; ZonedDateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(
        cls: type[ZonedDateTime], tz: str | None = None
    ) -&gt; ZonedDateTime: ...
    @classmethod
    def utcnow(cls: type[ZonedDateTime]) -&gt; ZonedDateTime: ...
    @classmethod
    def parse(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
    @classmethod
    def from_rfc2822(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(
        cls: type[ZonedDateTime], format: str, input: str
    ) -&gt; ZonedDateTime: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: ZonedDateTime) -&gt; bool: ...
    def __gt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __le__(self, other: ZonedDateTime) -&gt; bool: ...
    def __lt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: ZonedDateTime, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; ZonedDateTime: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def checked_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; ZonedDateTime: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; ZonedDateTime: ...
    def first_of_year(self) -&gt; ZonedDateTime: ...
    def in_leap_year(self) -&gt; bool: ...
    def intz(self, tz: str) -&gt; t.Self: ...
    def inutc(self) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; ZonedDateTime: ...
    def last_of_year(self) -&gt; ZonedDateTime: ...
    def offset(self) -&gt; Offset: ...
    def round(self, options: JIFF_UNIT_STRING | DateTimeRound) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def saturating_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def start_of_day(self) -&gt; ZonedDateTime: ...
    def time(self) -&gt; Time: ...
    def time_zone(self) -&gt; TimeZone: ...
    def timestamp(self) -&gt; Timestamp: ...
    def timezone(self) -&gt; TimeZone: ...
    def to_rfc2822(self) -&gt; str: ...
    def tomorrow(self) -&gt; ZonedDateTime: ...
    def with_time_zone(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def yesterday(self) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self, other: ZonedDateTime | tuple[JIFF_UNIT_STRING, ZonedDateTime]
    ) -&gt; TimeSpan: ...
    def until(
        self, other: ZonedDateTime | tuple[JIFF_UNIT_STRING, ZonedDateTime]
    ) -&gt; TimeSpan: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================
    def nth_weekday(self) -&gt; t.NoReturn: ...
    def nth_weekday_of_month(self) -&gt; t.NoReturn: ...


class DateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT_STRING) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT_STRING: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE_STRING: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT_STRING | None,
        mode: JIFF_ROUND_MODE_STRING | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class Offset:
    MIN: Offset
    MAX: Offset
    UTC: Offset
    ZERO: Offset

    def __init__(
        self, hours: int | None = None, seconds: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; Offset: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls: type[Offset]) -&gt; Offset: ...
    @classmethod
    def from_hours(cls: type[Offset], hours: int) -&gt; Offset: ...
    @classmethod
    def from_seconds(cls: type[Offset], seconds: int) -&gt; Offset: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def checked_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def negate(self) -&gt; Offset: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def since(self, other: Offset) -&gt; TimeSpan: ...
    def until(self, other: Offset) -&gt; TimeSpan: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
    unchecked: bool = False,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...

</code></pre>
<h2 id="ryjson"><a class="header" href="#ryjson"><code>ry.JSON</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.JSON"""

from typing import Literal

JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


def parse_json(
    data: bytes | str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...

</code></pre>
<h2 id="ry_dev"><a class="header" href="#ry_dev"><code>ry._dev</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.dev"""

from __future__ import annotations

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...

</code></pre>
<h2 id="rydirs"><a class="header" href="#rydirs"><code>ry.dirs</code></a></h2>
<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...

</code></pre>
<h2 id="ryhttp"><a class="header" href="#ryhttp"><code>ry.http</code></a></h2>
<pre><code class="language-python">class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(self, headers: dict[str, str]) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: str) -&gt; str: ...
    def __setitem__(self, key: str, value: str) -&gt; None: ...
    def __delitem__(self, key: str) -&gt; None: ...
    def __contains__(self, key: str) -&gt; bool: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def append(self, key: str, value: str) -&gt; None: ...
    def get(self, key: str) -&gt; str: ...
    def get_all(self, key: str) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def remove(self, key: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def pop(self, key: str) -&gt; str: ...
    def keys(self) -&gt; list[str]: ...

</code></pre>
<h2 id="ryreqwest"><a class="header" href="#ryreqwest"><code>ry.reqwest</code></a></h2>
<pre><code class="language-python">import typing as t


class AsyncClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | None = None,
        timeout: float | None = None,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
    ) -&gt; None: ...
    async def get(
        self, url: str, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def post(
        self,
        url: str,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def put(
        self,
        url: str,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def delete(
        self, url: str, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def patch(
        self,
        url: str,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def head(
        self, url: str, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: str,
        *,
        method: str = "GET",
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...


class Response:
    status_code: int
    headers: dict[str, str]

    async def text(self) -&gt; str: ...
    async def json(self) -&gt; t.Any: ...
    async def bytes(self) -&gt; bytes: ...
    def bytes_stream(self) -&gt; ResponseStream: ...


class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; bytes: ...


async def fetch(
    url: str,
    *,
    method: str = "GET",
    body: bytes | None = None,
    headers: dict[str, str] | None = None,
) -&gt; Response: ...

</code></pre>
<h2 id="ryxxhash"><a class="header" href="#ryxxhash"><code>ry.xxhash</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

import typing as t


@t.final
class Xxh32:
    name: t.Literal["xxh32"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh64:
    name: t.Literal["xxh64"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh3:
    name: t.Literal["xxh3"]

    def __init__(
        self,
        input: bytes = ...,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def digest128(self) -&gt; bytes: ...
    def hexdigest128(self) -&gt; str: ...
    def intdigest128(self) -&gt; int: ...
    def copy(self) -&gt; Xxh3: ...
    def reset(self) -&gt; None: ...


def xxh32(input: bytes | None = None, seed: int | None = None) -&gt; Xxh32: ...
def xxh64(input: bytes | None = None, seed: int | None = None) -&gt; Xxh64: ...
def xxh3(
    input: bytes | None = None,
    seed: int | None = None,
    secret: bytes | None = None,
) -&gt; Xxh3: ...


# xxh32
def xxh32_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh32_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh32_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh64
def xxh64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh128
def xxh128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh3
def xxh3_64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh3_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...


# xxh128
def xxh3_128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...

</code></pre>
<!-- API-END -->
<hr />
<h2 id="dev"><a class="header" href="#dev">DEV</a></h2>
<ul>
<li><code>just</code> is used to run tasks</li>
<li>Do not use the phrase <code>blazing fast</code> or any emojis in any PRs or issues or
docs</li>
<li>type annotations are required</li>
<li><code>ruff</code> used for formatting and linting</li>
</ul>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<ul>
<li>utiles (web-map tile utils): https://github.com/jessekrubin/utiles</li>
<li>jsonc2json (jsonc to json converter):
https://github.com/jessekrubin/jsonc2json</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">DEVELOPMENT</a></h1>
<p><strong>OPEN TO PRS!</strong></p>
<h2 id="style-guide"><a class="header" href="#style-guide">style guide</a></h2>
<ul>
<li><strong>NO UNWRAPPING</strong></li>
<li><strong>NO PANICS</strong></li>
<li><strong>USE CLIPPY</strong> <code>just clippy</code> or <code>just ci</code></li>
<li><strong>USE RUSTFMT AND RUFF</strong> <code>just fmt</code></li>
<li>avoid using macros as they are not as easy to reason about and/or debug, but feel free to say ‘yolo’</li>
<li>library style guide:
<ul>
<li>python objects/structs/classes defined in the library should be named either <code>Py&lt;CLASSNAME&gt;</code> or <code>Ry&lt;CLASSNAME&gt;</code> and
the prefix should be consistent throughout the library (eg <code>ryo3-jiff</code> uses <code>Ry</code> as the internal prefix to not
conflict with the <code>Py&lt;CLASSNAME&gt;</code> structs provided by <code>pyo3</code>)</li>
<li>if a <code>pyclass</code> or <code>pyfunction</code> is not mirroring a rust function prefer names that are puns but also
semi-descriptive (eg <code>Globsters</code> in <code>ryo3-globset</code>)</li>
<li>attempt to mirror the structure of the og library as much as possible</li>
<li>wrapper libraries should be of the form <code>ryo3-&lt;LIB_NAME&gt;</code> where <code>&lt;LIB_NAME&gt;</code> is the name of the library they</li>
<li>library directories should be <code>kebab-case</code> and should be <code>ryo3-&lt;LIB_NAME&gt;</code></li>
<li>MUST PROVIDE TYPE ANNOTATIONS</li>
</ul>
</li>
</ul>
<h2 id="creating-a-new-librarywrapper-thing"><a class="header" href="#creating-a-new-librarywrapper-thing">Creating a new library/wrapper-thing</a></h2>
<ul>
<li>copy the template library  <code>ryo3-quick-maths</code> library to your new library name</li>
<li>refer to the above style guide for naming conventions</li>
</ul>
<h2 id="tools"><a class="header" href="#tools">tools</a></h2>
<h3 id="python"><a class="header" href="#python">python</a></h3>
<ul>
<li>we use <code>maturin</code> for building the python wheels</li>
<li>we support <code>python-3.9+</code></li>
<li>we use <code>pytest</code> for testing as well as the following plugins:
<ul>
<li><code>pytest-benchmark</code></li>
<li><code>pytest-asyncio</code> (may switch to <code>anyio</code> in the future)</li>
<li><code>hypothesis</code></li>
</ul>
</li>
</ul>
<h3 id="just"><a class="header" href="#just">just</a></h3>
<p><strong><code>cargo install just</code></strong></p>
<ul>
<li>we use <code>just</code> for task running</li>
<li>to see all tasks run <code>just</code> or <code>just --list</code> (our default task echos the list of tasks)</li>
</ul>
<p>tasks as of 2024-12-03:</p>
<pre><code class="language-aiignore">Available recipes:
    dev            # dev run build + tests
    develop        # maturin develop
    cargo-test     # cargo test
    build          # build
    build-release  # build release
    dev-rel        # maturin develop release
    pytest         # run pytest
    pytestv        # run pytest (printing captured output)
    test           # run all test
    test-release   # test ry package
    bench          # benchmark ry python package
    ci             # ci rust checks
    cargo-fmt      # cargo format
    cargo-fmtc     # cargo format check
    sort-all-check # ruff check sorting of '__all__'
    sort-all       # ruff sort '__all__'
    ruff-fmt       # ruff format
    ruff-fmtc      # ruff format check
    black          # python format black
    fmtpy          # python format
    fmtcpy         # python format check
    justfilefmt    # justfile format
    justfilefmtc   # justfile format check
    fmt            # format
    fmtc           # format check
    ruff           # run ruff linter
    ruffix         # run ruff + fix
    clippy         # run clippy
    lint           # lint python and rust
    mypy           # run mypy type checker
    pyright        # run pyright
    pip-compile    # pip compile requirements
    gen            # generate code tasks
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>This project would not be possible without the incredible work of many others.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">THANK YOU</a></h2>
<ul>
<li>pyo3 developers</li>
<li>all authors of all libraries used in this project!</li>
<li>burnt-sushi for his incredible set of libraries</li>
</ul>
<hr />
<p>If you want to be added to this list, please open an issue or PR! Happy to add you if you’ve helped in any way!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">CHANGELOG</a></h1>
<h2 id="v0025-2024-01-07-25-for-2025"><a class="header" href="#v0025-2024-01-07-25-for-2025">v0.0.25 [2024-01-07] (25 for 2025)</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Updated to <code>0.1.21</code> which has span and signed duration strings with capital letters</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0024-2024-12-24-the-night-b4-xmas"><a class="header" href="#v0024-2024-12-24-the-night-b4-xmas">v0.0.24 [2024-12-24] (the night b4 xmas…)</a></h2>
<ul>
<li><code>http</code>
<ul>
<li>basic headers struct/obj – WIP</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>reqwest client (currently root-export)</li>
<li>default client + root <code>fetch</code> function likely needs work…</li>
<li>response <code>byte_stream</code>!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0023-2024-12-19"><a class="header" href="#v0023-2024-12-19">v0.0.23 [2024-12-19]</a></h2>
<ul>
<li><code>python -m ry.dev</code> repl for ipython/python repl ~ handy nifty secret tool makes it into repo</li>
<li>internal
<ul>
<li>in process of renaming all python-rust <code>#[new]</code> functions to be named <code>fn py_new(...)</code></li>
</ul>
</li>
<li><code>unindent</code>
<ul>
<li>Added <code>unindent</code> module for unindenting strings will move to <code>ryo3-unindent</code></li>
</ul>
</li>
<li><code>FsPath</code>
<ul>
<li>creeping ever closer to being a full-fledged pathlib.Path replacement</li>
<li>Added bindings to all rust <code>std::path::Path(buf)</code> methods for <code>FsPath</code></li>
</ul>
</li>
<li>sub-packaging
<ul>
<li><code>xxhash</code> is own sub package now <code>ry.xxhash</code></li>
<li><code>JSON</code> is own subpackage right now – named <code>ry.JSON</code> to avoid conflict with <code>json</code> module but maybe will change…</li>
<li>food-for-thought-ing how <code>ryo3</code> and <code>ry</code> should be organized w/ respsect to sub-packages and where that organization should be</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>required to break up the type annotations due to migration to sub-packages</li>
<li>breaking up the type annotations file into smaller files under <code>&lt;REPO&gt;/python/ry/ryo3/*.pyi</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0022-2024-12-16"><a class="header" href="#v0022-2024-12-16">v0.0.22 [2024-12-16]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Super simple regex wrapper (must to do here, but was added for <code>ryo3-which::which_re</code>)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li><code>until</code>/<code>since</code>
<ul>
<li>Basic <code>until</code>/<code>since</code> implementation but I do not like them and they confusingly named <code>*Difference</code> structs/py-objects, so I may change how they work…</li>
</ul>
</li>
<li><code>jiff</code> seems to be about as performant as <code>whenever</code> ~ yay! also the whenever dude appears to be watching this repo (as of 2024-12-16)</li>
</ul>
</li>
<li><code>walkdir</code>
<ul>
<li><code>collect</code> added to <code>WalkdirGen</code> to collect the results into a list</li>
</ul>
</li>
<li>deps
<ul>
<li><code>thiserror</code> version <code>2.0.7</code> -&gt; <code>2.0.8</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0021-2024-12-13-friday-the-13th-spoogidy-oogidity"><a class="header" href="#v0021-2024-12-13-friday-the-13th-spoogidy-oogidity">v0.0.21 [2024-12-13] (friday the 13th… spoogidy oogidity)</a></h2>
<ul>
<li><code>walkdir</code>
<ul>
<li>add <code>glob</code> kwarg that takes a <code>ry.Glob</code> or <code>ry.GlobSet</code> or <code>ry.Globster</code> obj to filter the walk on</li>
</ul>
</li>
<li><code>globset</code>
<ul>
<li>Internal refactoring</li>
<li>added <code>globster()</code> method to <code>ry.Glob</code> and <code>ry.GlobSet</code> to return a <code>ry.Globster</code> obj</li>
<li>added <code>globset()</code> method to <code>ry.Glob</code> to return a <code>ry.GlobSet</code> obj from a <code>ry.Glob</code> obj</li>
</ul>
</li>
<li><code>url</code>
<ul>
<li>python <code>Url</code> changed name <code>URL</code>; aligns with jawascript and other python libs</li>
</ul>
</li>
<li><code>bzip2</code>
<ul>
<li>update to v5</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>conversions for jiff-round-mode/unit/weekday</li>
<li>not-implemented placeholders and new impls
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDateTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDate</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyOffset</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySignedDuration</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySpan</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTimeZone</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyZoned</code></li>
</ul>
</li>
<li>span builder functions use form <code>s._hours(1)</code> for panic-inducing building, and <code>s.try_hours(1)</code> for non-panic-inducing building</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>fixes and updates and a hacky script I wrote to check for discrepancies</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0020-2024-12-10"><a class="header" href="#v0020-2024-12-10">v0.0.20 [2024-12-10]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Templated out regex package but nothing added</li>
</ul>
</li>
<li><code>ry</code>
<ul>
<li>python 3.13 yay!</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated jiter version thanks depbot!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0019-2024-12-05"><a class="header" href="#v0019-2024-12-05">v0.0.19 [2024-12-05]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>py-conversions
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDateTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDate</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffOffset</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSignedDuration</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSpan</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTimeZone</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffZoned</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0018-2024-12-03"><a class="header" href="#v0018-2024-12-03">v0.0.18 [2024-12-03]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Renamed <code>ry.Span</code> to <code>ry.TimeSpan</code></li>
<li>Renamed <code>ry.Zoned</code> to <code>ry.ZonedDateTime</code></li>
<li>Updated type stubs to reflect renames</li>
</ul>
</li>
<li>docs
<ul>
<li>init-ed the docs</li>
<li>style guide under <code>DEVELOPMENT.md</code> file</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0017-2024-12-02"><a class="header" href="#v0017-2024-12-02">v0.0.17 [2024-12-02]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li><code>ry.TimeZone</code> testing and to/from <code>datetime.tzinfo</code> conversions</li>
<li>Using nu-types for <code>jiff</code> intermediate types bc of the classic orphans problem (aka batman) w/ traits</li>
<li>hypothesis tests</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated to <code>jiter</code> v0.8.1</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0016-2024-11-29"><a class="header" href="#v0016-2024-11-29">v0.0.16 [2024-11-29]</a></h2>
<ul>
<li>Moved walkdir to <code>ryo3-walkdir</code></li>
<li>added <code>ryo3-types</code> for custom and shared types</li>
<li><code>heck</code> wrapper(s)</li>
<li>jiff
<ul>
<li>Added operators <code>+</code>/<code>+=</code>/<code>-</code>/<code>-=</code> to date/time/datetime/etc</li>
<li>TODO: figure out how to take refs in the union enum for the operators</li>
</ul>
</li>
<li>fspath
<ul>
<li>further beefing out as well as testing</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0015-2024-11-20"><a class="header" href="#v0015-2024-11-20">v0.0.15 [2024-11-20]</a></h2>
<ul>
<li><code>from __future__ import annotations</code> added to all modules</li>
<li>cicd updated to include more targets</li>
</ul>
<hr />
<h2 id="v0014-2024-11-20"><a class="header" href="#v0014-2024-11-20">v0.0.14 [2024-11-20]</a></h2>
<ul>
<li>Primitive/crude wrappers around Mr. Sushi’s <code>jiff</code> library</li>
<li>Updated to use pyo3 (had to use jiter git repo dep)</li>
<li><code>ry.FsPath</code> beefed out</li>
<li>Added iterdir gen wrapper</li>
<li>(todo undo when jiter + pyo3 23 is public)</li>
</ul>
<hr />
<h2 id="v0013-2024-11-20"><a class="header" href="#v0013-2024-11-20">v0.0.13 [2024-11-20]</a></h2>
<ul>
<li><strong>VERSION SKIPPED DUE TO <code>13</code> BEING SPOOKY AND ME BEING MODERATELY-STITCHOUS (AKA fully ‘superstitchous’)</strong></li>
</ul>
<hr />
<h2 id="v0012-2024-11-14"><a class="header" href="#v0012-2024-11-14">v0.0.12 [2024-11-14]</a></h2>
<ul>
<li>sqlformat wrapper(s) (this is the first <code>ryo3-*</code> sub-crate)</li>
</ul>
<hr />
<h2 id="v0011-2024-09-22"><a class="header" href="#v0011-2024-09-22">v0.0.11 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
<li>prepare for python 3.13</li>
</ul>
<hr />
<h2 id="v0010-2024-09-22"><a class="header" href="#v0010-2024-09-22">v0.0.10 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
</ul>
<hr />
<h2 id="v009-2024-08-22"><a class="header" href="#v009-2024-08-22">v0.0.9 [2024-08-22]</a></h2>
<ul>
<li>Added <code>globset</code> wrapper(s)</li>
<li>Added <code>__init__.py</code> generator</li>
</ul>
<hr />
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<h2 id="v008-2024-06-25"><a class="header" href="#v008-2024-06-25">v0.0.8 [2024-06-25]</a></h2>
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<hr />
<h2 id="v007-2024-06-08"><a class="header" href="#v007-2024-06-08">v0.0.7 [2024-06-08]</a></h2>
<ul>
<li>internal refactoring</li>
</ul>
<hr />
<h2 id="v006-2024-06-05"><a class="header" href="#v006-2024-06-05">v0.0.6 [2024-06-05]</a></h2>
<ul>
<li>Added zstd (<code>zstd_encode</code>/<code>zstd</code> and <code>zstd_decode</code>)</li>
<li>Added gzip (<code>gzip_encode</code>/<code>gzip</code> and <code>gzip_decode</code>/<code>gunzip</code>)</li>
<li>Added bzip2 (<code>bzip2_encode</code>/<code>bzip2</code> and <code>bzip2_decode</code>)</li>
<li>Added walkdir</li>
<li>Reorg libs</li>
</ul>
<hr />
<h2 id="v005-2024-04-19"><a class="header" href="#v005-2024-04-19">v0.0.5 [2024-04-19]</a></h2>
<ul>
<li>Added brotli (<code>brotli_encode</code> and <code>brotli_decode</code>)</li>
<li>xxhash
<ul>
<li>const functions</li>
<li>hasher streaming objects</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p><strong>TODO: Add examples</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<h2 id="ry__init__-1"><a class="header" href="#ry__init__-1"><code>ry.__init__</code></a></h2>
<pre><code class="language-python">"""ry api ~ type annotations"""

import datetime as pydt
import typing as t
from os import PathLike

from ry.types import (
    DateTimeTypedDict,
    DateTypedDict,
    TimeSpanTypedDict,
    TimeTypedDict,
)

from . import http as http
from .reqwest import (
    AsyncClient as AsyncClient,
)
from .reqwest import (
    Response as Response,
)
from .reqwest import (
    ResponseStream as ResponseStream,
)
from .reqwest import (
    fetch as fetch,
)

__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str

# =============================================================================
# TYPE ALIASES
# =============================================================================
JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)

# =============================================================================
# STD
# =============================================================================


class Duration:
    ZERO: Duration
    MIN: Duration
    MAX: Duration
    NANOSECOND: Duration
    MICROSECOND: Duration
    MILLISECOND: Duration
    SECOND: Duration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Duration) -&gt; bool: ...
    def __le__(self, other: Duration) -&gt; bool: ...
    def __gt__(self, other: Duration) -&gt; bool: ...
    def __ge__(self, other: Duration) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(
        self, other: Duration | pydt.timedelta, op: int
    ) -&gt; bool: ...
    def __str__(self) -&gt; str: ...
    def abs_diff(self, other: Duration) -&gt; Duration: ...
    def sleep(self) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[Duration], td: pydt.timedelta
    ) -&gt; Duration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; Duration: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; Duration: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; Duration: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; Duration: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; Duration: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; Duration: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_days(cls, days: int) -&gt; Duration: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; Duration: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Duration | None: ...
    def checked_div(self, other: Duration) -&gt; Duration | None: ...
    def checked_mul(self, other: Duration) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Duration | None: ...
    def div_duration_f32(self, other: Duration) -&gt; float: ...
    def div_duration_f64(self, other: Duration) -&gt; float: ...
    def div_f32(self, other: float) -&gt; Duration: ...
    def div_f64(self, other: float) -&gt; Duration: ...
    def mul_f32(self, other: float) -&gt; Duration: ...
    def mul_f64(self, other: float) -&gt; Duration: ...
    def saturating_add(self, other: Duration) -&gt; Duration: ...
    def saturating_mul(self, other: Duration) -&gt; Duration: ...
    def saturating_sub(self, other: Duration) -&gt; Duration: ...


class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; Instant: ...
    def __iadd__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Instant) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Instant | None: ...
    def checked_duration_since(self, earlier: Instant) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Instant | None: ...
    def duration_since(self, earlier: Instant) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: Instant) -&gt; Duration: ...


def instant() -&gt; Instant: ...


# =============================================================================
# RY03-CORE
# =============================================================================


class FsPath:
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __truediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def read_text(self) -&gt; str: ...
    def read_bytes(self) -&gt; bytes: ...
    def absolute(self) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def write_text(self, data: str) -&gt; None: ...
    def write_bytes(self, data: bytes) -&gt; None: ...
    def joinpath(self, *paths: str) -&gt; FsPath: ...
    def exists(self) -&gt; bool: ...
    def with_name(self, name: str) -&gt; FsPath: ...
    def with_suffix(self, suffix: str) -&gt; FsPath: ...
    def iterdir(self) -&gt; t.Iterator[FsPath]: ...
    def relative_to(self, other: PathLike[str] | str | FsPath) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...

    # TODO
    def __bytes__(self) -&gt; bytes: ...
    def as_uri(self) -&gt; str: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def string(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; FsPath: ...
    @classmethod
    def home(cls) -&gt; FsPath: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; FsPath: ...
    @property
    def parents(self) -&gt; t.Sequence[t.Self]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; str: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf
    # =========================================================================
    def _pop(self) -&gt; FsPath: ...
    def _push(self, path: PathLike[str] | str) -&gt; FsPath: ...
    def _set_extension(self, ext: str) -&gt; FsPath: ...
    def _set_file_name(self, name: str) -&gt; FsPath: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; t.Iterator[FsPath]: ...
    def canonicalize(self) -&gt; FsPath: ...
    def components(self) -&gt; t.Iterator[FsPath]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; FsPath: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, prefix: PathLike[str] | str) -&gt; FsPath: ...
    def with_extension(self, ext: str) -&gt; FsPath: ...
    def with_file_name(self, name: str) -&gt; FsPath: ...


FsPathLike = str | FsPath | PathLike[str]


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: FsPathLike) -&gt; None: ...
def ls(path: FsPathLike | None = None) -&gt; list[FsPath]: ...
def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """


# =============================================================================
# SLEEP
# =============================================================================
def sleep(seconds: float) -&gt; float: ...
async def sleep_async(seconds: float) -&gt; float: ...


# =============================================================================
# FILESYSTEM
# =============================================================================
def read_text(path: FsPathLike) -&gt; str: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def write_text(path: FsPathLike, data: str) -&gt; None: ...
def write_bytes(path: FsPathLike, data: bytes) -&gt; None: ...


# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------
# |~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~|
# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------

# =============================================================================
# Regex
# =============================================================================


class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: str | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def is_match(self, string: str) -&gt; bool: ...


# =============================================================================
# WHICH
# =============================================================================
def which(cmd: str, path: None | str = None) -&gt; str | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[str]: ...
def which_re(regex: Regex, path: None | str = None) -&gt; list[str]: ...


# =============================================================================
# HECK
# =============================================================================


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...


# =============================================================================
# GLOBSET
# =============================================================================
class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def regex(self) -&gt; str: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globster(self) -&gt; Globster: ...


class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def glob(
    pattern: str,
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Glob: ...
def globs(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Globster: ...


# =============================================================================
# WALKDIR
# =============================================================================


class WalkdirGen:
    """walkdir::Walkdir iterable wrapper"""

    files: bool
    dirs: bool

    def __next__(self) -&gt; str: ...
    def __iter__(self) -&gt; t.Iterator[str]: ...
    def collect(self) -&gt; list[str]: ...


class FspathsGen:
    """walkdir iterable that yields FsPath objects"""

    files: bool
    dirs: bool

    def __next__(self) -&gt; FsPath: ...
    def __iter__(self) -&gt; t.Iterator[FsPath]: ...


def walkdir(
    path: FsPathLike | None = None,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | None = None,
) -&gt; WalkdirGen: ...
def fspaths(
    path: FsPathLike | None = None,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
) -&gt; WalkdirGen: ...


# =============================================================================
# SHLEX
# =============================================================================
def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""
    ...


# =============================================================================
# JSON
# =============================================================================
def parse_json(
    data: bytes | str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: t.Literal[
        True, False, "off", "on", "trailing-strings"
    ] = False,
    catch_duplicate_keys: bool = False,
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: t.Literal[
        True, False, "off", "on", "trailing-strings"
    ] = False,
    catch_duplicate_keys: bool = False,
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: t.Literal[
        True, False, "off", "on", "trailing-strings"
    ] = False,
    catch_duplicate_keys: bool = False,
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...


# =============================================================================
# FORMATTING
# =============================================================================
def fmt_nbytes(nbytes: int) -&gt; str: ...
def unindent(string: str) -&gt; str: ...
def unindent_bytes(string: bytes) -&gt; bytes: ...


# =============================================================================
# FNV
# =============================================================================
class FnvHasher:
    name: t.Literal["fnv1a"]

    def __init__(self, input: bytes | None = None) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; FnvHasher: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def fnv1a(input: bytes) -&gt; FnvHasher: ...


# =============================================================================
# BROTLI
# =============================================================================
def brotli_encode(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(input: bytes) -&gt; bytes: ...
def brotli(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""


# =============================================================================
# BZIP2
# =============================================================================
def bzip2_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def bzip2_decode(input: bytes) -&gt; bytes: ...
def bzip2(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for bzip2_encode"""


# =============================================================================
# GZIP
# =============================================================================
def gzip_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def gzip_decode(input: bytes) -&gt; bytes: ...
def gzip(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for gzip_encode"""


def gunzip(input: bytes) -&gt; bytes:
    """Alias for gzip_decode"""


# =============================================================================
# ZSTD
# =============================================================================
def zstd_encode(input: bytes, level: int = 3) -&gt; bytes: ...
def zstd(input: bytes, level: int = 3) -&gt; bytes:
    """Alias for zstd_encode"""


def zstd_decode(input: bytes) -&gt; bytes: ...


# =============================================================================
# SQLFORMAT
# =============================================================================
SqlfmtParamValue = str | int | float | bool
TSqlfmtParamValue_co = t.TypeVar(
    "TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike = (
    dict[str, TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, TSqlfmtParamValue_co]]
    | t.Sequence[TSqlfmtParamValue_co]
)


class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[TSqlfmtParamValue_co] | SqlfmtQueryParams,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int = 2,  # -1 or any negative value will use tabs
    uppercase: bool | None = True,
    lines_between_statements: int = 1,
) -&gt; str: ...


# =============================================================================
# URL
# =============================================================================


class URL:
    def __init__(
        self, url: str, *, params: dict[str, str] | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, url: str) -&gt; URL: ...
    @classmethod
    def parse_with_params(cls, url: str, params: dict[str, str]) -&gt; URL: ...
    @classmethod
    def from_directory_path(cls, path: str) -&gt; URL: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: URL) -&gt; bool: ...
    def __gt__(self, other: URL) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: URL) -&gt; bool: ...
    def __lt__(self, other: URL) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rtruediv__(self, relative: str) -&gt; URL: ...
    def __truediv__(self, relative: str) -&gt; URL: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None: ...
    @property
    def port_or_known_default(self) -&gt; int | None: ...
    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_pairs(self) -&gt; list[tuple[str, str]]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def username(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def to_filepath(self) -&gt; str: ...
    def set_fragment(self, fragment: str) -&gt; None: ...
    def set_host(self, host: str) -&gt; None: ...
    def set_ip_host(self, host: str) -&gt; None: ...
    def set_password(self, password: str) -&gt; None: ...
    def set_path(self, path: str) -&gt; None: ...
    def set_port(self, port: int) -&gt; None: ...
    def set_query(self, query: str) -&gt; None: ...
    def set_scheme(self, scheme: str) -&gt; None: ...
    def set_username(self, username: str) -&gt; None: ...
    def socket_addrs(self) -&gt; None: ...


# =============================================================================
# JIFF
# =============================================================================
JIFF_UNIT_STRING = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JIFF_ROUND_MODE_STRING = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half_ceil",
    "half_floor",
    "half_expand",
    "half_trunc",
    "half_even",
]


class Date:
    MIN: Date
    MAX: Date
    ZERO: Date

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls: type[Date], date: pydt.date) -&gt; Date: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(
        cls: type[Date], year: int, week: int, weekday: int
    ) -&gt; Date: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls: type[Date], format: str, string: str) -&gt; Date: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __isub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int
    ) -&gt; DateTime: ...
    def asdict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: Date) -&gt; Date: ...
    def duration_until(self, other: Date) -&gt; Date: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; Date: ...
    def first_of_year(self) -&gt; Date: ...
    def in_leap_year(self) -&gt; bool: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; Date: ...
    def last_of_year(self) -&gt; Date: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Date]: ...
    def to_datetime(self, time: Time) -&gt; DateTime: ...
    def tomorrow(self) -&gt; Date: ...
    def yesterday(self) -&gt; Date: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoDateDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoDateDifference) -&gt; TimeSpan: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================

    def nth_weekday(self) -&gt; t.NoReturn: ...
    def nth_weekday_of_month(self) -&gt; t.NoReturn: ...
    def to_zoned(self) -&gt; t.NoReturn: ...
    def weekday(self) -&gt; t.NoReturn: ...


IntoDateDifference = (
    DateDifference
    | Date
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class DateDifference:
    def __init__(
        self,
        date: Date,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; DateDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; DateDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; DateDifference: ...
    def increment(self, increment: int) -&gt; DateDifference: ...


class Time:
    MIN: Time
    MAX: Time

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __isub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls: type[Time], format: str, string: str) -&gt; Time: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls: type[Time], time: pydt.time) -&gt; Time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def now(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; None: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def asdict(self) -&gt; TimeTypedDict: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Time]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    @t.overload
    def checked_sub(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def round(
        self,
        smallest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; Time: ...
    def to_datetime(self, d: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoTimeDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoTimeDifference) -&gt; TimeSpan: ...


IntoTimeDifference = (
    TimeDifference
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class TimeDifference:
    def __init__(
        self,
        date: Time,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; TimeDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; TimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; TimeDifference: ...
    def increment(self, increment: int) -&gt; TimeDifference: ...


class DateTime:
    MIN: DateTime
    MAX: DateTime
    ZERO: DateTime

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls: type[DateTime], format: str, string: str) -&gt; DateTime: ...
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls: type[DateTime], dt: pydt.datetime) -&gt; DateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls: type[DateTime]) -&gt; DateTime: ...
    @classmethod
    def from_parts(cls: type[DateTime], date: Date, time: Time) -&gt; DateTime: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __repr__(self) -&gt; str: ...
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __sub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __isub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def date(self) -&gt; Date: ...
    def time(self) -&gt; Time: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[DateTime]: ...
    def asdict(self) -&gt; DateTimeTypedDict: ...
    def round(self, options: JIFF_UNIT_STRING | DateTimeRound) -&gt; t.Self: ...
    def yesterday(self) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def saturating_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; t.NoReturn: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================
    def first_of_month(self) -&gt; DateTime: ...
    def first_of_year(self) -&gt; DateTime: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def duration_since(self, other: DateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: DateTime) -&gt; SignedDuration: ...
    def in_leap_year(self) -&gt; bool: ...
    def end_of_day(self) -&gt; DateTime: ...
    def last_of_month(self) -&gt; DateTime: ...
    def last_of_year(self) -&gt; DateTime: ...
    def start_of_day(self) -&gt; DateTime: ...
    def tomorrow(self) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoDateTimeDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoDateTimeDifference) -&gt; TimeSpan: ...

    # =========================================================================
    def nth_weekday(self) -&gt; t.NoReturn: ...
    def nth_weekday_of_month(self) -&gt; t.NoReturn: ...


IntoDateTimeDifference = (
    DateTimeDifference
    | Date
    | Time
    | DateTime
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Date]
    | tuple[JIFF_UNIT_STRING, Time]
    | tuple[JIFF_UNIT_STRING, DateTime]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class DateTimeDifference:
    def __init__(
        self,
        date: DateTime,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; DateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; DateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; DateTimeDifference: ...
    def increment(self, increment: int) -&gt; DateTimeDifference: ...


class TimeZone:
    def __init__(self, name: str) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    @classmethod
    def from_pytzinfo(cls: type[TimeZone], tz: pydt.tzinfo) -&gt; TimeZone: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls: type[TimeZone], offset: Offset) -&gt; TimeZone: ...
    @classmethod
    def get(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def posix(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def try_system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def tzif(cls: type[TimeZone], name: str, data: bytes) -&gt; TimeZone: ...
    @classmethod
    def utc(cls: type[TimeZone]) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, dt: Timestamp) -&gt; DateTime: ...
    def to_offset(self, timestamp: Timestamp) -&gt; tuple[Offset, bool, str]: ...
    def to_timestamp(self, dt: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, other: DateTime) -&gt; ZonedDateTime: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


class SignedDuration:
    MIN: SignedDuration
    MAX: SignedDuration
    ZERO: SignedDuration

    def __init__(self, secs: int, nanos: int) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __mul__(self, other: int) -&gt; SignedDuration: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; t.Self: ...
    def __add__(self, other: t.Self) -&gt; SignedDuration: ...
    def __abs__(self) -&gt; t.Self: ...
    def __div__(self, other: int) -&gt; SignedDuration: ...
    def abs(self) -&gt; t.Self: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(
        self, other: SignedDuration | pydt.timedelta, op: int
    ) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[SignedDuration], td: pydt.timedelta
    ) -&gt; SignedDuration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls: type[SignedDuration], s: str) -&gt; SignedDuration: ...
    @classmethod
    def from_hours(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_micros(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_millis(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_mins(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_nanos(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def checked_div(self, other: int) -&gt; SignedDuration | None: ...
    def checked_mul(self, other: int) -&gt; SignedDuration | None: ...
    def checked_neg(self) -&gt; SignedDuration | None: ...
    def checked_sub(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def div_duration_f32(self, other: SignedDuration) -&gt; float: ...
    def div_duration_f64(self, other: SignedDuration) -&gt; float: ...
    def div_f32(self, other: int) -&gt; float: ...
    def div_f64(self, other: int) -&gt; float: ...
    def is_positive(self) -&gt; bool: ...
    def mul_f32(self, other: int) -&gt; SignedDuration: ...
    def mul_f64(self, other: int) -&gt; SignedDuration: ...
    def saturating_add(self, other: SignedDuration) -&gt; SignedDuration: ...
    def saturating_mul(self, other: int) -&gt; SignedDuration: ...
    def saturating_sub(self, other: SignedDuration) -&gt; SignedDuration: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def subsec_micros(self) -&gt; int: ...
    def subsec_millis(self) -&gt; int: ...
    def subsec_nanos(self) -&gt; int: ...
    def to_timespan(self) -&gt; TimeSpan: ...


# put in quotes to avoid ruff F821 - undefined name
_TimeSpanArithmeticSingle = "TimeSpan" | Duration | SignedDuration
_TimeSpanArithmeticTuple = tuple[
    _TimeSpanArithmeticSingle, ZonedDateTime | Date | DateTime
]
TimeSpanArithmetic = _TimeSpanArithmeticSingle | _TimeSpanArithmeticTuple


class TimeSpan:
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls: type[t.Self], td: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __neg__(self) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __invert__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: TimeSpan) -&gt; bool: ...
    def __gt__(self, other: TimeSpan) -&gt; bool: ...
    def __le__(self, other: TimeSpan) -&gt; bool: ...
    def __lt__(self, other: TimeSpan) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: TimeSpan) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; t.Self: ...
    def asdict(self) -&gt; TimeSpanTypedDict: ...
    def checked_add(self, val: TimeSpanArithmetic) -&gt; t.Self: ...
    def checked_mul(self, other: int) -&gt; t.Self: ...
    def checked_sub(self, val: TimeSpanArithmetic) -&gt; t.Self: ...
    def compare(self, other: TimeSpan) -&gt; int: ...
    def negate(self) -&gt; t.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; t.Self: ...
    def round(self, options: JIFF_UNIT_STRING) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self, relative: ZonedDateTime | Date | DateTime
    ) -&gt; SignedDuration: ...
    def total(self) -&gt; int: ...
    def total_seconds(self) -&gt; int: ...
    def try_years(self, years: int) -&gt; t.Self: ...
    def try_months(self, months: int) -&gt; t.Self: ...
    def try_weeks(self, weeks: int) -&gt; t.Self: ...
    def try_days(self, days: int) -&gt; t.Self: ...
    def try_hours(self, hours: int) -&gt; t.Self: ...
    def try_minutes(self, minutes: int) -&gt; t.Self: ...
    def try_seconds(self, seconds: int) -&gt; t.Self: ...
    def try_milliseconds(self, milliseconds: int) -&gt; t.Self: ...
    def try_microseconds(self, microseconds: int) -&gt; t.Self: ...
    def try_nanoseconds(self, nanoseconds: int) -&gt; t.Self: ...

    # -------------------------------------------------------------------------
    # PANIC-INDUCING METHODS
    # -------------------------------------------------------------------------
    def _years(self, years: int) -&gt; t.Self: ...
    def _months(self, months: int) -&gt; t.Self: ...
    def _weeks(self, weeks: int) -&gt; t.Self: ...
    def _days(self, days: int) -&gt; t.Self: ...
    def _hours(self, hours: int) -&gt; t.Self: ...
    def _minutes(self, minutes: int) -&gt; t.Self: ...
    def _seconds(self, seconds: int) -&gt; t.Self: ...
    def _milliseconds(self, milliseconds: int) -&gt; t.Self: ...
    def _microseconds(self, microseconds: int) -&gt; t.Self: ...
    def _nanoseconds(self, nanoseconds: int) -&gt; t.Self: ...


class Timestamp:
    """
    A representation of a timestamp with second and nanosecond precision.
    """

    def __init__(
        self, second: int | None = None, nanosecond: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls: type[t.Self]) -&gt; t.Self: ...
    @classmethod
    def parse(cls: type[t.Self], s: str) -&gt; t.Self: ...
    @classmethod
    def from_millisecond(cls: type[t.Self], millisecond: int) -&gt; t.Self: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: Timestamp) -&gt; bool: ...
    def __gt__(self, other: Timestamp) -&gt; bool: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __le__(self, other: Timestamp) -&gt; bool: ...
    def __lt__(self, other: Timestamp) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: Timestamp, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def series(self, span: TimeSpan) -&gt; t.Iterator[Timestamp]: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...
    def string(self) -&gt; str: ...
    def as_second(self) -&gt; int: ...
    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(self, other: IntoTimestampDifference) -&gt; TimeSpan: ...
    def until(self, other: IntoTimestampDifference) -&gt; TimeSpan: ...


IntoTimestampDifference = (
    TimestampDifference
    | Timestamp
    | ZonedDateTime
    | tuple[JIFF_UNIT_STRING, Timestamp]
    | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)


class TimestampDifference:
    def __init__(
        self,
        date: Timestamp,
        *,
        smallest: JIFF_UNIT_STRING | None = None,
        largest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT_STRING) -&gt; TimestampDifference: ...
    def largest(self, unit: JIFF_UNIT_STRING) -&gt; TimestampDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; TimestampDifference: ...
    def increment(self, increment: int) -&gt; TimestampDifference: ...


class ZonedDateTime:
    def __init__(self, timestamp: Timestamp, time_zone: TimeZone) -&gt; None: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(
        cls: type[ZonedDateTime], dt: pydt.datetime
    ) -&gt; ZonedDateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(
        cls: type[ZonedDateTime], tz: str | None = None
    ) -&gt; ZonedDateTime: ...
    @classmethod
    def utcnow(cls: type[ZonedDateTime]) -&gt; ZonedDateTime: ...
    @classmethod
    def parse(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
    @classmethod
    def from_rfc2822(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(
        cls: type[ZonedDateTime], format: str, input: str
    ) -&gt; ZonedDateTime: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: ZonedDateTime) -&gt; bool: ...
    def __gt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def __le__(self, other: ZonedDateTime) -&gt; bool: ...
    def __lt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: ZonedDateTime, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; ZonedDateTime: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def checked_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; ZonedDateTime: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; ZonedDateTime: ...
    def first_of_year(self) -&gt; ZonedDateTime: ...
    def in_leap_year(self) -&gt; bool: ...
    def intz(self, tz: str) -&gt; t.Self: ...
    def inutc(self) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; ZonedDateTime: ...
    def last_of_year(self) -&gt; ZonedDateTime: ...
    def offset(self) -&gt; Offset: ...
    def round(self, options: JIFF_UNIT_STRING | DateTimeRound) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    @t.overload
    def saturating_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; t.Self: ...
    def start_of_day(self) -&gt; ZonedDateTime: ...
    def time(self) -&gt; Time: ...
    def time_zone(self) -&gt; TimeZone: ...
    def timestamp(self) -&gt; Timestamp: ...
    def timezone(self) -&gt; TimeZone: ...
    def to_rfc2822(self) -&gt; str: ...
    def tomorrow(self) -&gt; ZonedDateTime: ...
    def with_time_zone(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def yesterday(self) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self, other: ZonedDateTime | tuple[JIFF_UNIT_STRING, ZonedDateTime]
    ) -&gt; TimeSpan: ...
    def until(
        self, other: ZonedDateTime | tuple[JIFF_UNIT_STRING, ZonedDateTime]
    ) -&gt; TimeSpan: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================
    def nth_weekday(self) -&gt; t.NoReturn: ...
    def nth_weekday_of_month(self) -&gt; t.NoReturn: ...


class DateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT_STRING | None = None,
        mode: JIFF_ROUND_MODE_STRING | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE_STRING) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT_STRING) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT_STRING: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE_STRING: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT_STRING | None,
        mode: JIFF_ROUND_MODE_STRING | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class Offset:
    MIN: Offset
    MAX: Offset
    UTC: Offset
    ZERO: Offset

    def __init__(
        self, hours: int | None = None, seconds: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; Offset: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls: type[Offset]) -&gt; Offset: ...
    @classmethod
    def from_hours(cls: type[Offset], hours: int) -&gt; Offset: ...
    @classmethod
    def from_seconds(cls: type[Offset], seconds: int) -&gt; Offset: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def checked_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def negate(self) -&gt; Offset: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def since(self, other: Offset) -&gt; TimeSpan: ...
    def until(self, other: Offset) -&gt; TimeSpan: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
    unchecked: bool = False,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...

</code></pre>
<h2 id="ryjson-1"><a class="header" href="#ryjson-1"><code>ry.JSON</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.JSON"""

from typing import Literal

JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


def parse_json(
    data: bytes | str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...

</code></pre>
<h2 id="ry_dev-1"><a class="header" href="#ry_dev-1"><code>ry._dev</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.dev"""

from __future__ import annotations

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...

</code></pre>
<h2 id="rydirs-1"><a class="header" href="#rydirs-1"><code>ry.dirs</code></a></h2>
<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...

</code></pre>
<h2 id="ryhttp-1"><a class="header" href="#ryhttp-1"><code>ry.http</code></a></h2>
<pre><code class="language-python">class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(self, headers: dict[str, str]) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: str) -&gt; str: ...
    def __setitem__(self, key: str, value: str) -&gt; None: ...
    def __delitem__(self, key: str) -&gt; None: ...
    def __contains__(self, key: str) -&gt; bool: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def append(self, key: str, value: str) -&gt; None: ...
    def get(self, key: str) -&gt; str: ...
    def get_all(self, key: str) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def remove(self, key: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def pop(self, key: str) -&gt; str: ...
    def keys(self) -&gt; list[str]: ...

</code></pre>
<h2 id="ryreqwest-1"><a class="header" href="#ryreqwest-1"><code>ry.reqwest</code></a></h2>
<pre><code class="language-python">import typing as t


class AsyncClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | None = None,
        timeout: float | None = None,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
    ) -&gt; None: ...
    async def get(
        self, url: str, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def post(
        self,
        url: str,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def put(
        self,
        url: str,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def delete(
        self, url: str, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def patch(
        self,
        url: str,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def head(
        self, url: str, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: str,
        *,
        method: str = "GET",
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...


class Response:
    status_code: int
    headers: dict[str, str]

    async def text(self) -&gt; str: ...
    async def json(self) -&gt; t.Any: ...
    async def bytes(self) -&gt; bytes: ...
    def bytes_stream(self) -&gt; ResponseStream: ...


class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; bytes: ...


async def fetch(
    url: str,
    *,
    method: str = "GET",
    body: bytes | None = None,
    headers: dict[str, str] | None = None,
) -&gt; Response: ...

</code></pre>
<h2 id="ryxxhash-1"><a class="header" href="#ryxxhash-1"><code>ry.xxhash</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

import typing as t


@t.final
class Xxh32:
    name: t.Literal["xxh32"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh64:
    name: t.Literal["xxh64"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh3:
    name: t.Literal["xxh3"]

    def __init__(
        self,
        input: bytes = ...,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def digest128(self) -&gt; bytes: ...
    def hexdigest128(self) -&gt; str: ...
    def intdigest128(self) -&gt; int: ...
    def copy(self) -&gt; Xxh3: ...
    def reset(self) -&gt; None: ...


def xxh32(input: bytes | None = None, seed: int | None = None) -&gt; Xxh32: ...
def xxh64(input: bytes | None = None, seed: int | None = None) -&gt; Xxh64: ...
def xxh3(
    input: bytes | None = None,
    seed: int | None = None,
    secret: bytes | None = None,
) -&gt; Xxh3: ...


# xxh32
def xxh32_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh32_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh32_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh64
def xxh64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh128
def xxh128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh3
def xxh3_64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh3_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...


# xxh128
def xxh3_128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
