<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ry(o3) docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ry(o3) docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jessekrubin/ry" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><strong>updated:</strong> <code>2025-02-24T16:29:37.960259783+00:00[Etc/UTC]</code></p>
<hr />
<h1 id="readme"><a class="header" href="#readme">README</a></h1>
<h1 id="ry"><a class="header" href="#ry">ry</a></h1>
<p>ry = rust and python and bears, oh my!</p>
<p><a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/v/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/pyversions/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Python Version" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/wheel/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Wheel" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/dm/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Downloads" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/status/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - Status" /></a>
<a href="https://pypi.org/project/ry/"><img src="https://img.shields.io/pypi/l/ry?style=flat-square&amp;cacheSeconds=600" alt="PyPI - License" /></a></p>
<p><strong>DOCS:</strong> <a href="https://ryo3.dev">ryo3.dev</a> (WIP)</p>
<ul>
<li><code>ry</code> is a library of python shims/bindings to popular rust crates</li>
<li><code>ryo3-*</code> is the collection of rust crates providing the shims used by ry and possibly your <code>pyo3</code> rust-python library</li>
</ul>
<p><strong>THIS IS A WORK IN PROGRESS ~ FEEDBACK/PRs WELCOME!</strong></p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-bash">pip install ry
uv add ry
</code></pre>
<p><strong>Check install:</strong> <code>python -m ry</code></p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Check out the <a href="https://github.com/jessekrubin/ry/tree/main/examples">examples</a> directory for some quickstart examples.</p>
<hr />
<h2 id="what-and-why"><a class="header" href="#what-and-why">What and why?</a></h2>
<p>This is a collection of pyo3-wrappers for rust crates I wish existed in python.</p>
<p>It all started with me wanting a fast python <code>xxhash</code> and <code>fnv-64</code></p>
<h2 id="who"><a class="header" href="#who">Who?</a></h2>
<ul>
<li>jessekrubin <a href="mailto:jessekrubin@gmail.com">jessekrubin@gmail.com</a></li>
<li>possibly you!?</li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><em>(aka: questions that I have been asking myself)</em></p>
<ul>
<li><strong>Q:</strong> Why?
<ul>
<li><strong>A:</strong> I (jesse) needed several hashing functions for python and then kept
adding things as I needed them</li>
</ul>
</li>
<li><strong>Q:</strong> Does this have anything to do with the (excellent) package manager
<code>rye</code>?
<ul>
<li><strong>A:</strong> short answer: no. long answer: no, it does not.</li>
</ul>
</li>
<li><strong>Q:</strong> Why is the repo split into <code>ry</code> and <code>ryo3</code>?
<ul>
<li><strong>A:</strong> <code>ry</code> is the python package, <code>ryo3</code> is a rust crate setup to let you
“register” functions you may want if you were writing your own pyo3-python
bindings library; maybe someday the <code>ryo3::libs</code> module will be split up
into separate packages</li>
</ul>
</li>
</ul>
<h2 id="crate-bindings"><a class="header" href="#crate-bindings">Crate bindings</a></h2>
<p>ryo3-std</p>
<ul>
<li>wrapped crates:
<ul>
<li><code>heck</code></li>
<li><code>jiter</code></li>
<li><code>shlex</code></li>
<li><code>sqlformat</code></li>
<li><code>url</code></li>
<li><code>which</code></li>
<li>compression:
<ul>
<li><code>brotli</code></li>
<li><code>bzip2</code></li>
<li><code>flate2</code></li>
<li><code>zstd</code></li>
</ul>
</li>
<li>hashing:
<ul>
<li><code>fnv</code></li>
<li><code>xxhash</code></li>
</ul>
</li>
<li>burnt-sushi:
<ul>
<li><code>globset</code> (formerly <a href="https://pypi.org/project/globsters/">globsters</a>)</li>
<li><code>jiff</code></li>
<li><code>walkdir</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="future"><a class="header" href="#future">FUTURE?</a></h3>
<ul>
<li><code>subprocess.redo</code> (subprocesses that are lessy finicky and support tee-ing)</li>
<li>wrappers:
<ul>
<li><code>ignore</code></li>
<li><code>http</code></li>
<li><code>regex</code></li>
<li><code>reqwest</code> (async http client / waiting on pyo3 asyncio to stabilize and for me to have more time)</li>
<li><code>tokio</code> (<code>fs</code> and <code>process</code>)</li>
<li><code>tracing</code> (could be nicer than python’s awful logging lib – currently a part of ry/ryo3 for my dev purposes - currently has impl thingy in utiles)</li>
<li><code>tracing</code> (eg logging)</li>
<li><code>uuid</code></li>
</ul>
</li>
<li>organization
<ul>
<li>split up the <code>ryo3</code> type annotations?</li>
<li>chunk things into smaller sub-packages within the <code>ry</code> package?</li>
</ul>
</li>
</ul>
<hr />
<h2 id="api"><a class="header" href="#api">API</a></h2>
<!-- API-START -->
<h2 id="ry__init__"><a class="header" href="#ry__init__"><code>ry.__init__</code></a></h2>
<pre><code class="language-python">"""ry api ~ type annotations"""

import datetime as pydt
import typing as t
from os import PathLike
from pathlib import Path

import typing_extensions as te

from ry._types import Buffer

from . import http as http
from ._bytes import Bytes as Bytes
from ._jiff import Date as Date
from ._jiff import DateDifference as DateDifference
from ._jiff import DateTime as DateTime
from ._jiff import DateTimeDifference as DateTimeDifference
from ._jiff import DateTimeRound as DateTimeRound
from ._jiff import ISOWeekDate as ISOWeekDate
from ._jiff import Offset as Offset
from ._jiff import SignedDuration as SignedDuration
from ._jiff import Time as Time
from ._jiff import TimeDifference as TimeDifference
from ._jiff import TimeSpan as TimeSpan
from ._jiff import Timestamp as Timestamp
from ._jiff import TimestampDifference as TimestampDifference
from ._jiff import TimestampRound as TimestampRound
from ._jiff import TimeZone as TimeZone
from ._jiff import ZonedDateTime as ZonedDateTime
from ._jiff import ZonedDateTimeDifference as ZonedDateTimeDifference
from ._jiff import ZonedDateTimeRound as ZonedDateTimeRound
from ._jiff import date as date
from ._jiff import datetime as datetime
from ._jiff import offset as offset
from ._jiff import time as time
from ._jiff import timespan as timespan
from ._size import SizeFormatter as SizeFormatter
from ._size import fmt_size as fmt_size
from ._size import parse_size as parse_size
from ._url import URL as URL
from .http import Headers as Headers
from .http import HttpStatus as HttpStatus
from .reqwest import HttpClient as HttpClient
from .reqwest import ReqwestError as ReqwestError
from .reqwest import Response as Response
from .reqwest import ResponseStream as ResponseStream
from .reqwest import fetch as fetch
from .tokio import read_async as read_async
from .tokio import write_async as write_async

__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str

# =============================================================================
# TYPE ALIASES
# =============================================================================
JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)

# =============================================================================
# STD
# =============================================================================


# -----------------------------------------------------------------------------
# STD::TIME
# -----------------------------------------------------------------------------
class Duration:
    ZERO: Duration
    MIN: Duration
    MAX: Duration
    NANOSECOND: Duration
    MICROSECOND: Duration
    MILLISECOND: Duration
    SECOND: Duration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Duration) -&gt; bool: ...
    def __le__(self, other: Duration) -&gt; bool: ...
    def __gt__(self, other: Duration) -&gt; bool: ...
    def __ge__(self, other: Duration) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(
        self, other: Duration | pydt.timedelta, op: int
    ) -&gt; bool: ...
    def __str__(self) -&gt; str: ...
    def abs_diff(self, other: Duration) -&gt; Duration: ...
    def sleep(self) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[Duration], td: pydt.timedelta
    ) -&gt; Duration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; Duration: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; Duration: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; Duration: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; Duration: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; Duration: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; Duration: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_days(cls, days: int) -&gt; Duration: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; Duration: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Duration | None: ...
    def checked_div(self, other: Duration) -&gt; Duration | None: ...
    def checked_mul(self, other: Duration) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Duration | None: ...
    def div_duration_f32(self, other: Duration) -&gt; float: ...
    def div_duration_f64(self, other: Duration) -&gt; float: ...
    def div_f32(self, other: float) -&gt; Duration: ...
    def div_f64(self, other: float) -&gt; Duration: ...
    def mul_f32(self, other: float) -&gt; Duration: ...
    def mul_f64(self, other: float) -&gt; Duration: ...
    def saturating_add(self, other: Duration) -&gt; Duration: ...
    def saturating_mul(self, other: Duration) -&gt; Duration: ...
    def saturating_sub(self, other: Duration) -&gt; Duration: ...


class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; Instant: ...
    def __iadd__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Instant) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Instant | None: ...
    def checked_duration_since(self, earlier: Instant) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Instant | None: ...
    def duration_since(self, earlier: Instant) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: Instant) -&gt; Duration: ...


def instant() -&gt; Instant: ...


# -----------------------------------------------------------------------------
# STD::FS
# -----------------------------------------------------------------------------
class FileType:
    def __repr__(self) -&gt; str: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...


class Metadata:
    def __repr__(self) -&gt; str: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def len(self) -&gt; int: ...
    @property
    def is_empty(self) -&gt; bool: ...
    @property
    def modified(self) -&gt; pydt.datetime: ...
    @property
    def accessed(self) -&gt; pydt.datetime: ...
    @property
    def created(self) -&gt; pydt.datetime: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...


# =============================================================================
# RY03-CORE
# =============================================================================


class FsPath:
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __truediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def to_pathlib(self) -&gt; Path: ...
    def read_text(self) -&gt; str: ...
    def read_bytes(self) -&gt; bytes: ...
    def absolute(self) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def write_text(self, data: str) -&gt; None: ...
    def write_bytes(self, data: bytes) -&gt; None: ...
    def joinpath(self, *paths: str) -&gt; FsPath: ...
    def exists(self) -&gt; bool: ...
    def with_name(self, name: str) -&gt; FsPath: ...
    def with_suffix(self, suffix: str) -&gt; FsPath: ...
    def iterdir(self) -&gt; t.Iterator[FsPath]: ...
    def relative_to(self, other: PathLike[str] | str | FsPath) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...

    # TODO
    def __bytes__(self) -&gt; bytes: ...
    def as_uri(self) -&gt; str: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def string(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; FsPath: ...
    @classmethod
    def home(cls) -&gt; FsPath: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; FsPath: ...
    @property
    def parents(self) -&gt; t.Sequence[FsPath]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; str: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf
    # =========================================================================
    def _pop(self) -&gt; FsPath: ...
    def _push(self, path: PathLike[str] | str) -&gt; FsPath: ...
    def _set_extension(self, ext: str) -&gt; FsPath: ...
    def _set_file_name(self, name: str) -&gt; FsPath: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; t.Iterator[FsPath]: ...
    def canonicalize(self) -&gt; FsPath: ...
    def components(self) -&gt; t.Iterator[FsPath]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; FsPath: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, prefix: PathLike[str] | str) -&gt; FsPath: ...
    def with_extension(self, ext: str) -&gt; FsPath: ...
    def with_file_name(self, name: str) -&gt; FsPath: ...


FsPathLike = str | FsPath | PathLike[str]


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: FsPathLike) -&gt; None: ...
@t.overload
def ls(
    path: FsPathLike | None = None,
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[False] = False,
) -&gt; list[str]:
    """List directory contents - returns list of strings"""


@t.overload
def ls(
    path: FsPathLike | None = None,
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[True] = True,
) -&gt; list[FsPath]:
    """List directory contents - returns list of FsPath objects"""


def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """


# =============================================================================
# SLEEP
# =============================================================================
def sleep(seconds: float) -&gt; float: ...
async def sleep_async(seconds: float) -&gt; float: ...
async def asleep(seconds: float) -&gt; float:
    """Alias for sleep_async"""
    ...


# =============================================================================
# FILESYSTEM
# =============================================================================
def read(path: FsPathLike) -&gt; Bytes: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def read_text(path: FsPathLike) -&gt; str: ...
def write(path: FsPathLike, data: Buffer | str) -&gt; None: ...
def write_bytes(path: FsPathLike, data: bytes) -&gt; None: ...
def write_text(path: FsPathLike, data: str) -&gt; None: ...


# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------
# |~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~|
# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------

# =============================================================================
# Regex
# =============================================================================


class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: str | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def is_match(self, string: str) -&gt; bool: ...


# =============================================================================
# WHICH
# =============================================================================
def which(cmd: str, path: None | str = None) -&gt; str | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[str]: ...
def which_re(regex: str | Regex, path: None | str = None) -&gt; list[str]: ...


# =============================================================================
# HECK
# =============================================================================


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...


# =============================================================================
# GLOBSET
# =============================================================================
class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def regex(self) -&gt; str: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globster(self) -&gt; Globster: ...


class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def glob(
    pattern: str,
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Glob: ...
def globster(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Globster: ...


# =============================================================================
# WALKDIR
# =============================================================================
class WalkDirEntry:
    def __fspath__(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    @property
    def path(self) -&gt; FsPath: ...
    @property
    def file_name(self) -&gt; str: ...
    @property
    def depth(self) -&gt; int: ...
    @property
    def path_is_symlink(self) -&gt; bool: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def len(self) -&gt; int: ...


class WalkdirGen:
    """walkdir::Walkdir iterable wrapper"""

    files: bool
    dirs: bool

    def __next__(self) -&gt; str: ...
    def __iter__(self) -&gt; t.Iterator[str]: ...
    def collect(self) -&gt; list[str]: ...


def walkdir(
    path: FsPathLike | None = None,
    *,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
) -&gt; WalkdirGen: ...


# =============================================================================
# SAME_FILE
# =============================================================================


def is_same_file(a: PathLike[str], b: PathLike[str]) -&gt; bool: ...


# =============================================================================
# SHLEX
# =============================================================================
def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""
    ...


# =============================================================================
# JSON
# =============================================================================


class JsonParseKwargs(t.TypedDict, total=False):
    allow_inf_nan: bool
    """Allow parsing of `Infinity`, `-Infinity`, `NaN` ~ default: True"""
    cache_mode: t.Literal[True, False, "all", "keys", "none"]
    """Cache mode for JSON parsing ~ default: `all` """
    partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"]
    """Partial mode for JSON parsing ~ default: False"""
    catch_duplicate_keys: bool
    """Catch duplicate keys in JSON objects ~ default: False"""
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool
    """Mode for parsing JSON floats ~ default: False"""


def parse_json(
    data: bytes | str,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...


# =============================================================================
# FORMATTING
# =============================================================================
def unindent(string: str) -&gt; str: ...
def unindent_bytes(string: bytes) -&gt; bytes: ...


# =============================================================================
# FNV
# =============================================================================
class FnvHasher:
    name: t.Literal["fnv1a"]

    def __init__(self, input: bytes | None = None) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; FnvHasher: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def fnv1a(input: bytes) -&gt; FnvHasher: ...


# =============================================================================
# BROTLI
# =============================================================================
def brotli_encode(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(input: bytes) -&gt; bytes: ...
def brotli(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""


# =============================================================================
# BZIP2
# =============================================================================
def bzip2_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def bzip2_decode(input: bytes) -&gt; bytes: ...
def bzip2(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for bzip2_encode"""


# =============================================================================
# GZIP
# =============================================================================
def gzip_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def gzip_decode(input: bytes) -&gt; bytes: ...
def gzip(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for gzip_encode"""


def gunzip(input: bytes) -&gt; bytes:
    """Alias for gzip_decode"""


# =============================================================================
# ZSTD
# =============================================================================
def zstd_encode(input: bytes, level: int = 3) -&gt; bytes: ...
def zstd(input: bytes, level: int = 3) -&gt; bytes:
    """Alias for zstd_encode"""


def zstd_decode(input: bytes) -&gt; bytes: ...


# =============================================================================
# SQLFORMAT
# =============================================================================
SqlfmtParamValue = str | int | float | bool
TSqlfmtParamValue_co = t.TypeVar(
    "TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike = (
    dict[str, TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, TSqlfmtParamValue_co]]
    | t.Sequence[TSqlfmtParamValue_co]
)


class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[TSqlfmtParamValue_co] | SqlfmtQueryParams,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int = 2,  # -1 or any negative value will use tabs
    uppercase: bool | None = True,
    lines_between_statements: int = 1,
) -&gt; str: ...

</code></pre>
<h2 id="ryjson"><a class="header" href="#ryjson"><code>ry.JSON</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.JSON"""

from typing import Literal

JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


def parse_json(
    data: bytes | str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...

</code></pre>
<h2 id="ry_bytes"><a class="header" href="#ry_bytes"><code>ry._bytes</code></a></h2>
<pre><code class="language-python">import sys
from typing import overload

if sys.version_info &gt;= (3, 12):
    from collections.abc import Buffer as Buffer
else:
    from typing_extensions import Buffer as Buffer


class Bytes(Buffer):
    """
    A buffer implementing the Python buffer protocol, allowing zero-copy access
    to underlying Rust memory.

    You can pass this to `memoryview` for a zero-copy view into the underlying
    data or to `bytes` to copy the underlying data into a Python `bytes`.

    Many methods from the Python `bytes` class are implemented on this,
    """

    def __init__(self, buf: Buffer = b"") -&gt; None:
        """Construct a new Bytes object.

        This will be a zero-copy view on the Python byte slice.
        """

    def __add__(self, other: Buffer) -&gt; Bytes: ...
    def __buffer__(self, flags: int) -&gt; memoryview[int]: ...
    def __contains__(self, other: Buffer) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @overload
    def __getitem__(self, other: int) -&gt; int: ...
    @overload
    def __getitem__(self, other: slice) -&gt; Bytes: ...
    def __mul__(self, other: Buffer) -&gt; int: ...
    def __len__(self) -&gt; int: ...
    def __repr__(self) -&gt; str: ...
    def removeprefix(self, prefix: Buffer, /) -&gt; Bytes:
        """
        If the binary data starts with the prefix string, return `bytes[len(prefix):]`.
        Otherwise, return the original binary data.
        """

    def removesuffix(self, suffix: Buffer, /) -&gt; Bytes:
        """
        If the binary data ends with the suffix string and that suffix is not empty,
        return `bytes[:-len(suffix)]`. Otherwise, return the original binary data.
        """

    def isalnum(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetical ASCII characters or
        ASCII decimal digits and the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal digits
        are those byte values in the sequence `b'0123456789'`.
        """

    def isalpha(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetic ASCII characters and
        the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
        """

    def isascii(self) -&gt; bool:
        """
        Return `True` if the sequence is empty or all bytes in the sequence are ASCII,
        `False` otherwise.

        ASCII bytes are in the range `0-0x7F`.
        """

    def isdigit(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII decimal digits and the
        sequence is not empty, `False` otherwise.

        ASCII decimal digits are those byte values in the sequence `b'0123456789'`.
        """

    def islower(self) -&gt; bool:
        """
        Return `True` if there is at least one lowercase ASCII character in the sequence
        and no uppercase ASCII characters, `False` otherwise.
        """

    def isspace(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII whitespace and the sequence
        is not empty, `False` otherwise.

        ASCII whitespace characters are those byte values
        in the sequence `b' \t\n\r\x0b\f'` (space, tab, newline, carriage return,
        vertical tab, form feed).
        """

    def isupper(self) -&gt; bool:
        """
        Return `True` if there is at least one uppercase alphabetic ASCII character in
        the sequence and no lowercase ASCII characters, `False` otherwise.
        """

    def lower(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the uppercase ASCII characters converted
        to their corresponding lowercase counterpart.
        """

    def upper(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the lowercase ASCII characters converted
        to their corresponding uppercase counterpart.
        """

    def to_bytes(self) -&gt; bytes:
        """Copy this buffer's contents into a Python `bytes` object."""

    # =========================================================================
    # IMPL IN RY
    # =========================================================================

    def decode(self, encoding: str = "utf-8", errors: str = "strict") -&gt; str:
        """Decode the binary data using the given encoding."""

    def hex(
        self, sep: str | None = None, bytes_per_sep: int | None = None
    ) -&gt; str:
        """Return a hexadecimal representation of the binary data."""

    @classmethod
    def fromhex(cls, hexstr: str) -&gt; Bytes:
        """Construct a `Bytes` object from a hexadecimal string."""


BytesLike = Buffer | bytes | bytearray | memoryview | Bytes

</code></pre>
<h2 id="ry_dev"><a class="header" href="#ry_dev"><code>ry._dev</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.dev"""

from __future__ import annotations

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...

</code></pre>
<h2 id="ry_jiff"><a class="header" href="#ry_jiff"><code>ry._jiff</code></a></h2>
<pre><code class="language-python">"""jiff types"""

import datetime as pydt
import typing as t

import typing_extensions as te

from ry._types import (
    DateTimeTypedDict,
    DateTypedDict,
    TimeSpanTypedDict,
    TimeTypedDict,
)
from ry.ryo3 import Duration

# =============================================================================
# JIFF
# =============================================================================
JIFF_UNIT = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JIFF_ROUND_MODE = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half_ceil",
    "half_floor",
    "half_expand",
    "half_trunc",
    "half_even",
]

WEEKDAY = t.Literal[
    "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
]

JIFF_WEEKDAY_INT = t.Literal[
    1,  # Monday
    2,  # Tuesday
    3,  # Wednesday
    4,  # Thursday
    5,  # Friday
    6,  # Saturday
    7,  # Sunday
]


class Date:
    MIN: Date
    MAX: Date
    ZERO: Date

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls: type[Date], date: pydt.date) -&gt; Date: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(
        cls: type[Date], year: int, week: int, weekday: int
    ) -&gt; Date: ...
    @classmethod
    def today(cls: type[Date]) -&gt; Date: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls: type[Date], format: str, string: str) -&gt; Date: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __isub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int
    ) -&gt; DateTime: ...
    def asdict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: Date) -&gt; Date: ...
    def duration_until(self, other: Date) -&gt; Date: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; Date: ...
    def first_of_year(self) -&gt; Date: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; Date: ...
    def last_of_year(self) -&gt; Date: ...
    def nth_weekday(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def nth_weekday_of_month(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Date]: ...
    def to_datetime(self, time: Time) -&gt; DateTime: ...
    def tomorrow(self) -&gt; Date: ...
    def yesterday(self) -&gt; Date: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...


class DateDifference:
    def __init__(
        self,
        date: Date,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; DateDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; DateDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateDifference: ...
    def increment(self, increment: int) -&gt; DateDifference: ...


class Time:
    MIN: Time
    MAX: Time

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __isub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls: type[Time], format: str, string: str) -&gt; Time: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls: type[Time], t: pydt.time) -&gt; Time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def now(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def parse(cls: type[Time], s: str) -&gt; Time: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; None: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def asdict(self) -&gt; TimeTypedDict: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Time]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    @t.overload
    def checked_sub(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; Time: ...
    def to_datetime(self, d: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class TimeDifference:
    def __init__(
        self,
        date: Time,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; TimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; TimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimeDifference: ...
    def increment(self, increment: int) -&gt; TimeDifference: ...


class DateTime:
    MIN: DateTime
    MAX: DateTime
    ZERO: DateTime

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls: type[DateTime], format: str, string: str) -&gt; DateTime: ...
    @classmethod
    def parse(cls: type[DateTime], s: str) -&gt; DateTime: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls: type[DateTime], dt: pydt.datetime) -&gt; DateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls: type[DateTime]) -&gt; DateTime: ...
    @classmethod
    def from_parts(cls: type[DateTime], date: Date, time: Time) -&gt; DateTime: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __repr__(self) -&gt; str: ...
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __sub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __isub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def iso_week_date(self) -&gt; tuple[int, int, int]: ...
    def date(self) -&gt; Date: ...
    def time(self) -&gt; Time: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[DateTime]: ...
    def asdict(self) -&gt; DateTimeTypedDict: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        *,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; DateTime: ...
    def _round(self, options: DateTimeRound) -&gt; DateTime: ...
    def yesterday(self) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def saturating_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================
    def first_of_month(self) -&gt; DateTime: ...
    def first_of_year(self) -&gt; DateTime: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def duration_since(self, other: DateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: DateTime) -&gt; SignedDuration: ...
    def in_leap_year(self) -&gt; bool: ...
    def end_of_day(self) -&gt; DateTime: ...
    def nth_weekday(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; DateTime: ...
    def nth_weekday_of_month(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; DateTime: ...
    def last_of_month(self) -&gt; DateTime: ...
    def last_of_year(self) -&gt; DateTime: ...
    def start_of_day(self) -&gt; DateTime: ...
    def tomorrow(self) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class DateTimeDifference:
    def __init__(
        self,
        date: DateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; DateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; DateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeDifference: ...
    def increment(self, increment: int) -&gt; DateTimeDifference: ...


class TimeZone:
    def __init__(self, name: str) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    @classmethod
    def from_pytzinfo(cls: type[TimeZone], tz: pydt.tzinfo) -&gt; TimeZone: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls: type[TimeZone], offset: Offset) -&gt; TimeZone: ...
    @classmethod
    def get(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def posix(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def try_system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def tzif(cls: type[TimeZone], name: str, data: bytes) -&gt; TimeZone: ...
    @classmethod
    def utc(cls: type[TimeZone]) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, dt: Timestamp) -&gt; DateTime: ...
    def to_offset(self, timestamp: Timestamp) -&gt; Offset: ...
    def to_timestamp(self, dt: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, other: DateTime) -&gt; ZonedDateTime: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


class SignedDuration:
    MIN: SignedDuration
    MAX: SignedDuration
    ZERO: SignedDuration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __mul__(self, other: int) -&gt; SignedDuration: ...
    def __rmul__(self, other: int) -&gt; SignedDuration: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; SignedDuration: ...
    def __add__(self, other: SignedDuration) -&gt; SignedDuration: ...
    def __abs__(self) -&gt; SignedDuration: ...
    def __div__(self, other: int) -&gt; SignedDuration: ...
    def abs(self) -&gt; SignedDuration: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(
        self, other: SignedDuration | pydt.timedelta, op: int
    ) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self, human: bool = False) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[SignedDuration], td: pydt.timedelta
    ) -&gt; SignedDuration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls: type[SignedDuration], s: str) -&gt; SignedDuration: ...
    @classmethod
    def from_hours(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_micros(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_millis(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_mins(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_nanos(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def checked_div(self, other: int) -&gt; SignedDuration | None: ...
    def checked_mul(self, other: int) -&gt; SignedDuration | None: ...
    def checked_neg(self) -&gt; SignedDuration | None: ...
    def checked_sub(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def div_duration_f32(self, other: SignedDuration) -&gt; float: ...
    def div_duration_f64(self, other: SignedDuration) -&gt; float: ...
    def div_f32(self, other: int) -&gt; float: ...
    def div_f64(self, other: int) -&gt; float: ...
    def is_positive(self) -&gt; bool: ...
    def mul_f32(self, other: int) -&gt; SignedDuration: ...
    def mul_f64(self, other: int) -&gt; SignedDuration: ...
    def saturating_add(self, other: SignedDuration) -&gt; SignedDuration: ...
    def saturating_mul(self, other: int) -&gt; SignedDuration: ...
    def saturating_sub(self, other: SignedDuration) -&gt; SignedDuration: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def subsec_micros(self) -&gt; int: ...
    def subsec_millis(self) -&gt; int: ...
    def subsec_nanos(self) -&gt; int: ...
    def to_timespan(self) -&gt; TimeSpan: ...


# put in quotes to avoid ruff F821 - undefined name
_TimeSpanArithmeticSingle = TimeSpan | Duration | SignedDuration
_TimeSpanArithmeticTuple = tuple[
    _TimeSpanArithmeticSingle, ZonedDateTime | Date | DateTime
]
TimeSpanArithmetic = _TimeSpanArithmeticSingle | _TimeSpanArithmeticTuple


class TimeSpan:
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self, human: bool = False) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, td: pydt.timedelta) -&gt; TimeSpan: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls, s: str) -&gt; TimeSpan: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; te.Self: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; te.Self: ...
    def __mul__(self, other: int) -&gt; te.Self: ...
    def __neg__(self) -&gt; te.Self: ...
    def __abs__(self) -&gt; te.Self: ...
    def __invert__(self) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: TimeSpan) -&gt; bool: ...
    def __gt__(self, other: TimeSpan) -&gt; bool: ...
    def __le__(self, other: TimeSpan) -&gt; bool: ...
    def __lt__(self, other: TimeSpan) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: TimeSpan) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; te.Self: ...
    def asdict(self) -&gt; TimeSpanTypedDict: ...
    def checked_add(self, val: TimeSpanArithmetic) -&gt; te.Self: ...
    def checked_mul(self, other: int) -&gt; te.Self: ...
    def checked_sub(self, val: TimeSpanArithmetic) -&gt; te.Self: ...
    def compare(
        self,
        other: TimeSpan,
        relative: ZonedDateTime | DateTime | Date | None = None,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def negate(self) -&gt; te.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; te.Self: ...
    def round(
        self,
        smallest: JIFF_UNIT,
        increment: int = 1,
        *,
        relative: ZonedDateTime | Date | DateTime | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
    ) -&gt; te.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self, relative: ZonedDateTime | Date | DateTime
    ) -&gt; SignedDuration: ...
    def total(
        self,
        unit: JIFF_UNIT,
        relative: ZonedDateTime | Date | DateTime | None = None,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def total_seconds(self) -&gt; int: ...
    def try_years(self, years: int) -&gt; te.Self: ...
    def try_months(self, months: int) -&gt; te.Self: ...
    def try_weeks(self, weeks: int) -&gt; te.Self: ...
    def try_days(self, days: int) -&gt; te.Self: ...
    def try_hours(self, hours: int) -&gt; te.Self: ...
    def try_minutes(self, minutes: int) -&gt; te.Self: ...
    def try_seconds(self, seconds: int) -&gt; te.Self: ...
    def try_milliseconds(self, milliseconds: int) -&gt; te.Self: ...
    def try_microseconds(self, microseconds: int) -&gt; te.Self: ...
    def try_nanoseconds(self, nanoseconds: int) -&gt; te.Self: ...

    # -------------------------------------------------------------------------
    # PANIC-INDUCING METHODS
    # -------------------------------------------------------------------------
    def _years(self, years: int) -&gt; te.Self: ...
    def _months(self, months: int) -&gt; te.Self: ...
    def _weeks(self, weeks: int) -&gt; te.Self: ...
    def _days(self, days: int) -&gt; te.Self: ...
    def _hours(self, hours: int) -&gt; te.Self: ...
    def _minutes(self, minutes: int) -&gt; te.Self: ...
    def _seconds(self, seconds: int) -&gt; te.Self: ...
    def _milliseconds(self, milliseconds: int) -&gt; te.Self: ...
    def _microseconds(self, microseconds: int) -&gt; te.Self: ...
    def _nanoseconds(self, nanoseconds: int) -&gt; te.Self: ...


class Timestamp:
    """
    A representation of a timestamp with second and nanosecond precision.
    """

    MIN: Timestamp
    MAX: Timestamp
    UNIX_EPOCH: Timestamp

    def __init__(
        self, second: int | None = None, nanosecond: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; Timestamp: ...
    @classmethod
    def parse(cls, s: str) -&gt; Timestamp: ...
    @classmethod
    def from_millisecond(cls, millisecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_microsecond(cls, microsecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_nanosecond(cls, nanosecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_second(cls, second: int) -&gt; Timestamp: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: Timestamp) -&gt; bool: ...
    def __gt__(self, other: Timestamp) -&gt; bool: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __le__(self, other: Timestamp) -&gt; bool: ...
    def __lt__(self, other: Timestamp) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: Timestamp, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def __sub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls, format: str, input: str) -&gt; Timestamp: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...
    def as_second(self) -&gt; int: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    @t.overload
    def checked_sub(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def display_with_offset(self, offset: Offset) -&gt; str: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime:
        """Deprecated ~ use `in_tz`"""

    def is_zero(self) -&gt; bool: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Timestamp]: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def string(self) -&gt; str: ...
    def subsec_microsecond(self) -&gt; int: ...
    def subsec_millisecond(self) -&gt; int: ...
    def subsec_nanosecond(self) -&gt; int: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def duration_since(self, other: Timestamp) -&gt; SignedDuration: ...
    def duration_until(self, other: Timestamp) -&gt; SignedDuration: ...
    def round(
        self,
        unit: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; Timestamp: ...
    def _round(self, options: TimestampRound) -&gt; Timestamp: ...


class TimestampDifference:
    def __init__(
        self,
        date: Timestamp,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; TimestampDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; TimestampDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimestampDifference: ...
    def increment(self, increment: int) -&gt; TimestampDifference: ...


class ZonedDateTime:
    def __init__(self, timestamp: Timestamp, time_zone: TimeZone) -&gt; None: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(
        cls: type[ZonedDateTime], dt: pydt.datetime
    ) -&gt; ZonedDateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(
        cls: type[ZonedDateTime], tz: str | None = None
    ) -&gt; ZonedDateTime: ...
    @classmethod
    def utcnow(cls: type[ZonedDateTime]) -&gt; ZonedDateTime: ...
    @classmethod
    def parse(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
    @classmethod
    def from_rfc2822(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(
        cls: type[ZonedDateTime], format: str, input: str
    ) -&gt; ZonedDateTime: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: ZonedDateTime) -&gt; bool: ...
    def __gt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __le__(self, other: ZonedDateTime) -&gt; bool: ...
    def __lt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: ZonedDateTime, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def __sub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; ZonedDateTime: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def checked_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; ZonedDateTime: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; ZonedDateTime: ...
    def first_of_year(self) -&gt; ZonedDateTime: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: str) -&gt; te.Self: ...
    def intz(self, tz: str) -&gt; te.Self: ...
    def inutc(self) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; ZonedDateTime: ...
    def last_of_year(self) -&gt; ZonedDateTime: ...
    def nth_weekday(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def nth_weekday_of_month(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def offset(self) -&gt; Offset: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        *,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; DateTime: ...
    def _round(self, options: ZonedDateTimeRound) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def saturating_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def start_of_day(self) -&gt; ZonedDateTime: ...
    def time(self) -&gt; Time: ...
    def time_zone(self) -&gt; TimeZone: ...
    def timestamp(self) -&gt; Timestamp: ...
    def timezone(self) -&gt; TimeZone: ...
    def to_rfc2822(self) -&gt; str: ...
    def tomorrow(self) -&gt; ZonedDateTime: ...
    def with_time_zone(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def yesterday(self) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self,
        other: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class ZonedDateTimeDifference:
    def __init__(
        self,
        date: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; ZonedDateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; ZonedDateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; ZonedDateTimeDifference: ...
    def increment(self, increment: int) -&gt; ZonedDateTimeDifference: ...


class ISOWeekDate:
    MIN: ISOWeekDate
    MAX: ISOWeekDate
    ZERO: ISOWeekDate

    def __init__(
        self, year: int, week: int, weekday: JIFF_WEEKDAY_INT | WEEKDAY
    ) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================

    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __le__(self, other: ISOWeekDate) -&gt; bool: ...
    def __gt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __ge__(self, other: ISOWeekDate) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_date(cls: type[ISOWeekDate], date: Date) -&gt; ISOWeekDate: ...
    @classmethod
    def today(cls: type[ISOWeekDate]) -&gt; ISOWeekDate: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def week(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; JIFF_WEEKDAY_INT: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...


class TimestampRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimestampRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; TimestampRound: ...
    def increment(self, increment: int) -&gt; TimestampRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; TimestampRound: ...


class DateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class ZonedDateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class Offset:
    MIN: Offset
    MAX: Offset
    UTC: Offset
    ZERO: Offset

    def __init__(
        self, hours: int | None = None, seconds: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; Offset: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls: type[Offset]) -&gt; Offset: ...
    @classmethod
    def from_hours(cls: type[Offset], hours: int) -&gt; Offset: ...
    @classmethod
    def from_seconds(cls: type[Offset], seconds: int) -&gt; Offset: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def checked_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def negate(self) -&gt; Offset: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def since(self, other: Offset) -&gt; TimeSpan: ...
    def until(self, other: Offset) -&gt; TimeSpan: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
    unchecked: bool = False,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...

</code></pre>
<h2 id="ry_size"><a class="header" href="#ry_size"><code>ry._size</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

from typing import Literal

FORMAT_SIZE_BASE = Literal[2, 10]  # default=2
FORMAT_SIZE_STYLE = Literal[  # default="default"
    "default",
    "abbreviated",
    "abbreviated_lowercase",
    "abbreviated-lowercase",
    "full",
    "full-lowercase",
    "full_lowercase",
]


def fmt_size(
    n: int,
    *,
    base: FORMAT_SIZE_BASE | None = 2,
    style: FORMAT_SIZE_STYLE | None = "default",
) -&gt; str:
    """Return human-readable string representation of bytes-size."""


def parse_size(s: str) -&gt; int:
    """Return integer representation of human-readable bytes-size string.

    Raises:
        ValueError: If string is not a valid human-readable bytes-size string.
    """


class SizeFormatter:
    """Human-readable bytes-size formatter."""

    def __init__(
        self,
        base: FORMAT_SIZE_BASE | None = 2,
        style: FORMAT_SIZE_STYLE | None = "default",
    ):
        self.base = base
        self.style = style

    def format(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __call__(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __repr__(self) -&gt; str: ...

</code></pre>
<h2 id="ry_url"><a class="header" href="#ry_url"><code>ry._url</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

from ipaddress import IPv4Address


class URL:
    def __init__(
        self, url: str | URL, *, params: dict[str, str] | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, url: str) -&gt; URL: ...
    @classmethod
    def parse_with_params(cls, url: str, params: dict[str, str]) -&gt; URL: ...
    @classmethod
    def from_directory_path(cls, path: str) -&gt; URL: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: URL) -&gt; bool: ...
    def __gt__(self, other: URL) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: URL) -&gt; bool: ...
    def __lt__(self, other: URL) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rtruediv__(self, relative: str) -&gt; URL: ...
    def __truediv__(self, relative: str) -&gt; URL: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None: ...
    @property
    def port_or_known_default(self) -&gt; int | None: ...
    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_pairs(self) -&gt; list[tuple[str, str]]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def username(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def to_filepath(self) -&gt; str: ...
    def replace_fragment(self, fragment: str | None = None) -&gt; URL: ...
    def replace_host(self, host: str | None = None) -&gt; URL: ...
    def replace_ip_host(self, host: IPv4Address | IPv4Address) -&gt; URL: ...
    def replace_password(self, password: str | None = None) -&gt; URL: ...
    def replace_path(self, path: str) -&gt; URL: ...
    def replace_port(self, port: int | None = None) -&gt; URL: ...
    def replace_query(self, query: str | None = None) -&gt; URL: ...
    def replace_scheme(self, scheme: str) -&gt; URL: ...
    def replace_username(self, username: str) -&gt; URL: ...
    def socket_addrs(self) -&gt; None: ...

</code></pre>
<h2 id="rydirs"><a class="header" href="#rydirs"><code>ry.dirs</code></a></h2>
<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...

</code></pre>
<h2 id="ryhttp"><a class="header" href="#ryhttp"><code>ry.http</code></a></h2>
<pre><code class="language-python">class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(self, headers: dict[str, str]) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: str) -&gt; str: ...
    def __setitem__(self, key: str, value: str) -&gt; None: ...
    def __delitem__(self, key: str) -&gt; None: ...
    def __contains__(self, key: str) -&gt; bool: ...
    def __or__(self, other: Headers | dict[str, str]) -&gt; Headers: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def append(self, key: str, value: str) -&gt; None: ...
    def get(self, key: str) -&gt; str | None: ...
    def get_all(self, key: str) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def remove(self, key: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def pop(self, key: str) -&gt; str: ...
    def keys(self) -&gt; list[str]: ...
    def update(self, headers: Headers | dict[str, str]) -&gt; None: ...


class HttpStatus:
    def __init__(self, code: int) -&gt; None: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: HttpStatus | int) -&gt; bool: ...
    def __le__(self, other: HttpStatus | int) -&gt; bool: ...
    def __gt__(self, other: HttpStatus | int) -&gt; bool: ...
    def __ge__(self, other: HttpStatus | int) -&gt; bool: ...
    def reason(self) -&gt; str: ...
    def is_informational(self) -&gt; bool: ...
    def is_success(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_client_error(self) -&gt; bool: ...
    def is_server_error(self) -&gt; bool: ...
    def is_ok(self) -&gt; bool: ...
    @property
    def ok(self) -&gt; bool: ...

    # =========================================================================
    # CONST STATUS CODES
    # =========================================================================
    CONTINUE: HttpStatus  # 100 ~ Continue
    SWITCHING_PROTOCOLS: HttpStatus  # 101 ~ Switching Protocols
    PROCESSING: HttpStatus  # 102 ~ Processing
    OK: HttpStatus  # 200 ~ OK
    CREATED: HttpStatus  # 201 ~ Created
    ACCEPTED: HttpStatus  # 202 ~ Accepted
    NON_AUTHORITATIVE_INFORMATION: (
        HttpStatus  # 203 ~ Non Authoritative Information
    )
    NO_CONTENT: HttpStatus  # 204 ~ No Content
    RESET_CONTENT: HttpStatus  # 205 ~ Reset Content
    PARTIAL_CONTENT: HttpStatus  # 206 ~ Partial Content
    MULTI_STATUS: HttpStatus  # 207 ~ Multi-Status
    ALREADY_REPORTED: HttpStatus  # 208 ~ Already Reported
    IM_USED: HttpStatus  # 226 ~ IM Used
    MULTIPLE_CHOICES: HttpStatus  # 300 ~ Multiple Choices
    MOVED_PERMANENTLY: HttpStatus  # 301 ~ Moved Permanently
    FOUND: HttpStatus  # 302 ~ Found
    SEE_OTHER: HttpStatus  # 303 ~ See Other
    NOT_MODIFIED: HttpStatus  # 304 ~ Not Modified
    USE_PROXY: HttpStatus  # 305 ~ Use Proxy
    TEMPORARY_REDIRECT: HttpStatus  # 307 ~ Temporary Redirect
    PERMANENT_REDIRECT: HttpStatus  # 308 ~ Permanent Redirect
    BAD_REQUEST: HttpStatus  # 400 ~ Bad Request
    UNAUTHORIZED: HttpStatus  # 401 ~ Unauthorized
    PAYMENT_REQUIRED: HttpStatus  # 402 ~ Payment Required
    FORBIDDEN: HttpStatus  # 403 ~ Forbidden
    NOT_FOUND: HttpStatus  # 404 ~ Not Found
    METHOD_NOT_ALLOWED: HttpStatus  # 405 ~ Method Not Allowed
    NOT_ACCEPTABLE: HttpStatus  # 406 ~ Not Acceptable
    PROXY_AUTHENTICATION_REQUIRED: (
        HttpStatus  # 407 ~ Proxy Authentication Required
    )
    REQUEST_TIMEOUT: HttpStatus  # 408 ~ Request Timeout
    CONFLICT: HttpStatus  # 409 ~ Conflict
    GONE: HttpStatus  # 410 ~ Gone
    LENGTH_REQUIRED: HttpStatus  # 411 ~ Length Required
    PRECONDITION_FAILED: HttpStatus  # 412 ~ Precondition Failed
    PAYLOAD_TOO_LARGE: HttpStatus  # 413 ~ Payload Too Large
    URI_TOO_LONG: HttpStatus  # 414 ~ URI Too Long
    UNSUPPORTED_MEDIA_TYPE: HttpStatus  # 415 ~ Unsupported Media Type
    RANGE_NOT_SATISFIABLE: HttpStatus  # 416 ~ Range Not Satisfiable
    EXPECTATION_FAILED: HttpStatus  # 417 ~ Expectation Failed
    IM_A_TEAPOT: HttpStatus  # 418 ~ I'm a teapot
    MISDIRECTED_REQUEST: HttpStatus  # 421 ~ Misdirected Request
    UNPROCESSABLE_ENTITY: HttpStatus  # 422 ~ Unprocessable Entity
    LOCKED: HttpStatus  # 423 ~ Locked
    FAILED_DEPENDENCY: HttpStatus  # 424 ~ Failed Dependency
    TOO_EARLY: HttpStatus  # 425 ~ Too Early
    UPGRADE_REQUIRED: HttpStatus  # 426 ~ Upgrade Required
    PRECONDITION_REQUIRED: HttpStatus  # 428 ~ Precondition Required
    TOO_MANY_REQUESTS: HttpStatus  # 429 ~ Too Many Requests
    REQUEST_HEADER_FIELDS_TOO_LARGE: (
        HttpStatus  # 431 ~ Request Header Fields Too Large
    )
    UNAVAILABLE_FOR_LEGAL_REASONS: (
        HttpStatus  # 451 ~ Unavailable For Legal Reasons
    )
    INTERNAL_SERVER_ERROR: HttpStatus  # 500 ~ Internal Server Error
    NOT_IMPLEMENTED: HttpStatus  # 501 ~ Not Implemented
    BAD_GATEWAY: HttpStatus  # 502 ~ Bad Gateway
    SERVICE_UNAVAILABLE: HttpStatus  # 503 ~ Service Unavailable
    GATEWAY_TIMEOUT: HttpStatus  # 504 ~ Gateway Timeout
    HTTP_VERSION_NOT_SUPPORTED: HttpStatus  # 505 ~ HTTP Version Not Supported
    VARIANT_ALSO_NEGOTIATES: HttpStatus  # 506 ~ Variant Also Negotiates
    INSUFFICIENT_STORAGE: HttpStatus  # 507 ~ Insufficient Storage
    LOOP_DETECTED: HttpStatus  # 508 ~ Loop Detected
    NOT_EXTENDED: HttpStatus  # 510 ~ Not Extended
    NETWORK_AUTHENTICATION_REQUIRED: (
        HttpStatus  # 511 ~ Network Authentication Required
    )

</code></pre>
<h2 id="ryreqwest"><a class="header" href="#ryreqwest"><code>ry.reqwest</code></a></h2>
<pre><code class="language-python">import typing as t
from http import HTTPStatus

import ry

if t.TYPE_CHECKING:
    from ry import Duration, Headers
    from ry.ryo3._url import URL


class HttpClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | None = None,
        user_agent: str | None = None,  # default ~ 'ry-reqwest/&lt;VERSION&gt; ...'
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
    ) -&gt; None: ...
    async def get(
        self, url: str | URL, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def post(
        self,
        url: str | URL,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def put(
        self,
        url: str | URL,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def delete(
        self, url: str | URL, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def patch(
        self,
        url: str | URL,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def head(
        self, url: str | URL, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: str | URL,
        *,
        method: str = "GET",
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...


class ReqwestError(Exception):
    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __dbg__(self) -&gt; str: ...
    def is_body(self) -&gt; bool: ...
    def is_builder(self) -&gt; bool: ...
    def is_connect(self) -&gt; bool: ...
    def is_decode(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_request(self) -&gt; bool: ...
    def is_status(self) -&gt; bool: ...
    def is_timeout(self) -&gt; bool: ...
    def status(self) -&gt; HTTPStatus | None: ...
    def url(self) -&gt; URL | None: ...


class Response:
    status_code: int

    @property
    def headers(self) -&gt; Headers: ...
    async def text(self) -&gt; str: ...
    async def json(self) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(self) -&gt; ResponseStream: ...


class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...


async def fetch(
    url: str | URL,
    *,
    client: HttpClient | None = None,
    method: str = "GET",
    body: bytes | None = None,
    headers: dict[str, str] | None = None,
) -&gt; Response: ...

</code></pre>
<h2 id="rytokio"><a class="header" href="#rytokio"><code>ry.tokio</code></a></h2>
<pre><code class="language-python">from ry import Bytes
from ry._types import Buffer
from ry.ryo3 import FsPathLike


async def read_async(path: FsPathLike) -&gt; Bytes: ...
async def write_async(path: FsPathLike, data: Buffer) -&gt; None: ...

</code></pre>
<h2 id="ryxxhash"><a class="header" href="#ryxxhash"><code>ry.xxhash</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

import typing as t


@t.final
class Xxh32:
    name: t.Literal["xxh32"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh64:
    name: t.Literal["xxh64"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh3:
    name: t.Literal["xxh3"]

    def __init__(
        self,
        input: bytes = ...,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def digest128(self) -&gt; bytes: ...
    def hexdigest128(self) -&gt; str: ...
    def intdigest128(self) -&gt; int: ...
    def copy(self) -&gt; Xxh3: ...
    def reset(self) -&gt; None: ...


def xxh32(input: bytes | None = None, seed: int | None = None) -&gt; Xxh32: ...
def xxh64(input: bytes | None = None, seed: int | None = None) -&gt; Xxh64: ...
def xxh3(
    input: bytes | None = None,
    seed: int | None = None,
    secret: bytes | None = None,
) -&gt; Xxh3: ...


# xxh32
def xxh32_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh32_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh32_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh64
def xxh64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh128
def xxh128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh3
def xxh3_64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh3_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...


# xxh128
def xxh3_128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...

</code></pre>
<!-- API-END -->
<hr />
<h2 id="dev"><a class="header" href="#dev">DEV</a></h2>
<ul>
<li><code>just</code> is used to run tasks</li>
<li>Do not use the phrase <code>blazing fast</code> or any emojis in any PRs or issues or
docs</li>
<li>type annotations are required</li>
<li><code>ruff</code> used for formatting and linting</li>
</ul>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<ul>
<li>utiles (web-map tile utils): https://github.com/jessekrubin/utiles</li>
<li>jsonc2json (jsonc to json converter):
https://github.com/jessekrubin/jsonc2json</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">DEVELOPMENT</a></h1>
<p><strong>OPEN TO PRS!</strong></p>
<h2 id="goals"><a class="header" href="#goals">goals</a></h2>
<ol>
<li>Provide a really nice ergonomic API to work with (this is the highest priority)</li>
<li>Get naming right (this is a hard one!)</li>
<li>Be fast</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">development-setup</a></h2>
<ul>
<li>clone repo</li>
<li>install <code>just</code> (<code>cargo install just</code>)</li>
<li>create a virtual env (using ye olde <code>venv</code> or <code>uv</code> or dare I say <code>conda</code>) – I am still working out the kinks of using <code>uv</code> with maturin</li>
<li>install the dev-requirements (<code>pip install -r requirements.dev.txt</code>)</li>
<li>run <code>just dev</code> to build and test the library</li>
<li>run <code>just fmt</code> to format the python and rust code</li>
</ul>
<h2 id="style-guide"><a class="header" href="#style-guide">style guide</a></h2>
<ul>
<li><strong>NO UNWRAPPING</strong></li>
<li><strong>NO PANICS</strong></li>
<li><strong>NO <code>blazingly-fast</code></strong> – <code>ry</code> is fast and does not need an adverb</li>
<li><strong>USE CLIPPY</strong> <code>just clippy</code> or <code>just ci</code></li>
<li><strong>USE RUSTFMT AND RUFF</strong> <code>just fmt</code></li>
<li>avoid using macros as they are not as easy to reason about and/or debug, but feel free to say ‘yolo’</li>
<li>library style guide:
<ul>
<li>python objects/structs/classes defined in the library should be named either <code>Py&lt;CLASSNAME&gt;</code> or <code>Ry&lt;CLASSNAME&gt;</code> and
the prefix should be consistent throughout the library (eg <code>ryo3-jiff</code> uses <code>Ry</code> as the internal prefix to not
conflict with the <code>Py&lt;CLASSNAME&gt;</code> structs provided by <code>pyo3</code>)</li>
<li>if a <code>pyclass</code> or <code>pyfunction</code> is not mirroring a rust function prefer names that are puns but also
semi-descriptive (eg <code>Globsters</code> in <code>ryo3-globset</code>)</li>
<li>attempt to mirror the structure of the og library as much as possible</li>
<li>wrapper libraries should be of the form <code>ryo3-&lt;LIB_NAME&gt;</code> where <code>&lt;LIB_NAME&gt;</code> is the name of the library they</li>
<li>library directories should be <code>kebab-case</code> and should be <code>ryo3-&lt;LIB_NAME&gt;</code></li>
<li>MUST PROVIDE TYPE ANNOTATIONS</li>
</ul>
</li>
</ul>
<h2 id="creating-a-new-librarywrapper-thing"><a class="header" href="#creating-a-new-librarywrapper-thing">Creating a new library/wrapper-thing</a></h2>
<ul>
<li>copy the template library  <code>ryo3-quick-maths</code> library to your new library name</li>
<li>refer to the above style guide for naming conventions</li>
</ul>
<h2 id="tools"><a class="header" href="#tools">tools</a></h2>
<h3 id="python"><a class="header" href="#python">python</a></h3>
<ul>
<li>we use <code>maturin</code> for building the python wheels</li>
<li>we support <code>python-3.9+</code></li>
<li>we use <code>pytest</code> for testing as well as the following plugins:
<ul>
<li><code>pytest-benchmark</code></li>
<li><code>pytest-asyncio</code> (may switch to <code>anyio</code> in the future)</li>
<li><code>hypothesis</code></li>
</ul>
</li>
</ul>
<h3 id="just"><a class="header" href="#just">just</a></h3>
<p><strong><code>cargo install just</code></strong></p>
<ul>
<li>we use <code>just</code> for task running</li>
<li>to see all tasks run <code>just</code> or <code>just --list</code> (our default task echos the list of tasks)</li>
</ul>
<p>tasks as of 2024-12-03:</p>
<pre><code class="language-aiignore">Available recipes:
    dev            # dev run build + tests
    develop        # maturin develop
    cargo-test     # cargo test
    build          # build
    build-release  # build release
    dev-rel        # maturin develop release
    pytest         # run pytest
    pytestv        # run pytest (printing captured output)
    test           # run all test
    test-release   # test ry package
    bench          # benchmark ry python package
    ci             # ci rust checks
    cargo-fmt      # cargo format
    cargo-fmtc     # cargo format check
    sort-all-check # ruff check sorting of '__all__'
    sort-all       # ruff sort '__all__'
    ruff-fmt       # ruff format
    ruff-fmtc      # ruff format check
    black          # python format black
    fmtpy          # python format
    fmtcpy         # python format check
    justfilefmt    # justfile format
    justfilefmtc   # justfile format check
    fmt            # format
    fmtc           # format check
    ruff           # run ruff linter
    ruffix         # run ruff + fix
    clippy         # run clippy
    lint           # lint python and rust
    mypy           # run mypy type checker
    pyright        # run pyright
    pip-compile    # pip compile requirements
    gen            # generate code tasks
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>This project would not be possible without the incredible work of many others.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">THANK YOU</a></h2>
<ul>
<li>pyo3 developers</li>
<li>all authors of all libraries used in this project!</li>
<li>burnt-sushi for his incredible set of libraries</li>
</ul>
<hr />
<p>If you want to be added to this list, please open an issue or PR! Happy to add you if you’ve helped in any way!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">CHANGELOG</a></h1>
<h2 id="v0031-2025-02-21"><a class="header" href="#v0031-2025-02-21">v0.0.31 [2025-02-21]</a></h2>
<ul>
<li><code>ryo3-core</code>
<ul>
<li>got rid of <code>ryo3-types</code> and moved into <code>ryo3-core</code></li>
</ul>
</li>
<li><code>ryo3-tokio</code>
<ul>
<li><code>read_async</code> and <code>write_async</code> async functions</li>
</ul>
</li>
<li><code>ryo3-which</code>
<ul>
<li><code>which_re</code> functions accepts <code>ry.Regex</code> or <code>str</code> now</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li><code>read</code> and <code>write</code> functions which take/return <code>ry.Bytes</code> objects</li>
</ul>
</li>
<li><code>internal</code>
<ul>
<li>Changed many many many of the structs/classes to be pyo3 <code>frozen</code> behaviour should not be different</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0030-2025-02-18"><a class="header" href="#v0030-2025-02-18">v0.0.30 [2025-02-18]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Upgraded jiff to version 2</li>
</ul>
</li>
<li>internal
<ul>
<li>Switch all lints from <code>#[allow(...)]</code>/<code>#![allow(...)]</code> to <code>#[expect(...)]</code>/<code>#![expect(...)]</code></li>
<li>Removed a bunch o commented out code</li>
</ul>
</li>
<li><code>ryo3-std</code>
<ul>
<li>added several <code>std::fs</code> structs</li>
</ul>
</li>
<li><code>ryo3-fspath</code>
<ul>
<li>conversion to <code>pathlib.Path</code> by way of <code>FsPath.to_pathlib()</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0029-2025-02-03"><a class="header" href="#v0029-2025-02-03">v0.0.29 [2025-02-03]</a></h2>
<ul>
<li>internal
<ul>
<li>Made sure each <code>ryo3-*</code> crate has a <code>README.md</code></li>
</ul>
</li>
<li><code>ryo3-bytes</code> &amp; <code>ryo3-fspath</code>
<ul>
<li>added <code>__hash__</code> dunders to both <code>Bytes</code> and <code>FsPath</code> structs</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0028-2025-01-31"><a class="header" href="#v0028-2025-01-31">v0.0.28 [2025-01-31]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Per Mr. Sushi’s thoughts changed all <code>until</code>/<code>since</code> methods to use kwargs instead of the rust-like tuples that impl
<code>From</code>/<code>Into</code> as it does not translate well to python</li>
<li>Gets rid of the following inane types:</li>
</ul>
</li>
</ul>
<pre><code class="language-python">IntoDateDifference = (
  DateDifference
  | Date
  | DateTime
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Date]
  | tuple[JIFF_UNIT_STRING, DateTime]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimeDifference = (
  TimeDifference
  | Time
  | DateTime
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Time]
  | tuple[JIFF_UNIT_STRING, DateTime]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoDateTimeDifference = (
  DateTimeDifference
  | Date
  | Time
  | DateTime
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Date]
  | tuple[JIFF_UNIT_STRING, Time]
  | tuple[JIFF_UNIT_STRING, DateTime]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
IntoTimestampDifference = (
  TimestampDifference
  | Timestamp
  | ZonedDateTime
  | tuple[JIFF_UNIT_STRING, Timestamp]
  | tuple[JIFF_UNIT_STRING, ZonedDateTime]
)
</code></pre>
<hr />
<h2 id="v0027-2025-01-23"><a class="header" href="#v0027-2025-01-23">v0.0.27 [2025-01-23]</a></h2>
<ul>
<li><code>ry</code>
<ul>
<li>Warning on <code>debug</code> build</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>headers-property response returns <code>Headers</code> object instead of python dict</li>
</ul>
</li>
<li><code>same-file</code>
<ul>
<li>wrapper module added with <code>is_same_file</code> py-fn (yet another piece of burnt sushi)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>jiff-version <code>0.1.25</code> ~ add <code>in_tz</code> methods and point old <code>intz</code> at new <code>in_tz</code> methods and raise
<code>DeprecationWarning</code> for old <code>intz</code> methods</li>
<li>Continued adding implementations that previously raised <code>NotImplementedError</code>
<ul>
<li><code>Date.nth_weekday_of_month</code></li>
<li><code>Date.nth_weekday</code></li>
<li><code>DateTime.nth_weekday_of_month</code></li>
<li><code>DateTime.nth_weekday</code></li>
<li><code>TimeSpan.compare</code></li>
<li><code>TimeSpan.total</code></li>
<li><code>ZonedDateTime.nth_weekday_of_month</code></li>
<li><code>ZonedDateTime.nth_weekday</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0026-2025-01-13"><a class="header" href="#v0026-2025-01-13">v0.0.26 [2025-01-13]</a></h2>
<ul>
<li><code>reqwest</code>
<ul>
<li><code>AsyncClient</code> renamed to <code>HttpClient</code></li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>human timespan strings for <code>TimeSpan</code> and <code>SignedDuration</code> objects:
<ul>
<li><code>ry.TimeSpan.parse("P2M10DT2H30M").string(human=True) == "2mo 10d 2h 30m"</code></li>
<li><code>ry.SignedDuration.parse("PT2H30M").string(human=True) == "2h 30m"</code></li>
</ul>
</li>
</ul>
</li>
<li>internal
<ul>
<li>workspace-ified all the deps</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0025-2024-01-07-25-for-2025"><a class="header" href="#v0025-2024-01-07-25-for-2025">v0.0.25 [2024-01-07] (25 for 2025)</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Updated to <code>0.1.21</code> which has span and signed duration strings with capital letters</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0024-2024-12-24-the-night-b4-xmas"><a class="header" href="#v0024-2024-12-24-the-night-b4-xmas">v0.0.24 [2024-12-24] (the night b4 xmas…)</a></h2>
<ul>
<li><code>http</code>
<ul>
<li>basic headers struct/obj – WIP</li>
</ul>
</li>
<li><code>reqwest</code>
<ul>
<li>reqwest client (currently root-export)</li>
<li>default client + root <code>fetch</code> function likely needs work…</li>
<li>response <code>byte_stream</code>!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0023-2024-12-19"><a class="header" href="#v0023-2024-12-19">v0.0.23 [2024-12-19]</a></h2>
<ul>
<li><code>python -m ry.dev</code> repl for ipython/python repl ~ handy nifty secret tool makes it into repo</li>
<li>internal
<ul>
<li>in process of renaming all python-rust <code>#[new]</code> functions to be named <code>fn py_new(...)</code></li>
</ul>
</li>
<li><code>unindent</code>
<ul>
<li>Added <code>unindent</code> module for unindenting strings will move to <code>ryo3-unindent</code></li>
</ul>
</li>
<li><code>FsPath</code>
<ul>
<li>creeping ever closer to being a full-fledged pathlib.Path replacement</li>
<li>Added bindings to all rust <code>std::path::Path(buf)</code> methods for <code>FsPath</code></li>
</ul>
</li>
<li>sub-packaging
<ul>
<li><code>xxhash</code> is own sub package now <code>ry.xxhash</code></li>
<li><code>JSON</code> is own subpackage right now – named <code>ry.JSON</code> to avoid conflict with <code>json</code> module but maybe will change…</li>
<li>food-for-thought-ing how <code>ryo3</code> and <code>ry</code> should be organized w/ respsect to sub-packages and where that organization
should be</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>required to break up the type annotations due to migration to sub-packages</li>
<li>breaking up the type annotations file into smaller files under <code>&lt;REPO&gt;/python/ry/ryo3/*.pyi</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0022-2024-12-16"><a class="header" href="#v0022-2024-12-16">v0.0.22 [2024-12-16]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Super simple regex wrapper (must to do here, but was added for <code>ryo3-which::which_re</code>)</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li><code>until</code>/<code>since</code>
<ul>
<li>Basic <code>until</code>/<code>since</code> implementation but I do not like them and they confusingly named <code>*Difference</code>
structs/py-objects, so I may change how they work…</li>
</ul>
</li>
<li><code>jiff</code> seems to be about as performant as <code>whenever</code> ~ yay! also the whenever dude appears to be watching this
repo (as of 2024-12-16)</li>
</ul>
</li>
<li><code>walkdir</code>
<ul>
<li><code>collect</code> added to <code>WalkdirGen</code> to collect the results into a list</li>
</ul>
</li>
<li>deps
<ul>
<li><code>thiserror</code> version <code>2.0.7</code> -&gt; <code>2.0.8</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0021-2024-12-13-friday-the-13th-spoogidy-oogidity"><a class="header" href="#v0021-2024-12-13-friday-the-13th-spoogidy-oogidity">v0.0.21 [2024-12-13] (friday the 13th… spoogidy oogidity)</a></h2>
<ul>
<li><code>walkdir</code>
<ul>
<li>add <code>glob</code> kwarg that takes a <code>ry.Glob</code> or <code>ry.GlobSet</code> or <code>ry.Globster</code> obj to filter the walk on</li>
</ul>
</li>
<li><code>globset</code>
<ul>
<li>Internal refactoring</li>
<li>added <code>globster()</code> method to <code>ry.Glob</code> and <code>ry.GlobSet</code> to return a <code>ry.Globster</code> obj</li>
<li>added <code>globset()</code> method to <code>ry.Glob</code> to return a <code>ry.GlobSet</code> obj from a <code>ry.Glob</code> obj</li>
</ul>
</li>
<li><code>url</code>
<ul>
<li>python <code>Url</code> changed name <code>URL</code>; aligns with jawascript and other python libs</li>
</ul>
</li>
<li><code>bzip2</code>
<ul>
<li>update to v5</li>
</ul>
</li>
<li><code>jiff</code>
<ul>
<li>conversions for jiff-round-mode/unit/weekday</li>
<li>not-implemented placeholders and new impls
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDateTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyDate</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyOffset</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySignedDuration</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RySpan</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTimeZone</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyTime</code></li>
<li><input disabled="" type="checkbox" checked=""/>
<code>RyZoned</code></li>
</ul>
</li>
<li>span builder functions use form <code>s._hours(1)</code> for panic-inducing building, and <code>s.try_hours(1)</code> for
non-panic-inducing building</li>
</ul>
</li>
<li>type-annotations
<ul>
<li>fixes and updates and a hacky script I wrote to check for discrepancies</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0020-2024-12-10"><a class="header" href="#v0020-2024-12-10">v0.0.20 [2024-12-10]</a></h2>
<ul>
<li><code>regex</code>
<ul>
<li>Templated out regex package but nothing added</li>
</ul>
</li>
<li><code>ry</code>
<ul>
<li>python 3.13 yay!</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated jiter version thanks depbot!</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0019-2024-12-05"><a class="header" href="#v0019-2024-12-05">v0.0.19 [2024-12-05]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>py-conversions
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDateTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffDate</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffOffset</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSignedDuration</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffSpan</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTimeZone</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffTime</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>JiffZoned</code>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
FromPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject</li>
<li><input disabled="" type="checkbox" checked=""/>
IntoPyObject (REF)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0018-2024-12-03"><a class="header" href="#v0018-2024-12-03">v0.0.18 [2024-12-03]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li>Renamed <code>ry.Span</code> to <code>ry.TimeSpan</code></li>
<li>Renamed <code>ry.Zoned</code> to <code>ry.ZonedDateTime</code></li>
<li>Updated type stubs to reflect renames</li>
</ul>
</li>
<li>docs
<ul>
<li>init-ed the docs</li>
<li>style guide under <code>DEVELOPMENT.md</code> file</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0017-2024-12-02"><a class="header" href="#v0017-2024-12-02">v0.0.17 [2024-12-02]</a></h2>
<ul>
<li><code>jiff</code>
<ul>
<li><code>ry.TimeZone</code> testing and to/from <code>datetime.tzinfo</code> conversions</li>
<li>Using nu-types for <code>jiff</code> intermediate types bc of the classic orphans problem (aka batman) w/ traits</li>
<li>hypothesis tests</li>
</ul>
</li>
<li><code>jiter</code>
<ul>
<li>Updated to <code>jiter</code> v0.8.1</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0016-2024-11-29"><a class="header" href="#v0016-2024-11-29">v0.0.16 [2024-11-29]</a></h2>
<ul>
<li>Moved walkdir to <code>ryo3-walkdir</code></li>
<li>added <code>ryo3-types</code> for custom and shared types</li>
<li><code>heck</code> wrapper(s)</li>
<li>jiff
<ul>
<li>Added operators <code>+</code>/<code>+=</code>/<code>-</code>/<code>-=</code> to date/time/datetime/etc</li>
<li>TODO: figure out how to take refs in the union enum for the operators</li>
</ul>
</li>
<li>fspath
<ul>
<li>further beefing out as well as testing</li>
</ul>
</li>
</ul>
<hr />
<h2 id="v0015-2024-11-20"><a class="header" href="#v0015-2024-11-20">v0.0.15 [2024-11-20]</a></h2>
<ul>
<li><code>from __future__ import annotations</code> added to all modules</li>
<li>cicd updated to include more targets</li>
</ul>
<hr />
<h2 id="v0014-2024-11-20"><a class="header" href="#v0014-2024-11-20">v0.0.14 [2024-11-20]</a></h2>
<ul>
<li>Primitive/crude wrappers around Mr. Sushi’s <code>jiff</code> library</li>
<li>Updated to use pyo3 (had to use jiter git repo dep)</li>
<li><code>ry.FsPath</code> beefed out</li>
<li>Added iterdir gen wrapper</li>
<li>(todo undo when jiter + pyo3 23 is public)</li>
</ul>
<hr />
<h2 id="v0013-2024-11-20"><a class="header" href="#v0013-2024-11-20">v0.0.13 [2024-11-20]</a></h2>
<ul>
<li><strong>VERSION SKIPPED DUE TO <code>13</code> BEING SPOOKY AND ME BEING MODERATELY-STITCHOUS (AKA fully ‘superstitchous’)</strong></li>
</ul>
<hr />
<h2 id="v0012-2024-11-14"><a class="header" href="#v0012-2024-11-14">v0.0.12 [2024-11-14]</a></h2>
<ul>
<li>sqlformat wrapper(s) (this is the first <code>ryo3-*</code> sub-crate)</li>
</ul>
<hr />
<h2 id="v0011-2024-09-22"><a class="header" href="#v0011-2024-09-22">v0.0.11 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
<li>prepare for python 3.13</li>
</ul>
<hr />
<h2 id="v0010-2024-09-22"><a class="header" href="#v0010-2024-09-22">v0.0.10 [2024-09-22]</a></h2>
<ul>
<li>dependencies updated</li>
</ul>
<hr />
<h2 id="v009-2024-08-22"><a class="header" href="#v009-2024-08-22">v0.0.9 [2024-08-22]</a></h2>
<ul>
<li>Added <code>globset</code> wrapper(s)</li>
<li>Added <code>__init__.py</code> generator</li>
</ul>
<hr />
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<h2 id="v008-2024-06-25"><a class="header" href="#v008-2024-06-25">v0.0.8 [2024-06-25]</a></h2>
<ul>
<li>Upgraded to pyo3-v0.22</li>
</ul>
<hr />
<h2 id="v007-2024-06-08"><a class="header" href="#v007-2024-06-08">v0.0.7 [2024-06-08]</a></h2>
<ul>
<li>internal refactoring</li>
</ul>
<hr />
<h2 id="v006-2024-06-05"><a class="header" href="#v006-2024-06-05">v0.0.6 [2024-06-05]</a></h2>
<ul>
<li>Added zstd (<code>zstd_encode</code>/<code>zstd</code> and <code>zstd_decode</code>)</li>
<li>Added gzip (<code>gzip_encode</code>/<code>gzip</code> and <code>gzip_decode</code>/<code>gunzip</code>)</li>
<li>Added bzip2 (<code>bzip2_encode</code>/<code>bzip2</code> and <code>bzip2_decode</code>)</li>
<li>Added walkdir</li>
<li>Reorg libs</li>
</ul>
<hr />
<h2 id="v005-2024-04-19"><a class="header" href="#v005-2024-04-19">v0.0.5 [2024-04-19]</a></h2>
<ul>
<li>Added brotli (<code>brotli_encode</code> and <code>brotli_decode</code>)</li>
<li>xxhash
<ul>
<li>const functions</li>
<li>hasher streaming objects</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p><strong>TODO: Add examples</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<h2 id="ry__init__-1"><a class="header" href="#ry__init__-1"><code>ry.__init__</code></a></h2>
<pre><code class="language-python">"""ry api ~ type annotations"""

import datetime as pydt
import typing as t
from os import PathLike
from pathlib import Path

import typing_extensions as te

from ry._types import Buffer

from . import http as http
from ._bytes import Bytes as Bytes
from ._jiff import Date as Date
from ._jiff import DateDifference as DateDifference
from ._jiff import DateTime as DateTime
from ._jiff import DateTimeDifference as DateTimeDifference
from ._jiff import DateTimeRound as DateTimeRound
from ._jiff import ISOWeekDate as ISOWeekDate
from ._jiff import Offset as Offset
from ._jiff import SignedDuration as SignedDuration
from ._jiff import Time as Time
from ._jiff import TimeDifference as TimeDifference
from ._jiff import TimeSpan as TimeSpan
from ._jiff import Timestamp as Timestamp
from ._jiff import TimestampDifference as TimestampDifference
from ._jiff import TimestampRound as TimestampRound
from ._jiff import TimeZone as TimeZone
from ._jiff import ZonedDateTime as ZonedDateTime
from ._jiff import ZonedDateTimeDifference as ZonedDateTimeDifference
from ._jiff import ZonedDateTimeRound as ZonedDateTimeRound
from ._jiff import date as date
from ._jiff import datetime as datetime
from ._jiff import offset as offset
from ._jiff import time as time
from ._jiff import timespan as timespan
from ._size import SizeFormatter as SizeFormatter
from ._size import fmt_size as fmt_size
from ._size import parse_size as parse_size
from ._url import URL as URL
from .http import Headers as Headers
from .http import HttpStatus as HttpStatus
from .reqwest import HttpClient as HttpClient
from .reqwest import ReqwestError as ReqwestError
from .reqwest import Response as Response
from .reqwest import ResponseStream as ResponseStream
from .reqwest import fetch as fetch
from .tokio import read_async as read_async
from .tokio import write_async as write_async

__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str

# =============================================================================
# TYPE ALIASES
# =============================================================================
JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)

# =============================================================================
# STD
# =============================================================================


# -----------------------------------------------------------------------------
# STD::TIME
# -----------------------------------------------------------------------------
class Duration:
    ZERO: Duration
    MIN: Duration
    MAX: Duration
    NANOSECOND: Duration
    MICROSECOND: Duration
    MILLISECOND: Duration
    SECOND: Duration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Duration) -&gt; bool: ...
    def __le__(self, other: Duration) -&gt; bool: ...
    def __gt__(self, other: Duration) -&gt; bool: ...
    def __ge__(self, other: Duration) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(
        self, other: Duration | pydt.timedelta, op: int
    ) -&gt; bool: ...
    def __str__(self) -&gt; str: ...
    def abs_diff(self, other: Duration) -&gt; Duration: ...
    def sleep(self) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[Duration], td: pydt.timedelta
    ) -&gt; Duration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; Duration: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; Duration: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; Duration: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; Duration: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; Duration: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; Duration: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; Duration: ...
    @classmethod
    def from_days(cls, days: int) -&gt; Duration: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; Duration: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Duration | None: ...
    def checked_div(self, other: Duration) -&gt; Duration | None: ...
    def checked_mul(self, other: Duration) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Duration | None: ...
    def div_duration_f32(self, other: Duration) -&gt; float: ...
    def div_duration_f64(self, other: Duration) -&gt; float: ...
    def div_f32(self, other: float) -&gt; Duration: ...
    def div_f64(self, other: float) -&gt; Duration: ...
    def mul_f32(self, other: float) -&gt; Duration: ...
    def mul_f64(self, other: float) -&gt; Duration: ...
    def saturating_add(self, other: Duration) -&gt; Duration: ...
    def saturating_mul(self, other: Duration) -&gt; Duration: ...
    def saturating_sub(self, other: Duration) -&gt; Duration: ...


class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; Instant: ...
    def __iadd__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; Instant: ...
    @t.overload
    def __sub__(self, other: Instant) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; Instant | None: ...
    def checked_duration_since(self, earlier: Instant) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; Instant | None: ...
    def duration_since(self, earlier: Instant) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: Instant) -&gt; Duration: ...


def instant() -&gt; Instant: ...


# -----------------------------------------------------------------------------
# STD::FS
# -----------------------------------------------------------------------------
class FileType:
    def __repr__(self) -&gt; str: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...


class Metadata:
    def __repr__(self) -&gt; str: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def len(self) -&gt; int: ...
    @property
    def is_empty(self) -&gt; bool: ...
    @property
    def modified(self) -&gt; pydt.datetime: ...
    @property
    def accessed(self) -&gt; pydt.datetime: ...
    @property
    def created(self) -&gt; pydt.datetime: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...


# =============================================================================
# RY03-CORE
# =============================================================================


class FsPath:
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __truediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def to_pathlib(self) -&gt; Path: ...
    def read_text(self) -&gt; str: ...
    def read_bytes(self) -&gt; bytes: ...
    def absolute(self) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def write_text(self, data: str) -&gt; None: ...
    def write_bytes(self, data: bytes) -&gt; None: ...
    def joinpath(self, *paths: str) -&gt; FsPath: ...
    def exists(self) -&gt; bool: ...
    def with_name(self, name: str) -&gt; FsPath: ...
    def with_suffix(self, suffix: str) -&gt; FsPath: ...
    def iterdir(self) -&gt; t.Iterator[FsPath]: ...
    def relative_to(self, other: PathLike[str] | str | FsPath) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...

    # TODO
    def __bytes__(self) -&gt; bytes: ...
    def as_uri(self) -&gt; str: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def string(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; FsPath: ...
    @classmethod
    def home(cls) -&gt; FsPath: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; FsPath: ...
    @property
    def parents(self) -&gt; t.Sequence[FsPath]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; str: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf
    # =========================================================================
    def _pop(self) -&gt; FsPath: ...
    def _push(self, path: PathLike[str] | str) -&gt; FsPath: ...
    def _set_extension(self, ext: str) -&gt; FsPath: ...
    def _set_file_name(self, name: str) -&gt; FsPath: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; t.Iterator[FsPath]: ...
    def canonicalize(self) -&gt; FsPath: ...
    def components(self) -&gt; t.Iterator[FsPath]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; FsPath: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, path: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, prefix: PathLike[str] | str) -&gt; FsPath: ...
    def with_extension(self, ext: str) -&gt; FsPath: ...
    def with_file_name(self, name: str) -&gt; FsPath: ...


FsPathLike = str | FsPath | PathLike[str]


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: FsPathLike) -&gt; None: ...
@t.overload
def ls(
    path: FsPathLike | None = None,
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[False] = False,
) -&gt; list[str]:
    """List directory contents - returns list of strings"""


@t.overload
def ls(
    path: FsPathLike | None = None,
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[True] = True,
) -&gt; list[FsPath]:
    """List directory contents - returns list of FsPath objects"""


def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """


# =============================================================================
# SLEEP
# =============================================================================
def sleep(seconds: float) -&gt; float: ...
async def sleep_async(seconds: float) -&gt; float: ...
async def asleep(seconds: float) -&gt; float:
    """Alias for sleep_async"""
    ...


# =============================================================================
# FILESYSTEM
# =============================================================================
def read(path: FsPathLike) -&gt; Bytes: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def read_text(path: FsPathLike) -&gt; str: ...
def write(path: FsPathLike, data: Buffer | str) -&gt; None: ...
def write_bytes(path: FsPathLike, data: bytes) -&gt; None: ...
def write_text(path: FsPathLike, data: str) -&gt; None: ...


# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------
# |~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~ LIBS ~|~|
# -----------------------------------------------------------------------------
# \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
# -----------------------------------------------------------------------------

# =============================================================================
# Regex
# =============================================================================


class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: str | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def is_match(self, string: str) -&gt; bool: ...


# =============================================================================
# WHICH
# =============================================================================
def which(cmd: str, path: None | str = None) -&gt; str | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[str]: ...
def which_re(regex: str | Regex, path: None | str = None) -&gt; list[str]: ...


# =============================================================================
# HECK
# =============================================================================


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...


# =============================================================================
# GLOBSET
# =============================================================================
class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def regex(self) -&gt; str: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def globster(self) -&gt; Globster: ...


class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool | None = None,
        literal_separator: bool | None = None,
        backslash_escape: bool | None = None,
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: FsPathLike) -&gt; bool: ...
    def __call__(self, path: FsPathLike) -&gt; bool: ...
    def __invert__(self) -&gt; GlobSet: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def glob(
    pattern: str,
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Glob: ...
def globster(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool | None = None,
    literal_separator: bool | None = None,
    backslash_escape: bool | None = None,
) -&gt; Globster: ...


# =============================================================================
# WALKDIR
# =============================================================================
class WalkDirEntry:
    def __fspath__(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    @property
    def path(self) -&gt; FsPath: ...
    @property
    def file_name(self) -&gt; str: ...
    @property
    def depth(self) -&gt; int: ...
    @property
    def path_is_symlink(self) -&gt; bool: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def len(self) -&gt; int: ...


class WalkdirGen:
    """walkdir::Walkdir iterable wrapper"""

    files: bool
    dirs: bool

    def __next__(self) -&gt; str: ...
    def __iter__(self) -&gt; t.Iterator[str]: ...
    def collect(self) -&gt; list[str]: ...


def walkdir(
    path: FsPathLike | None = None,
    *,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    same_file_system: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
) -&gt; WalkdirGen: ...


# =============================================================================
# SAME_FILE
# =============================================================================


def is_same_file(a: PathLike[str], b: PathLike[str]) -&gt; bool: ...


# =============================================================================
# SHLEX
# =============================================================================
def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""
    ...


# =============================================================================
# JSON
# =============================================================================


class JsonParseKwargs(t.TypedDict, total=False):
    allow_inf_nan: bool
    """Allow parsing of `Infinity`, `-Infinity`, `NaN` ~ default: True"""
    cache_mode: t.Literal[True, False, "all", "keys", "none"]
    """Cache mode for JSON parsing ~ default: `all` """
    partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"]
    """Partial mode for JSON parsing ~ default: False"""
    catch_duplicate_keys: bool
    """Catch duplicate keys in JSON objects ~ default: False"""
    float_mode: t.Literal["float", "decimal", "lossless-float"] | bool
    """Mode for parsing JSON floats ~ default: False"""


def parse_json(
    data: bytes | str,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    **kwargs: te.Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...


# =============================================================================
# FORMATTING
# =============================================================================
def unindent(string: str) -&gt; str: ...
def unindent_bytes(string: bytes) -&gt; bytes: ...


# =============================================================================
# FNV
# =============================================================================
class FnvHasher:
    name: t.Literal["fnv1a"]

    def __init__(self, input: bytes | None = None) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; FnvHasher: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def fnv1a(input: bytes) -&gt; FnvHasher: ...


# =============================================================================
# BROTLI
# =============================================================================
def brotli_encode(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(input: bytes) -&gt; bytes: ...
def brotli(
    input: bytes, quality: int = 11, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""


# =============================================================================
# BZIP2
# =============================================================================
def bzip2_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def bzip2_decode(input: bytes) -&gt; bytes: ...
def bzip2(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for bzip2_encode"""


# =============================================================================
# GZIP
# =============================================================================
def gzip_encode(input: bytes, quality: int = 9) -&gt; bytes: ...
def gzip_decode(input: bytes) -&gt; bytes: ...
def gzip(input: bytes, quality: int = 9) -&gt; bytes:
    """Alias for gzip_encode"""


def gunzip(input: bytes) -&gt; bytes:
    """Alias for gzip_decode"""


# =============================================================================
# ZSTD
# =============================================================================
def zstd_encode(input: bytes, level: int = 3) -&gt; bytes: ...
def zstd(input: bytes, level: int = 3) -&gt; bytes:
    """Alias for zstd_encode"""


def zstd_decode(input: bytes) -&gt; bytes: ...


# =============================================================================
# SQLFORMAT
# =============================================================================
SqlfmtParamValue = str | int | float | bool
TSqlfmtParamValue_co = t.TypeVar(
    "TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike = (
    dict[str, TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, TSqlfmtParamValue_co]]
    | t.Sequence[TSqlfmtParamValue_co]
)


class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[TSqlfmtParamValue_co] | SqlfmtQueryParams,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int = 2,  # -1 or any negative value will use tabs
    uppercase: bool | None = True,
    lines_between_statements: int = 1,
) -&gt; str: ...

</code></pre>
<h2 id="ryjson-1"><a class="header" href="#ryjson-1"><code>ry.JSON</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.JSON"""

from typing import Literal

JsonPrimitive = None | bool | int | float | str
JsonValue = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


def parse_json(
    data: bytes | str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_bytes(
    data: bytes,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def parse_json_str(
    data: str,
    /,
    *,
    allow_inf_nan: bool = True,
    cache_mode: Literal[True, False, "all", "keys", "none"] = "all",
    partial_mode: Literal[True, False, "off", "on", "trailing-strings"] = False,
    catch_duplicate_keys: bool = False,
    float_mode: Literal["float", "decimal", "lossless-float"] | bool = False,
) -&gt; JsonValue: ...
def jiter_cache_clear() -&gt; None: ...
def jiter_cache_usage() -&gt; int: ...

</code></pre>
<h2 id="ry_bytes-1"><a class="header" href="#ry_bytes-1"><code>ry._bytes</code></a></h2>
<pre><code class="language-python">import sys
from typing import overload

if sys.version_info &gt;= (3, 12):
    from collections.abc import Buffer as Buffer
else:
    from typing_extensions import Buffer as Buffer


class Bytes(Buffer):
    """
    A buffer implementing the Python buffer protocol, allowing zero-copy access
    to underlying Rust memory.

    You can pass this to `memoryview` for a zero-copy view into the underlying
    data or to `bytes` to copy the underlying data into a Python `bytes`.

    Many methods from the Python `bytes` class are implemented on this,
    """

    def __init__(self, buf: Buffer = b"") -&gt; None:
        """Construct a new Bytes object.

        This will be a zero-copy view on the Python byte slice.
        """

    def __add__(self, other: Buffer) -&gt; Bytes: ...
    def __buffer__(self, flags: int) -&gt; memoryview[int]: ...
    def __contains__(self, other: Buffer) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @overload
    def __getitem__(self, other: int) -&gt; int: ...
    @overload
    def __getitem__(self, other: slice) -&gt; Bytes: ...
    def __mul__(self, other: Buffer) -&gt; int: ...
    def __len__(self) -&gt; int: ...
    def __repr__(self) -&gt; str: ...
    def removeprefix(self, prefix: Buffer, /) -&gt; Bytes:
        """
        If the binary data starts with the prefix string, return `bytes[len(prefix):]`.
        Otherwise, return the original binary data.
        """

    def removesuffix(self, suffix: Buffer, /) -&gt; Bytes:
        """
        If the binary data ends with the suffix string and that suffix is not empty,
        return `bytes[:-len(suffix)]`. Otherwise, return the original binary data.
        """

    def isalnum(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetical ASCII characters or
        ASCII decimal digits and the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal digits
        are those byte values in the sequence `b'0123456789'`.
        """

    def isalpha(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetic ASCII characters and
        the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
        """

    def isascii(self) -&gt; bool:
        """
        Return `True` if the sequence is empty or all bytes in the sequence are ASCII,
        `False` otherwise.

        ASCII bytes are in the range `0-0x7F`.
        """

    def isdigit(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII decimal digits and the
        sequence is not empty, `False` otherwise.

        ASCII decimal digits are those byte values in the sequence `b'0123456789'`.
        """

    def islower(self) -&gt; bool:
        """
        Return `True` if there is at least one lowercase ASCII character in the sequence
        and no uppercase ASCII characters, `False` otherwise.
        """

    def isspace(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII whitespace and the sequence
        is not empty, `False` otherwise.

        ASCII whitespace characters are those byte values
        in the sequence `b' \t\n\r\x0b\f'` (space, tab, newline, carriage return,
        vertical tab, form feed).
        """

    def isupper(self) -&gt; bool:
        """
        Return `True` if there is at least one uppercase alphabetic ASCII character in
        the sequence and no lowercase ASCII characters, `False` otherwise.
        """

    def lower(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the uppercase ASCII characters converted
        to their corresponding lowercase counterpart.
        """

    def upper(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the lowercase ASCII characters converted
        to their corresponding uppercase counterpart.
        """

    def to_bytes(self) -&gt; bytes:
        """Copy this buffer's contents into a Python `bytes` object."""

    # =========================================================================
    # IMPL IN RY
    # =========================================================================

    def decode(self, encoding: str = "utf-8", errors: str = "strict") -&gt; str:
        """Decode the binary data using the given encoding."""

    def hex(
        self, sep: str | None = None, bytes_per_sep: int | None = None
    ) -&gt; str:
        """Return a hexadecimal representation of the binary data."""

    @classmethod
    def fromhex(cls, hexstr: str) -&gt; Bytes:
        """Construct a `Bytes` object from a hexadecimal string."""


BytesLike = Buffer | bytes | bytearray | memoryview | Bytes

</code></pre>
<h2 id="ry_dev-1"><a class="header" href="#ry_dev-1"><code>ry._dev</code></a></h2>
<pre><code class="language-python">"""ry.ryo3.dev"""

from __future__ import annotations

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...

</code></pre>
<h2 id="ry_jiff-1"><a class="header" href="#ry_jiff-1"><code>ry._jiff</code></a></h2>
<pre><code class="language-python">"""jiff types"""

import datetime as pydt
import typing as t

import typing_extensions as te

from ry._types import (
    DateTimeTypedDict,
    DateTypedDict,
    TimeSpanTypedDict,
    TimeTypedDict,
)
from ry.ryo3 import Duration

# =============================================================================
# JIFF
# =============================================================================
JIFF_UNIT = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JIFF_ROUND_MODE = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half_ceil",
    "half_floor",
    "half_expand",
    "half_trunc",
    "half_even",
]

WEEKDAY = t.Literal[
    "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
]

JIFF_WEEKDAY_INT = t.Literal[
    1,  # Monday
    2,  # Tuesday
    3,  # Wednesday
    4,  # Thursday
    5,  # Friday
    6,  # Saturday
    7,  # Sunday
]


class Date:
    MIN: Date
    MAX: Date
    ZERO: Date

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls: type[Date], date: pydt.date) -&gt; Date: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(
        cls: type[Date], year: int, week: int, weekday: int
    ) -&gt; Date: ...
    @classmethod
    def today(cls: type[Date]) -&gt; Date: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls: type[Date], format: str, string: str) -&gt; Date: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...
    @t.overload
    def __isub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int
    ) -&gt; DateTime: ...
    def asdict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: Date) -&gt; Date: ...
    def duration_until(self, other: Date) -&gt; Date: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; Date: ...
    def first_of_year(self) -&gt; Date: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; Date: ...
    def last_of_year(self) -&gt; Date: ...
    def nth_weekday(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def nth_weekday_of_month(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Date]: ...
    def to_datetime(self, time: Time) -&gt; DateTime: ...
    def tomorrow(self) -&gt; Date: ...
    def yesterday(self) -&gt; Date: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Date: ...


class DateDifference:
    def __init__(
        self,
        date: Date,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; DateDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; DateDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateDifference: ...
    def increment(self, increment: int) -&gt; DateDifference: ...


class Time:
    MIN: Time
    MAX: Time

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    def __iadd__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...
    @t.overload
    def __isub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(self, other: TimeSpan | SignedDuration | Duration) -&gt; Time: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls: type[Time], format: str, string: str) -&gt; Time: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls: type[Time], t: pydt.time) -&gt; Time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def now(cls: type[Time]) -&gt; Time: ...
    @classmethod
    def parse(cls: type[Time], s: str) -&gt; Time: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; None: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def asdict(self) -&gt; TimeTypedDict: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Time]: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    @t.overload
    def checked_sub(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Time: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; Time: ...
    def to_datetime(self, d: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class TimeDifference:
    def __init__(
        self,
        date: Time,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; TimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; TimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimeDifference: ...
    def increment(self, increment: int) -&gt; TimeDifference: ...


class DateTime:
    MIN: DateTime
    MAX: DateTime
    ZERO: DateTime

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls: type[DateTime], format: str, string: str) -&gt; DateTime: ...
    @classmethod
    def parse(cls: type[DateTime], s: str) -&gt; DateTime: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls: type[DateTime], dt: pydt.datetime) -&gt; DateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls: type[DateTime]) -&gt; DateTime: ...
    @classmethod
    def from_parts(cls: type[DateTime], date: Date, time: Time) -&gt; DateTime: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __repr__(self) -&gt; str: ...
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __sub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def __isub__(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime: ...
    def iso_week_date(self) -&gt; tuple[int, int, int]: ...
    def date(self) -&gt; Date: ...
    def time(self) -&gt; Time: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[DateTime]: ...
    def asdict(self) -&gt; DateTimeTypedDict: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        *,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; DateTime: ...
    def _round(self, options: DateTimeRound) -&gt; DateTime: ...
    def yesterday(self) -&gt; DateTime: ...

    # =========================================================================
    # INSTANCE METHODS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def checked_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...
    @t.overload
    def saturating_sub(self, other: DateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; DateTime: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # NOT IMPLEMENTED &amp; NOT TYPED
    # =========================================================================
    def first_of_month(self) -&gt; DateTime: ...
    def first_of_year(self) -&gt; DateTime: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def duration_since(self, other: DateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: DateTime) -&gt; SignedDuration: ...
    def in_leap_year(self) -&gt; bool: ...
    def end_of_day(self) -&gt; DateTime: ...
    def nth_weekday(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; DateTime: ...
    def nth_weekday_of_month(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; DateTime: ...
    def last_of_month(self) -&gt; DateTime: ...
    def last_of_year(self) -&gt; DateTime: ...
    def start_of_day(self) -&gt; DateTime: ...
    def tomorrow(self) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | Time | DateTime | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class DateTimeDifference:
    def __init__(
        self,
        date: DateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; DateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; DateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeDifference: ...
    def increment(self, increment: int) -&gt; DateTimeDifference: ...


class TimeZone:
    def __init__(self, name: str) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    @classmethod
    def from_pytzinfo(cls: type[TimeZone], tz: pydt.tzinfo) -&gt; TimeZone: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls: type[TimeZone], offset: Offset) -&gt; TimeZone: ...
    @classmethod
    def get(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def posix(cls: type[TimeZone], name: str) -&gt; TimeZone: ...
    @classmethod
    def system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def try_system(cls: type[TimeZone]) -&gt; TimeZone: ...
    @classmethod
    def tzif(cls: type[TimeZone], name: str, data: bytes) -&gt; TimeZone: ...
    @classmethod
    def utc(cls: type[TimeZone]) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, dt: Timestamp) -&gt; DateTime: ...
    def to_offset(self, timestamp: Timestamp) -&gt; Offset: ...
    def to_timestamp(self, dt: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, other: DateTime) -&gt; ZonedDateTime: ...

    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


class SignedDuration:
    MIN: SignedDuration
    MAX: SignedDuration
    ZERO: SignedDuration

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __mul__(self, other: int) -&gt; SignedDuration: ...
    def __rmul__(self, other: int) -&gt; SignedDuration: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; SignedDuration: ...
    def __add__(self, other: SignedDuration) -&gt; SignedDuration: ...
    def __abs__(self) -&gt; SignedDuration: ...
    def __div__(self, other: int) -&gt; SignedDuration: ...
    def abs(self) -&gt; SignedDuration: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(
        self, other: SignedDuration | pydt.timedelta, op: int
    ) -&gt; bool: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self, human: bool = False) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(
        cls: type[SignedDuration], td: pydt.timedelta
    ) -&gt; SignedDuration: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls: type[SignedDuration], s: str) -&gt; SignedDuration: ...
    @classmethod
    def from_hours(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_micros(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_millis(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_mins(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_nanos(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs(cls: type[SignedDuration], n: int) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f32(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...
    @classmethod
    def try_from_secs_f64(
        cls: type[SignedDuration], n: float
    ) -&gt; SignedDuration: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def checked_div(self, other: int) -&gt; SignedDuration | None: ...
    def checked_mul(self, other: int) -&gt; SignedDuration | None: ...
    def checked_neg(self) -&gt; SignedDuration | None: ...
    def checked_sub(self, other: SignedDuration) -&gt; SignedDuration | None: ...
    def div_duration_f32(self, other: SignedDuration) -&gt; float: ...
    def div_duration_f64(self, other: SignedDuration) -&gt; float: ...
    def div_f32(self, other: int) -&gt; float: ...
    def div_f64(self, other: int) -&gt; float: ...
    def is_positive(self) -&gt; bool: ...
    def mul_f32(self, other: int) -&gt; SignedDuration: ...
    def mul_f64(self, other: int) -&gt; SignedDuration: ...
    def saturating_add(self, other: SignedDuration) -&gt; SignedDuration: ...
    def saturating_mul(self, other: int) -&gt; SignedDuration: ...
    def saturating_sub(self, other: SignedDuration) -&gt; SignedDuration: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def subsec_micros(self) -&gt; int: ...
    def subsec_millis(self) -&gt; int: ...
    def subsec_nanos(self) -&gt; int: ...
    def to_timespan(self) -&gt; TimeSpan: ...


# put in quotes to avoid ruff F821 - undefined name
_TimeSpanArithmeticSingle = TimeSpan | Duration | SignedDuration
_TimeSpanArithmeticTuple = tuple[
    _TimeSpanArithmeticSingle, ZonedDateTime | Date | DateTime
]
TimeSpanArithmetic = _TimeSpanArithmeticSingle | _TimeSpanArithmeticTuple


class TimeSpan:
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self, human: bool = False) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, td: pydt.timedelta) -&gt; TimeSpan: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def parse(cls, s: str) -&gt; TimeSpan: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; te.Self: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; te.Self: ...
    def __mul__(self, other: int) -&gt; te.Self: ...
    def __neg__(self) -&gt; te.Self: ...
    def __abs__(self) -&gt; te.Self: ...
    def __invert__(self) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: TimeSpan) -&gt; bool: ...
    def __gt__(self, other: TimeSpan) -&gt; bool: ...
    def __le__(self, other: TimeSpan) -&gt; bool: ...
    def __lt__(self, other: TimeSpan) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: TimeSpan) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; te.Self: ...
    def asdict(self) -&gt; TimeSpanTypedDict: ...
    def checked_add(self, val: TimeSpanArithmetic) -&gt; te.Self: ...
    def checked_mul(self, other: int) -&gt; te.Self: ...
    def checked_sub(self, val: TimeSpanArithmetic) -&gt; te.Self: ...
    def compare(
        self,
        other: TimeSpan,
        relative: ZonedDateTime | DateTime | Date | None = None,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def negate(self) -&gt; te.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; te.Self: ...
    def round(
        self,
        smallest: JIFF_UNIT,
        increment: int = 1,
        *,
        relative: ZonedDateTime | Date | DateTime | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
    ) -&gt; te.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self, relative: ZonedDateTime | Date | DateTime
    ) -&gt; SignedDuration: ...
    def total(
        self,
        unit: JIFF_UNIT,
        relative: ZonedDateTime | Date | DateTime | None = None,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def total_seconds(self) -&gt; int: ...
    def try_years(self, years: int) -&gt; te.Self: ...
    def try_months(self, months: int) -&gt; te.Self: ...
    def try_weeks(self, weeks: int) -&gt; te.Self: ...
    def try_days(self, days: int) -&gt; te.Self: ...
    def try_hours(self, hours: int) -&gt; te.Self: ...
    def try_minutes(self, minutes: int) -&gt; te.Self: ...
    def try_seconds(self, seconds: int) -&gt; te.Self: ...
    def try_milliseconds(self, milliseconds: int) -&gt; te.Self: ...
    def try_microseconds(self, microseconds: int) -&gt; te.Self: ...
    def try_nanoseconds(self, nanoseconds: int) -&gt; te.Self: ...

    # -------------------------------------------------------------------------
    # PANIC-INDUCING METHODS
    # -------------------------------------------------------------------------
    def _years(self, years: int) -&gt; te.Self: ...
    def _months(self, months: int) -&gt; te.Self: ...
    def _weeks(self, weeks: int) -&gt; te.Self: ...
    def _days(self, days: int) -&gt; te.Self: ...
    def _hours(self, hours: int) -&gt; te.Self: ...
    def _minutes(self, minutes: int) -&gt; te.Self: ...
    def _seconds(self, seconds: int) -&gt; te.Self: ...
    def _milliseconds(self, milliseconds: int) -&gt; te.Self: ...
    def _microseconds(self, microseconds: int) -&gt; te.Self: ...
    def _nanoseconds(self, nanoseconds: int) -&gt; te.Self: ...


class Timestamp:
    """
    A representation of a timestamp with second and nanosecond precision.
    """

    MIN: Timestamp
    MAX: Timestamp
    UNIX_EPOCH: Timestamp

    def __init__(
        self, second: int | None = None, nanosecond: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; Timestamp: ...
    @classmethod
    def parse(cls, s: str) -&gt; Timestamp: ...
    @classmethod
    def from_millisecond(cls, millisecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_microsecond(cls, microsecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_nanosecond(cls, nanosecond: int) -&gt; Timestamp: ...
    @classmethod
    def from_second(cls, second: int) -&gt; Timestamp: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: Timestamp) -&gt; bool: ...
    def __gt__(self, other: Timestamp) -&gt; bool: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __le__(self, other: Timestamp) -&gt; bool: ...
    def __lt__(self, other: Timestamp) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: Timestamp, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def __sub__(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    def strftime(self, format: str) -&gt; str: ...
    @classmethod
    def strptime(cls, format: str, input: str) -&gt; Timestamp: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...
    def as_second(self) -&gt; int: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    @t.overload
    def checked_sub(self, other: Timestamp) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def display_with_offset(self, offset: Offset) -&gt; str: ...
    def in_tz(self, tz: str) -&gt; ZonedDateTime: ...
    def intz(self, tz: str) -&gt; ZonedDateTime:
        """Deprecated ~ use `in_tz`"""

    def is_zero(self) -&gt; bool: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; Timestamp: ...
    def series(self, span: TimeSpan) -&gt; t.Iterator[Timestamp]: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def string(self) -&gt; str: ...
    def subsec_microsecond(self) -&gt; int: ...
    def subsec_millisecond(self) -&gt; int: ...
    def subsec_nanosecond(self) -&gt; int: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def duration_since(self, other: Timestamp) -&gt; SignedDuration: ...
    def duration_until(self, other: Timestamp) -&gt; SignedDuration: ...
    def round(
        self,
        unit: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; Timestamp: ...
    def _round(self, options: TimestampRound) -&gt; Timestamp: ...


class TimestampDifference:
    def __init__(
        self,
        date: Timestamp,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; TimestampDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; TimestampDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimestampDifference: ...
    def increment(self, increment: int) -&gt; TimestampDifference: ...


class ZonedDateTime:
    def __init__(self, timestamp: Timestamp, time_zone: TimeZone) -&gt; None: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(
        cls: type[ZonedDateTime], dt: pydt.datetime
    ) -&gt; ZonedDateTime: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(
        cls: type[ZonedDateTime], tz: str | None = None
    ) -&gt; ZonedDateTime: ...
    @classmethod
    def utcnow(cls: type[ZonedDateTime]) -&gt; ZonedDateTime: ...
    @classmethod
    def parse(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...
    @classmethod
    def from_rfc2822(cls: type[ZonedDateTime], s: str) -&gt; ZonedDateTime: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(
        cls: type[ZonedDateTime], format: str, input: str
    ) -&gt; ZonedDateTime: ...
    def strftime(self, format: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: ZonedDateTime) -&gt; bool: ...
    def __gt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __iadd__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def __le__(self, other: ZonedDateTime) -&gt; bool: ...
    def __lt__(self, other: ZonedDateTime) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: ZonedDateTime, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __isub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __isub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def __sub__(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; ZonedDateTime: ...
    def checked_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def checked_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def checked_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def duration_until(self, other: ZonedDateTime) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; ZonedDateTime: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; ZonedDateTime: ...
    def first_of_year(self) -&gt; ZonedDateTime: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: str) -&gt; te.Self: ...
    def intz(self, tz: str) -&gt; te.Self: ...
    def inutc(self) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; ZonedDateTime: ...
    def last_of_year(self) -&gt; ZonedDateTime: ...
    def nth_weekday(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def nth_weekday_of_month(
        self, nth: int, weekday: WEEKDAY | JIFF_WEEKDAY_INT
    ) -&gt; Date: ...
    def offset(self) -&gt; Offset: ...
    def round(
        self,
        smallest: JIFF_UNIT | None = None,
        *,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; DateTime: ...
    def _round(self, options: ZonedDateTimeRound) -&gt; DateTime: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    @t.overload
    def saturating_sub(self, other: ZonedDateTime) -&gt; TimeSpan: ...
    @t.overload
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration
    ) -&gt; te.Self: ...
    def start_of_day(self) -&gt; ZonedDateTime: ...
    def time(self) -&gt; Time: ...
    def time_zone(self) -&gt; TimeZone: ...
    def timestamp(self) -&gt; Timestamp: ...
    def timezone(self) -&gt; TimeZone: ...
    def to_rfc2822(self) -&gt; str: ...
    def tomorrow(self) -&gt; ZonedDateTime: ...
    def with_time_zone(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def yesterday(self) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self,
        other: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; TimeSpan: ...


class ZonedDateTimeDifference:
    def __init__(
        self,
        date: ZonedDateTime,
        *,
        smallest: JIFF_UNIT | None = None,
        largest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def smallest(self, unit: JIFF_UNIT) -&gt; ZonedDateTimeDifference: ...
    def largest(self, unit: JIFF_UNIT) -&gt; ZonedDateTimeDifference: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; ZonedDateTimeDifference: ...
    def increment(self, increment: int) -&gt; ZonedDateTimeDifference: ...


class ISOWeekDate:
    MIN: ISOWeekDate
    MAX: ISOWeekDate
    ZERO: ISOWeekDate

    def __init__(
        self, year: int, week: int, weekday: JIFF_WEEKDAY_INT | WEEKDAY
    ) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================

    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __le__(self, other: ISOWeekDate) -&gt; bool: ...
    def __gt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __ge__(self, other: ISOWeekDate) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_date(cls: type[ISOWeekDate], date: Date) -&gt; ISOWeekDate: ...
    @classmethod
    def today(cls: type[ISOWeekDate]) -&gt; ISOWeekDate: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def week(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; JIFF_WEEKDAY_INT: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...


class TimestampRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; TimestampRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; TimestampRound: ...
    def increment(self, increment: int) -&gt; TimestampRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; TimestampRound: ...


class DateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class ZonedDateTimeRound:
    def __init__(
        self,
        smallest: JIFF_UNIT | None = None,
        mode: JIFF_ROUND_MODE | None = None,
        increment: int = 1,
    ) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def mode(self, mode: JIFF_ROUND_MODE) -&gt; DateTimeRound: ...
    def smallest(self, smallest: JIFF_UNIT) -&gt; DateTimeRound: ...
    def increment(self, increment: int) -&gt; DateTimeRound: ...
    def _smallest(self) -&gt; JIFF_UNIT: ...
    def _mode(self) -&gt; JIFF_ROUND_MODE: ...
    def _increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: JIFF_UNIT | None,
        mode: JIFF_ROUND_MODE | None,
        increment: int | None,
    ) -&gt; DateTimeRound: ...


class Offset:
    MIN: Offset
    MAX: Offset
    UTC: Offset
    ZERO: Offset

    def __init__(
        self, hours: int | None = None, seconds: int | None = None
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def string(self) -&gt; str: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; Offset: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls: type[Offset]) -&gt; Offset: ...
    @classmethod
    def from_hours(cls: type[Offset], hours: int) -&gt; Offset: ...
    @classmethod
    def from_seconds(cls: type[Offset], seconds: int) -&gt; Offset: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def checked_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def negate(self) -&gt; Offset: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan
    ) -&gt; Offset: ...
    def since(self, other: Offset) -&gt; TimeSpan: ...
    def until(self, other: Offset) -&gt; TimeSpan: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
    unchecked: bool = False,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...

</code></pre>
<h2 id="ry_size-1"><a class="header" href="#ry_size-1"><code>ry._size</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

from typing import Literal

FORMAT_SIZE_BASE = Literal[2, 10]  # default=2
FORMAT_SIZE_STYLE = Literal[  # default="default"
    "default",
    "abbreviated",
    "abbreviated_lowercase",
    "abbreviated-lowercase",
    "full",
    "full-lowercase",
    "full_lowercase",
]


def fmt_size(
    n: int,
    *,
    base: FORMAT_SIZE_BASE | None = 2,
    style: FORMAT_SIZE_STYLE | None = "default",
) -&gt; str:
    """Return human-readable string representation of bytes-size."""


def parse_size(s: str) -&gt; int:
    """Return integer representation of human-readable bytes-size string.

    Raises:
        ValueError: If string is not a valid human-readable bytes-size string.
    """


class SizeFormatter:
    """Human-readable bytes-size formatter."""

    def __init__(
        self,
        base: FORMAT_SIZE_BASE | None = 2,
        style: FORMAT_SIZE_STYLE | None = "default",
    ):
        self.base = base
        self.style = style

    def format(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __call__(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __repr__(self) -&gt; str: ...

</code></pre>
<h2 id="ry_url-1"><a class="header" href="#ry_url-1"><code>ry._url</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

from ipaddress import IPv4Address


class URL:
    def __init__(
        self, url: str | URL, *, params: dict[str, str] | None = None
    ) -&gt; None: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, url: str) -&gt; URL: ...
    @classmethod
    def parse_with_params(cls, url: str, params: dict[str, str]) -&gt; URL: ...
    @classmethod
    def from_directory_path(cls, path: str) -&gt; URL: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: URL) -&gt; bool: ...
    def __gt__(self, other: URL) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: URL) -&gt; bool: ...
    def __lt__(self, other: URL) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rtruediv__(self, relative: str) -&gt; URL: ...
    def __truediv__(self, relative: str) -&gt; URL: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None: ...
    @property
    def port_or_known_default(self) -&gt; int | None: ...
    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_pairs(self) -&gt; list[tuple[str, str]]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def username(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def to_filepath(self) -&gt; str: ...
    def replace_fragment(self, fragment: str | None = None) -&gt; URL: ...
    def replace_host(self, host: str | None = None) -&gt; URL: ...
    def replace_ip_host(self, host: IPv4Address | IPv4Address) -&gt; URL: ...
    def replace_password(self, password: str | None = None) -&gt; URL: ...
    def replace_path(self, path: str) -&gt; URL: ...
    def replace_port(self, port: int | None = None) -&gt; URL: ...
    def replace_query(self, query: str | None = None) -&gt; URL: ...
    def replace_scheme(self, scheme: str) -&gt; URL: ...
    def replace_username(self, username: str) -&gt; URL: ...
    def socket_addrs(self) -&gt; None: ...

</code></pre>
<h2 id="rydirs-1"><a class="header" href="#rydirs-1"><code>ry.dirs</code></a></h2>
<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...

</code></pre>
<h2 id="ryhttp-1"><a class="header" href="#ryhttp-1"><code>ry.http</code></a></h2>
<pre><code class="language-python">class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(self, headers: dict[str, str]) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: str) -&gt; str: ...
    def __setitem__(self, key: str, value: str) -&gt; None: ...
    def __delitem__(self, key: str) -&gt; None: ...
    def __contains__(self, key: str) -&gt; bool: ...
    def __or__(self, other: Headers | dict[str, str]) -&gt; Headers: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def append(self, key: str, value: str) -&gt; None: ...
    def get(self, key: str) -&gt; str | None: ...
    def get_all(self, key: str) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def remove(self, key: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def pop(self, key: str) -&gt; str: ...
    def keys(self) -&gt; list[str]: ...
    def update(self, headers: Headers | dict[str, str]) -&gt; None: ...


class HttpStatus:
    def __init__(self, code: int) -&gt; None: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: HttpStatus | int) -&gt; bool: ...
    def __le__(self, other: HttpStatus | int) -&gt; bool: ...
    def __gt__(self, other: HttpStatus | int) -&gt; bool: ...
    def __ge__(self, other: HttpStatus | int) -&gt; bool: ...
    def reason(self) -&gt; str: ...
    def is_informational(self) -&gt; bool: ...
    def is_success(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_client_error(self) -&gt; bool: ...
    def is_server_error(self) -&gt; bool: ...
    def is_ok(self) -&gt; bool: ...
    @property
    def ok(self) -&gt; bool: ...

    # =========================================================================
    # CONST STATUS CODES
    # =========================================================================
    CONTINUE: HttpStatus  # 100 ~ Continue
    SWITCHING_PROTOCOLS: HttpStatus  # 101 ~ Switching Protocols
    PROCESSING: HttpStatus  # 102 ~ Processing
    OK: HttpStatus  # 200 ~ OK
    CREATED: HttpStatus  # 201 ~ Created
    ACCEPTED: HttpStatus  # 202 ~ Accepted
    NON_AUTHORITATIVE_INFORMATION: (
        HttpStatus  # 203 ~ Non Authoritative Information
    )
    NO_CONTENT: HttpStatus  # 204 ~ No Content
    RESET_CONTENT: HttpStatus  # 205 ~ Reset Content
    PARTIAL_CONTENT: HttpStatus  # 206 ~ Partial Content
    MULTI_STATUS: HttpStatus  # 207 ~ Multi-Status
    ALREADY_REPORTED: HttpStatus  # 208 ~ Already Reported
    IM_USED: HttpStatus  # 226 ~ IM Used
    MULTIPLE_CHOICES: HttpStatus  # 300 ~ Multiple Choices
    MOVED_PERMANENTLY: HttpStatus  # 301 ~ Moved Permanently
    FOUND: HttpStatus  # 302 ~ Found
    SEE_OTHER: HttpStatus  # 303 ~ See Other
    NOT_MODIFIED: HttpStatus  # 304 ~ Not Modified
    USE_PROXY: HttpStatus  # 305 ~ Use Proxy
    TEMPORARY_REDIRECT: HttpStatus  # 307 ~ Temporary Redirect
    PERMANENT_REDIRECT: HttpStatus  # 308 ~ Permanent Redirect
    BAD_REQUEST: HttpStatus  # 400 ~ Bad Request
    UNAUTHORIZED: HttpStatus  # 401 ~ Unauthorized
    PAYMENT_REQUIRED: HttpStatus  # 402 ~ Payment Required
    FORBIDDEN: HttpStatus  # 403 ~ Forbidden
    NOT_FOUND: HttpStatus  # 404 ~ Not Found
    METHOD_NOT_ALLOWED: HttpStatus  # 405 ~ Method Not Allowed
    NOT_ACCEPTABLE: HttpStatus  # 406 ~ Not Acceptable
    PROXY_AUTHENTICATION_REQUIRED: (
        HttpStatus  # 407 ~ Proxy Authentication Required
    )
    REQUEST_TIMEOUT: HttpStatus  # 408 ~ Request Timeout
    CONFLICT: HttpStatus  # 409 ~ Conflict
    GONE: HttpStatus  # 410 ~ Gone
    LENGTH_REQUIRED: HttpStatus  # 411 ~ Length Required
    PRECONDITION_FAILED: HttpStatus  # 412 ~ Precondition Failed
    PAYLOAD_TOO_LARGE: HttpStatus  # 413 ~ Payload Too Large
    URI_TOO_LONG: HttpStatus  # 414 ~ URI Too Long
    UNSUPPORTED_MEDIA_TYPE: HttpStatus  # 415 ~ Unsupported Media Type
    RANGE_NOT_SATISFIABLE: HttpStatus  # 416 ~ Range Not Satisfiable
    EXPECTATION_FAILED: HttpStatus  # 417 ~ Expectation Failed
    IM_A_TEAPOT: HttpStatus  # 418 ~ I'm a teapot
    MISDIRECTED_REQUEST: HttpStatus  # 421 ~ Misdirected Request
    UNPROCESSABLE_ENTITY: HttpStatus  # 422 ~ Unprocessable Entity
    LOCKED: HttpStatus  # 423 ~ Locked
    FAILED_DEPENDENCY: HttpStatus  # 424 ~ Failed Dependency
    TOO_EARLY: HttpStatus  # 425 ~ Too Early
    UPGRADE_REQUIRED: HttpStatus  # 426 ~ Upgrade Required
    PRECONDITION_REQUIRED: HttpStatus  # 428 ~ Precondition Required
    TOO_MANY_REQUESTS: HttpStatus  # 429 ~ Too Many Requests
    REQUEST_HEADER_FIELDS_TOO_LARGE: (
        HttpStatus  # 431 ~ Request Header Fields Too Large
    )
    UNAVAILABLE_FOR_LEGAL_REASONS: (
        HttpStatus  # 451 ~ Unavailable For Legal Reasons
    )
    INTERNAL_SERVER_ERROR: HttpStatus  # 500 ~ Internal Server Error
    NOT_IMPLEMENTED: HttpStatus  # 501 ~ Not Implemented
    BAD_GATEWAY: HttpStatus  # 502 ~ Bad Gateway
    SERVICE_UNAVAILABLE: HttpStatus  # 503 ~ Service Unavailable
    GATEWAY_TIMEOUT: HttpStatus  # 504 ~ Gateway Timeout
    HTTP_VERSION_NOT_SUPPORTED: HttpStatus  # 505 ~ HTTP Version Not Supported
    VARIANT_ALSO_NEGOTIATES: HttpStatus  # 506 ~ Variant Also Negotiates
    INSUFFICIENT_STORAGE: HttpStatus  # 507 ~ Insufficient Storage
    LOOP_DETECTED: HttpStatus  # 508 ~ Loop Detected
    NOT_EXTENDED: HttpStatus  # 510 ~ Not Extended
    NETWORK_AUTHENTICATION_REQUIRED: (
        HttpStatus  # 511 ~ Network Authentication Required
    )

</code></pre>
<h2 id="ryreqwest-1"><a class="header" href="#ryreqwest-1"><code>ry.reqwest</code></a></h2>
<pre><code class="language-python">import typing as t
from http import HTTPStatus

import ry

if t.TYPE_CHECKING:
    from ry import Duration, Headers
    from ry.ryo3._url import URL


class HttpClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | None = None,
        user_agent: str | None = None,  # default ~ 'ry-reqwest/&lt;VERSION&gt; ...'
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
    ) -&gt; None: ...
    async def get(
        self, url: str | URL, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def post(
        self,
        url: str | URL,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def put(
        self,
        url: str | URL,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def delete(
        self, url: str | URL, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def patch(
        self,
        url: str | URL,
        *,
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...
    async def head(
        self, url: str | URL, *, headers: dict[str, str] | None = None
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: str | URL,
        *,
        method: str = "GET",
        body: bytes | None = None,
        headers: dict[str, str] | None = None,
    ) -&gt; Response: ...


class ReqwestError(Exception):
    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def __dbg__(self) -&gt; str: ...
    def is_body(self) -&gt; bool: ...
    def is_builder(self) -&gt; bool: ...
    def is_connect(self) -&gt; bool: ...
    def is_decode(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_request(self) -&gt; bool: ...
    def is_status(self) -&gt; bool: ...
    def is_timeout(self) -&gt; bool: ...
    def status(self) -&gt; HTTPStatus | None: ...
    def url(self) -&gt; URL | None: ...


class Response:
    status_code: int

    @property
    def headers(self) -&gt; Headers: ...
    async def text(self) -&gt; str: ...
    async def json(self) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(self) -&gt; ResponseStream: ...


class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...


async def fetch(
    url: str | URL,
    *,
    client: HttpClient | None = None,
    method: str = "GET",
    body: bytes | None = None,
    headers: dict[str, str] | None = None,
) -&gt; Response: ...

</code></pre>
<h2 id="rytokio-1"><a class="header" href="#rytokio-1"><code>ry.tokio</code></a></h2>
<pre><code class="language-python">from ry import Bytes
from ry._types import Buffer
from ry.ryo3 import FsPathLike


async def read_async(path: FsPathLike) -&gt; Bytes: ...
async def write_async(path: FsPathLike, data: Buffer) -&gt; None: ...

</code></pre>
<h2 id="ryxxhash-1"><a class="header" href="#ryxxhash-1"><code>ry.xxhash</code></a></h2>
<pre><code class="language-python">from __future__ import annotations

import typing as t


@t.final
class Xxh32:
    name: t.Literal["xxh32"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh64:
    name: t.Literal["xxh64"]

    def __init__(self, input: bytes = ..., seed: int | None = ...) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; Xxh32: ...
    def reset(self, seed: int | None = ...) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...


@t.final
class Xxh3:
    name: t.Literal["xxh3"]

    def __init__(
        self,
        input: bytes = ...,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, input: bytes) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def digest128(self) -&gt; bytes: ...
    def hexdigest128(self) -&gt; str: ...
    def intdigest128(self) -&gt; int: ...
    def copy(self) -&gt; Xxh3: ...
    def reset(self) -&gt; None: ...


def xxh32(input: bytes | None = None, seed: int | None = None) -&gt; Xxh32: ...
def xxh64(input: bytes | None = None, seed: int | None = None) -&gt; Xxh64: ...
def xxh3(
    input: bytes | None = None,
    seed: int | None = None,
    secret: bytes | None = None,
) -&gt; Xxh3: ...


# xxh32
def xxh32_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh32_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh32_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh64
def xxh64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh128
def xxh128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...


# xxh3
def xxh3_64_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_64_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_64_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...
def xxh3_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...


# xxh128
def xxh3_128_digest(input: bytes, seed: int | None = None) -&gt; bytes: ...
def xxh3_128_intdigest(input: bytes, seed: int | None = None) -&gt; int: ...
def xxh3_128_hexdigest(input: bytes, seed: int | None = None) -&gt; str: ...

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="food-4-thought"><a class="header" href="#food-4-thought">food-4-thought</a></h1>
<p>thinking out loud…</p>
<hr />
<h1 id="rydev"><a class="header" href="#rydev"><code>ry.dev</code></a></h1>
<p>For people who find <code>ry.dev</code> it is a module that exports all the things in ry as well as can be used as a repl; <code>python -m ry.dev</code> will start a repl (with ipython if installed else python-repl) with all of ry already imported. I use this super often for testing things out.</p>
<hr />
<h2 id="string-bridge"><a class="header" href="#string-bridge">string-bridge?</a></h2>
<p>The <code>jiter</code> crate uses a string-cache to store python-strings to avoid the
overhead of converting strings to python strings. A global string bridge and/or
caching setup for other types of structs that often convert to strings might be
worth considering?</p>
<hr />
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Coming up with names is hard… I want to strike a balance between being clear
but also close to the wrapped libraries…</p>
<ul>
<li>Should jiff’s <code>Zoned</code> be <code>Zoned</code> in python? or <code>ZonedDateTime</code>? (currently <code>ZonedDateTime</code>)</li>
<li>Should jiff’s <code>Span</code> be <code>Span</code> in python? or <code>TimeSpan</code>? (currently <code>TimeSpan</code>)</li>
<li>Should reqwest’s <code>Client</code> be <code>Client</code> in python? or <code>HttpClient</code>? (currently <code>HttpClient</code>)</li>
</ul>
<hr />
<h2 id="flat-nested-submodules"><a class="header" href="#flat-nested-submodules">Flat? Nested submodules?</a></h2>
<p>I like flat more, but nesting submodules might be preferable for some people and would allow for more flexibility in naming…</p>
<p>pros &amp; cons:</p>
<ul>
<li>flat:
<ul>
<li>pros:
<ul>
<li>easier to import</li>
<li>easier to work on</li>
<li>no need to remember where things are</li>
<li>type annotations are easier to setup/dist</li>
</ul>
</li>
<li>cons:
<ul>
<li>name conflicts</li>
<li>type annotations are harder to read bc of huge file</li>
<li>harder to remember where things are</li>
</ul>
</li>
</ul>
</li>
<li>nested:
<ul>
<li>pros:
<ul>
<li>no name conflicts</li>
<li>easier to remember where things are</li>
<li>type annotations are easier to read</li>
<li>importing <code>ry.jiff</code> (or <code>ry.ryo3.jiff</code> tbd) is more explicitly the <code>jiff</code> wrapper(s)</li>
</ul>
</li>
<li>cons:
<ul>
<li>Don’t know how type annotations should be laid out… if there is a submodule called <code>ry.ryo3.reqwest</code>, do you import from <code>ry.ryo3.reqwest</code> or do I reexport from <code>ry.reqwest</code>? Then were doe the type-annotations live and how are they laid out without having to duplicate/shim them?</li>
</ul>
</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
