diff --git c/Cargo.lock w/Cargo.lock
index e013c6b..d185ac2 100644
--- c/Cargo.lock
+++ w/Cargo.lock
@@ -1952,7 +1952,6 @@ dependencies = [
  "flate2",
  "pyo3",
  "ryo3-bytes",
- "ryo3-macro-rules",
 ]
 
 [[package]]
diff --git c/Cargo.toml w/Cargo.toml
index 6311519..913e407 100644
--- c/Cargo.toml
+++ w/Cargo.toml
@@ -113,7 +113,9 @@ members = [
 # ryo3-*
 # ======
 # internal
-ryo3 = { path = "./crates/ryo3", features = [] }
+ryo3 = { path = "./crates/ryo3", features = [
+  "generate-import-lib"
+] }
 # dev/future
 # ryo3-ignore = { path = "./crates/_future/ryo3-ignore" }
 # wrappers
@@ -155,7 +157,7 @@ ryo3-xxhash = { path = "./crates/ryo3-xxhash" }
 ryo3-zstd = { path = "./crates/ryo3-zstd" }
 
 # pyo3
-pyo3 = { version = "0.25.1", features = ["macros", "serde"] }
+pyo3 = { version = "0.25.1", features = ["macros", "serde", ""] }
 # pyo3 async runtimes
 pyo3-async-runtimes = { version = "0.25.0", features = ["tokio-runtime"] }
 pyo3-build-config = "0.25.1"
diff --git c/crates/ryo3-brotli/src/lib.rs w/crates/ryo3-brotli/src/lib.rs
index 7c8d4f4..35616c0 100644
--- c/crates/ryo3-brotli/src/lib.rs
+++ w/crates/ryo3-brotli/src/lib.rs
@@ -25,15 +25,11 @@ fn encode(data: &[u8], quality: Option<u8>, magic_number: Option<bool>) -> PyRes
             ..Default::default()
         };
         let mut encoder = br::CompressorWriter::with_params(Vec::new(), 4 * 1024, &params);
-        encoder.write_all(data).map_err(|e| {
-            PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("Error: {e:?}"))
-        })?;
+        encoder.write_all(data)?;
         encoder.into_inner()
     } else {
         let mut encoder = br::CompressorWriter::new(Vec::new(), 4 * 1024, quality_u8.into(), 22);
-        encoder.write_all(data).map_err(|e| {
-            PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("Error: {e:?}"))
-        })?;
+        encoder.write_all(data)?;
         encoder.into_inner()
     };
     Ok(encoded)
diff --git c/crates/ryo3-bzip2/src/lib.rs w/crates/ryo3-bzip2/src/lib.rs
index a49b335..65a9dd7 100644
--- c/crates/ryo3-bzip2/src/lib.rs
+++ w/crates/ryo3-bzip2/src/lib.rs
@@ -4,28 +4,15 @@ use std::io::{Read, Write};
 use ::bzip2::Compression;
 use ::bzip2::read::BzDecoder;
 use ::bzip2::write::BzEncoder;
+use pyo3::exceptions::PyValueError;
 use pyo3::prelude::PyModule;
 use pyo3::prelude::*;
-use pyo3::types::PyBytes;
+use pyo3::types::{PyBytes, PyInt, PyString};
 
-fn rs_bzip2_encode(py: Python<'_>, data: &[u8], quality: Option<u32>) -> PyResult<PyObject> {
-    let quality = if let Some(param) = quality {
-        if param < Compression::fast().level() || param > Compression::best().level() {
-            return Err(PyErr::new::<pyo3::exceptions::PyValueError, _>(
-                "The optional second argument to bzip2() must be between 0 and 9",
-            ));
-        }
-        Compression::new(param)
-    } else {
-        Compression::default()
-    };
+fn rs_bzip2_encode(py: Python<'_>, data: &[u8], quality: Compression) -> PyResult<PyObject> {
     let mut bzip2_encoder = BzEncoder::new(Vec::new(), quality);
-    bzip2_encoder.write_all(data.as_ref()).map_err(|e| {
-        PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("bzip2-encode-error: {e:?}"))
-    })?;
-    let encoded = bzip2_encoder.finish().map_err(|e| {
-        PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("bzip2-encode-error: {e:?}"))
-    })?;
+    bzip2_encoder.write_all(data.as_ref())?;
+    let encoded = bzip2_encoder.finish()?;
     Ok(PyBytes::new(py, &encoded).into())
 }
 
@@ -35,10 +22,10 @@ fn rs_bzip2_encode(py: Python<'_>, data: &[u8], quality: Option<u32>) -> PyResul
 pub fn bzip2_encode(
     py: Python<'_>,
     data: ryo3_bytes::PyBytes,
-    quality: Option<u32>,
+    quality: Option<PyCompression>,
 ) -> PyResult<PyObject> {
     let data = data.as_ref();
-    rs_bzip2_encode(py, data, quality)
+    rs_bzip2_encode(py, data, quality.unwrap_or_default().0)
 }
 
 #[pyfunction]
@@ -47,10 +34,10 @@ pub fn bzip2_encode(
 pub fn bzip2(
     py: Python<'_>,
     data: ryo3_bytes::PyBytes,
-    quality: Option<u32>,
+    quality: Option<PyCompression>,
 ) -> PyResult<PyObject> {
     let data = data.as_ref();
-    rs_bzip2_encode(py, data, quality)
+    rs_bzip2_encode(py, data, quality.unwrap_or_default().0)
 }
 
 #[pyfunction]
@@ -58,14 +45,39 @@ pub fn bzip2(
 pub fn bzip2_decode(py: Python<'_>, data: ryo3_bytes::PyBytes) -> PyResult<PyObject> {
     let mut decompressed = Vec::new();
     let data: &[u8] = data.as_ref();
-    BzDecoder::new(data)
-        .read_to_end(&mut decompressed)
-        .map_err(|e| {
-            PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("bzip2-decode-error: {e:?}"))
-        })?;
+    BzDecoder::new(data).read_to_end(&mut decompressed)?;
+
     Ok(PyBytes::new(py, &decompressed).into())
 }
 
+#[derive(Copy, Clone, PartialEq, Eq, Debug, Default)]
+pub struct PyCompression(pub(crate) Compression);
+
+impl FromPyObject<'_> for PyCompression {
+    fn extract_bound(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
+        if let Ok(pyint) = ob.downcast::<PyInt>() {
+            let level = pyint.extract::<u32>()?;
+            if level < 10 {
+                return Ok(Self(Compression::new(level)));
+            }
+        } else if let Ok(pystr) = ob.downcast::<PyString>() {
+            let s = pystr.to_str()?;
+            let c = match s {
+                "fast" => Some(Self(Compression::fast())),
+                "default" => Some(Self(Compression::default())),
+                "best" => Some(Self(Compression::best())),
+                _ => None,
+            };
+            if let Some(c) = c {
+                return Ok(c);
+            }
+        }
+        Err(PyValueError::new_err(
+            "Invalid compression level; valid levels are int 0-9 or string 'fast', 'default', 'best'",
+        ))
+    }
+}
+
 pub fn pymod_add(m: &Bound<'_, PyModule>) -> PyResult<()> {
     m.add_function(wrap_pyfunction!(bzip2_decode, m)?)?;
     m.add_function(wrap_pyfunction!(bzip2_encode, m)?)?;
diff --git c/crates/ryo3-flate2/Cargo.toml w/crates/ryo3-flate2/Cargo.toml
index 94390dd..b87b777 100644
--- c/crates/ryo3-flate2/Cargo.toml
+++ w/crates/ryo3-flate2/Cargo.toml
@@ -15,7 +15,6 @@ description = "python + flate2 (https://github.com/rust-lang/flate2-rs)"
 flate2 = { workspace = true }
 pyo3 = { workspace = true, features = [] }
 ryo3-bytes.workspace = true
-ryo3-macro-rules.workspace = true
 
 [lints]
 workspace = true
diff --git c/crates/ryo3-flate2/src/compression.rs w/crates/ryo3-flate2/src/compression.rs
new file mode 100644
index 0000000..559c091
--- /dev/null
+++ w/crates/ryo3-flate2/src/compression.rs
@@ -0,0 +1,31 @@
+use flate2::Compression;
+use pyo3::types::{PyInt, PyString};
+use pyo3::{exceptions::PyValueError, prelude::*};
+
+#[derive(Copy, Clone, PartialEq, Eq, Debug, Default)]
+pub struct PyCompression(pub(crate) Compression);
+
+impl FromPyObject<'_> for PyCompression {
+    fn extract_bound(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
+        if let Ok(pyint) = ob.downcast::<PyInt>() {
+            let level = pyint.extract::<u32>()?;
+            if level < 10 {
+                return Ok(Self(Compression::new(level)));
+            }
+        } else if let Ok(pystr) = ob.downcast::<PyString>() {
+            let s = pystr.to_str()?;
+            let c = match s {
+                "fast" => Some(Self(Compression::fast())),
+                "default" => Some(Self(Compression::default())),
+                "best" => Some(Self(Compression::best())),
+                _ => None,
+            };
+            if let Some(c) = c {
+                return Ok(c);
+            }
+        }
+        Err(PyValueError::new_err(
+            "Invalid compression level; valid levels are int 0-9 or string 'fast', 'default', 'best'",
+        ))
+    }
+}
diff --git c/crates/ryo3-flate2/src/gz.rs w/crates/ryo3-flate2/src/gz.rs
index 461982b..2271366 100644
--- c/crates/ryo3-flate2/src/gz.rs
+++ w/crates/ryo3-flate2/src/gz.rs
@@ -1,23 +1,13 @@
-use flate2::Compression;
 use flate2::bufread::GzDecoder;
 use flate2::write::GzEncoder;
 use pyo3::prelude::*;
 use pyo3::types::PyBytes;
-use ryo3_macro_rules::py_value_error;
 use std::io::{Read, Write};
 
-pub fn rs_gzip_encode(py: Python<'_>, data: &[u8], quality: Option<u32>) -> PyResult<PyObject> {
-    let quality = if let Some(param) = quality {
-        if param > 9 {
-            return Err(py_value_error!(
-                "Quality must be between 0 and 9 - got: {param:?}"
-            ));
-        }
-        Compression::new(param)
-    } else {
-        Compression::default()
-    };
-    let mut gzip_encoder = GzEncoder::new(Vec::new(), quality);
+use crate::compression::PyCompression;
+
+fn rs_gzip_encode(py: Python<'_>, data: &[u8], quality: PyCompression) -> PyResult<PyObject> {
+    let mut gzip_encoder = GzEncoder::new(Vec::new(), quality.0);
     gzip_encoder.write_all(data)?;
     let encoded = gzip_encoder.finish()?;
     Ok(PyBytes::new(py, &encoded).into())
@@ -35,10 +25,10 @@ pub fn rs_gzip_decode(data: &[u8]) -> PyResult<ryo3_bytes::PyBytes> {
 pub fn gzip_encode(
     py: Python<'_>,
     data: ryo3_bytes::PyBytes,
-    quality: Option<u32>,
+    quality: Option<PyCompression>,
 ) -> PyResult<PyObject> {
     let bin: &[u8] = data.as_ref();
-    rs_gzip_encode(py, bin, quality)
+    rs_gzip_encode(py, bin, quality.unwrap_or_default())
 }
 
 #[pyfunction]
@@ -52,9 +42,13 @@ pub fn gzip_decode(data: ryo3_bytes::PyBytes) -> PyResult<ryo3_bytes::PyBytes> {
 #[pyfunction]
 #[pyo3(signature = (data, quality=None))]
 #[expect(clippy::needless_pass_by_value)]
-pub fn gzip(py: Python<'_>, data: ryo3_bytes::PyBytes, quality: Option<u32>) -> PyResult<PyObject> {
-    let data: &[u8] = data.as_ref();
-    rs_gzip_encode(py, data, quality)
+pub fn gzip(
+    py: Python<'_>,
+    data: ryo3_bytes::PyBytes,
+    quality: Option<PyCompression>,
+) -> PyResult<PyObject> {
+    let bin: &[u8] = data.as_ref();
+    rs_gzip_encode(py, bin, quality.unwrap_or_default())
 }
 
 #[pyfunction]
diff --git c/crates/ryo3-flate2/src/lib.rs w/crates/ryo3-flate2/src/lib.rs
index d146669..cb2358a 100644
--- c/crates/ryo3-flate2/src/lib.rs
+++ w/crates/ryo3-flate2/src/lib.rs
@@ -3,6 +3,7 @@ mod gz;
 pub use gz::*;
 use pyo3::prelude::PyModule;
 use pyo3::prelude::*;
+mod compression;
 
 pub fn pymod_add(m: &Bound<'_, PyModule>) -> PyResult<()> {
     m.add_function(wrap_pyfunction!(gzip_encode, m)?)?;
diff --git c/crates/ryo3-unindent/src/lib.rs w/crates/ryo3-unindent/src/lib.rs
index 5c1af96..518d200 100644
--- c/crates/ryo3-unindent/src/lib.rs
+++ w/crates/ryo3-unindent/src/lib.rs
@@ -14,6 +14,7 @@ pub fn unindent_bytes<'py>(py: Python<'py>, input: &[u8]) -> Bound<'py, PyBytes>
     let b = ::unindent::unindent_bytes(input);
     PyBytes::new(py, &b)
 }
+
 pub fn pymod_add(m: &Bound<'_, PyModule>) -> PyResult<()> {
     m.add_function(wrap_pyfunction!(crate::unindent, m)?)?;
     m.add_function(wrap_pyfunction!(crate::unindent_bytes, m)?)?;
diff --git c/tests/flate2/test_gzip.py w/tests/flate2/test_gzip.py
index 4deeaae..9712923 100644
--- c/tests/flate2/test_gzip.py
+++ w/tests/flate2/test_gzip.py
@@ -103,4 +103,7 @@ def test_gzip_quality_value_error() -> None:
     with pytest.raises(ValueError) as e:
         ry.gzip(b"test", quality=10)
     s = str(e.value)
-    assert "Quality must be between 0 and 9 - got: 10" in s
+    assert (
+        "Invalid compression level; valid levels are int 0-9 or string 'fast', 'default', 'best'"
+        in s
+    )
