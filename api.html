<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>API - ry(o3) docs</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-6a101e14.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-1ed5fffe.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">ry(o3) docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/jessekrubin/ry" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/jessekrubin/ry/edit/main/docs/src/api.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="api"><a class="header" href="#api">API</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#ry.ryo3.__init__"><code>ry.ryo3.__init__</code></a></li>
<li><a href="#ry.ryo3.__about__"><code>ry.ryo3.__about__</code></a></li>
<li><a href="#ry.ryo3._aws_lc"><code>ry.ryo3._aws_lc</code></a></li>
<li><a href="#ry.ryo3._brotli"><code>ry.ryo3._brotli</code></a></li>
<li><a href="#ry.ryo3._bytes"><code>ry.ryo3._bytes</code></a></li>
<li><a href="#ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></a></li>
<li><a href="#ry.ryo3._dev"><code>ry.ryo3._dev</code></a></li>
<li><a href="#ry.ryo3._encoding_rs"><code>ry.ryo3._encoding_rs</code></a></li>
<li><a href="#ry.ryo3._flate2"><code>ry.ryo3._flate2</code></a></li>
<li><a href="#ry.ryo3._fnv"><code>ry.ryo3._fnv</code></a></li>
<li><a href="#ry.ryo3._fspath"><code>ry.ryo3._fspath</code></a></li>
<li><a href="#ry.ryo3._glob"><code>ry.ryo3._glob</code></a></li>
<li><a href="#ry.ryo3._globset"><code>ry.ryo3._globset</code></a></li>
<li><a href="#ry.ryo3._heck"><code>ry.ryo3._heck</code></a></li>
<li><a href="#ry.ryo3._http"><code>ry.ryo3._http</code></a></li>
<li><a href="#ry.ryo3._jiff"><code>ry.ryo3._jiff</code></a></li>
<li><a href="#ry.ryo3._jiff_tz"><code>ry.ryo3._jiff_tz</code></a></li>
<li><a href="#ry.ryo3._jiter"><code>ry.ryo3._jiter</code></a></li>
<li><a href="#ry.ryo3._memchr"><code>ry.ryo3._memchr</code></a></li>
<li><a href="#ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></a></li>
<li><a href="#ry.ryo3._regex"><code>ry.ryo3._regex</code></a></li>
<li><a href="#ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></a></li>
<li><a href="#ry.ryo3._same_file"><code>ry.ryo3._same_file</code></a></li>
<li><a href="#ry.ryo3._shlex"><code>ry.ryo3._shlex</code></a></li>
<li><a href="#ry.ryo3._size"><code>ry.ryo3._size</code></a></li>
<li><a href="#ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></a></li>
<li><a href="#ry.ryo3._std"><code>ry.ryo3._std</code></a></li>
<li><a href="#ry.ryo3._std_constants"><code>ry.ryo3._std_constants</code></a></li>
<li><a href="#ry.ryo3._tokio"><code>ry.ryo3._tokio</code></a></li>
<li><a href="#ry.ryo3._unindent"><code>ry.ryo3._unindent</code></a></li>
<li><a href="#ry.ryo3._url"><code>ry.ryo3._url</code></a></li>
<li><a href="#ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></a></li>
<li><a href="#ry.ryo3._which"><code>ry.ryo3._which</code></a></li>
<li><a href="#ry.ryo3._zstd"><code>ry.ryo3._zstd</code></a></li>
<li><a href="#ry.ryo3.dirs"><code>ry.ryo3.dirs</code></a></li>
<li><a href="#ry.ryo3.errors"><code>ry.ryo3.errors</code></a></li>
<li><a href="#ry.ryo3.JSON"><code>ry.ryo3.JSON</code></a></li>
<li><a href="#ry.ryo3.orjson"><code>ry.ryo3.orjson</code></a></li>
<li><a href="#ry.ryo3.sh"><code>ry.ryo3.sh</code></a></li>
<li><a href="#ry.ryo3.ulid"><code>ry.ryo3.ulid</code></a></li>
<li><a href="#ry.ryo3.uuid"><code>ry.ryo3.uuid</code></a></li>
<li><a href="#ry.ryo3.xxhash"><code>ry.ryo3.xxhash</code></a></li>
<li><a href="#ry.ryo3.zstd"><code>ry.ryo3.zstd</code></a></li>
<li><a href="#ry._types"><code>ry._types</code></a></li>
<li><a href="#ry.dirs"><code>ry.dirs</code></a></li>
<li><a href="#ry.JSON"><code>ry.JSON</code></a></li>
<li><a href="#ry.protocols"><code>ry.protocols</code></a></li>
<li><a href="#ry.ulid"><code>ry.ulid</code></a></li>
<li><a href="#ry.uuid"><code>ry.uuid</code></a></li>
<li><a href="#ry.xxhash"><code>ry.xxhash</code></a></li>
<li><a href="#ry.zstd"><code>ry.zstd</code></a></li>
</ul>
<h2 id="ry.ryo3.__init__"><code>ry.ryo3.__init__</code></h2>

<pre><code class="language-python">"""ry api ~ type annotations"""

from ry.ryo3 import JSON as JSON
from ry.ryo3 import ulid as ulid
from ry.ryo3 import uuid as uuid
from ry.ryo3 import xxhash as xxhash
from ry.ryo3 import zstd as zstd
from ry.ryo3.__about__ import __allocator__ as __allocator__
from ry.ryo3.__about__ import __authors__ as __authors__
from ry.ryo3.__about__ import __build_profile__ as __build_profile__
from ry.ryo3.__about__ import __build_timestamp__ as __build_timestamp__
from ry.ryo3.__about__ import __crypto_provider__ as __crypto_provider__
from ry.ryo3.__about__ import __description__ as __description__
from ry.ryo3.__about__ import __opt_level__ as __opt_level__
from ry.ryo3.__about__ import __pkg_name__ as __pkg_name__
from ry.ryo3.__about__ import __target__ as __target__
from ry.ryo3.__about__ import __version__ as __version__
from ry.ryo3._aws_lc import sha1 as sha1
from ry.ryo3._aws_lc import sha3_256 as sha3_256
from ry.ryo3._aws_lc import sha3_384 as sha3_384
from ry.ryo3._aws_lc import sha3_512 as sha3_512
from ry.ryo3._aws_lc import sha224 as sha224
from ry.ryo3._aws_lc import sha256 as sha256
from ry.ryo3._aws_lc import sha384 as sha384
from ry.ryo3._aws_lc import sha512 as sha512
from ry.ryo3._aws_lc import sha512_256 as sha512_256
from ry.ryo3._brotli import brotli as brotli
from ry.ryo3._brotli import brotli_decode as brotli_decode
from ry.ryo3._brotli import brotli_encode as brotli_encode
from ry.ryo3._bytes import Bytes as Bytes
from ry.ryo3._bzip2 import bzip2 as bzip2
from ry.ryo3._bzip2 import bzip2_decode as bzip2_decode
from ry.ryo3._bzip2 import bzip2_encode as bzip2_encode
from ry.ryo3._flate2 import gunzip as gunzip
from ry.ryo3._flate2 import gzip as gzip
from ry.ryo3._flate2 import gzip_decode as gzip_decode
from ry.ryo3._flate2 import gzip_encode as gzip_encode
from ry.ryo3._flate2 import is_gzipped as is_gzipped
from ry.ryo3._fnv import fnv1a as fnv1a
from ry.ryo3._fspath import FsPath as FsPath
from ry.ryo3._glob import GlobPattern as GlobPattern
from ry.ryo3._glob import glob as glob
from ry.ryo3._globset import Glob as Glob
from ry.ryo3._globset import GlobSet as GlobSet
from ry.ryo3._globset import Globster as Globster
from ry.ryo3._globset import globster as globster
from ry.ryo3._heck import camel_case as camel_case
from ry.ryo3._heck import kebab_case as kebab_case
from ry.ryo3._heck import pascal_case as pascal_case
from ry.ryo3._heck import shouty_kebab_case as shouty_kebab_case
from ry.ryo3._heck import shouty_snake_case as shouty_snake_case
from ry.ryo3._heck import snake_case as snake_case
from ry.ryo3._heck import snek_case as snek_case
from ry.ryo3._heck import title_case as title_case
from ry.ryo3._heck import train_case as train_case
from ry.ryo3._http import Headers as Headers
from ry.ryo3._http import HttpStatus as HttpStatus
from ry.ryo3._jiff import Date as Date
from ry.ryo3._jiff import DateDifference as DateDifference
from ry.ryo3._jiff import DateTime as DateTime
from ry.ryo3._jiff import DateTimeDifference as DateTimeDifference
from ry.ryo3._jiff import DateTimeRound as DateTimeRound
from ry.ryo3._jiff import ISOWeekDate as ISOWeekDate
from ry.ryo3._jiff import JiffRoundMode as JiffRoundMode
from ry.ryo3._jiff import JiffUnit as JiffUnit
from ry.ryo3._jiff import Offset as Offset
from ry.ryo3._jiff import OffsetRound as OffsetRound
from ry.ryo3._jiff import SignedDuration as SignedDuration
from ry.ryo3._jiff import SignedDurationRound as SignedDurationRound
from ry.ryo3._jiff import Time as Time
from ry.ryo3._jiff import TimeDifference as TimeDifference
from ry.ryo3._jiff import TimeRound as TimeRound
from ry.ryo3._jiff import TimeSpan as TimeSpan
from ry.ryo3._jiff import Timestamp as Timestamp
from ry.ryo3._jiff import TimestampDifference as TimestampDifference
from ry.ryo3._jiff import TimestampRound as TimestampRound
from ry.ryo3._jiff import TimeZone as TimeZone
from ry.ryo3._jiff import TimeZoneDatabase as TimeZoneDatabase
from ry.ryo3._jiff import Weekday as Weekday
from ry.ryo3._jiff import WeekdayInt as WeekdayInt
from ry.ryo3._jiff import WeekdayStr as WeekdayStr
from ry.ryo3._jiff import ZonedDateTime as ZonedDateTime
from ry.ryo3._jiff import ZonedDateTimeDifference as ZonedDateTimeDifference
from ry.ryo3._jiff import ZonedDateTimeRound as ZonedDateTimeRound
from ry.ryo3._jiff import date as date
from ry.ryo3._jiff import datetime as datetime
from ry.ryo3._jiff import now as now
from ry.ryo3._jiff import offset as offset
from ry.ryo3._jiff import time as time
from ry.ryo3._jiff import timespan as timespan
from ry.ryo3._jiff import utcnow as utcnow
from ry.ryo3._jiff import zoned as zoned
from ry.ryo3._jiter import JsonParseKwargs as JsonParseKwargs
from ry.ryo3._jiter import JsonPrimitive as JsonPrimitive
from ry.ryo3._jiter import JsonValue as JsonValue
from ry.ryo3._jiter import json_cache_clear as json_cache_clear
from ry.ryo3._jiter import json_cache_usage as json_cache_usage
from ry.ryo3._jiter import parse_json as parse_json
from ry.ryo3._jiter import parse_jsonl as parse_jsonl
from ry.ryo3._jiter import read_json as read_json
from ry.ryo3._memchr import memchr as memchr
from ry.ryo3._memchr import memchr2 as memchr2
from ry.ryo3._memchr import memchr3 as memchr3
from ry.ryo3._memchr import memrchr as memrchr
from ry.ryo3._memchr import memrchr2 as memrchr2
from ry.ryo3._memchr import memrchr3 as memrchr3
from ry.ryo3._quick_maths import quick_maths as quick_maths
from ry.ryo3._regex import Regex as Regex
from ry.ryo3._reqwest import BlockingClient as BlockingClient
from ry.ryo3._reqwest import BlockingResponse as BlockingResponse
from ry.ryo3._reqwest import BlockingResponseStream as BlockingResponseStream
from ry.ryo3._reqwest import Certificate as Certificate
from ry.ryo3._reqwest import (
    CertificateRevocationList as CertificateRevocationList,
)
from ry.ryo3._reqwest import Client as Client
from ry.ryo3._reqwest import ClientConfig as ClientConfig
from ry.ryo3._reqwest import Cookie as Cookie
from ry.ryo3._reqwest import HttpClient as HttpClient
from ry.ryo3._reqwest import Identity as Identity
from ry.ryo3._reqwest import Proxy as Proxy
from ry.ryo3._reqwest import RequestKwargs as RequestKwargs
from ry.ryo3._reqwest import ReqwestError as ReqwestError
from ry.ryo3._reqwest import Response as Response
from ry.ryo3._reqwest import ResponseStream as ResponseStream
from ry.ryo3._reqwest import fetch as fetch
from ry.ryo3._reqwest import fetch_sync as fetch_sync
from ry.ryo3._same_file import is_same_file as is_same_file
from ry.ryo3._shlex import shplit as shplit
from ry.ryo3._size import Size as Size
from ry.ryo3._size import SizeFormatter as SizeFormatter
from ry.ryo3._size import fmt_size as fmt_size
from ry.ryo3._size import parse_size as parse_size
from ry.ryo3._sqlformat import SqlfmtQueryParams as SqlfmtQueryParams
from ry.ryo3._sqlformat import SqlFormatter as SqlFormatter
from ry.ryo3._sqlformat import sqlfmt as sqlfmt
from ry.ryo3._sqlformat import sqlfmt_params as sqlfmt_params
from ry.ryo3._std import DirEntry as DirEntry
from ry.ryo3._std import Duration as Duration
from ry.ryo3._std import FileReadStream as FileReadStream
from ry.ryo3._std import FileType as FileType
from ry.ryo3._std import Instant as Instant
from ry.ryo3._std import IpAddr as IpAddr
from ry.ryo3._std import Ipv4Addr as Ipv4Addr
from ry.ryo3._std import Ipv6Addr as Ipv6Addr
from ry.ryo3._std import Metadata as Metadata
from ry.ryo3._std import ReadDir as ReadDir
from ry.ryo3._std import SocketAddr as SocketAddr
from ry.ryo3._std import SocketAddrV4 as SocketAddrV4
from ry.ryo3._std import SocketAddrV6 as SocketAddrV6
from ry.ryo3._std import canonicalize as canonicalize
from ry.ryo3._std import copy as copy
from ry.ryo3._std import create_dir as create_dir
from ry.ryo3._std import create_dir_all as create_dir_all
from ry.ryo3._std import duration as duration
from ry.ryo3._std import exists as exists
from ry.ryo3._std import hard_link as hard_link
from ry.ryo3._std import instant as instant
from ry.ryo3._std import is_dir as is_dir
from ry.ryo3._std import is_file as is_file
from ry.ryo3._std import is_symlink as is_symlink
from ry.ryo3._std import metadata as metadata
from ry.ryo3._std import read as read
from ry.ryo3._std import read_bytes as read_bytes
from ry.ryo3._std import read_dir as read_dir
from ry.ryo3._std import read_link as read_link
from ry.ryo3._std import read_str as read_str
from ry.ryo3._std import read_stream as read_stream
from ry.ryo3._std import read_text as read_text
from ry.ryo3._std import read_to_string as read_to_string
from ry.ryo3._std import remove_dir as remove_dir
from ry.ryo3._std import remove_dir_all as remove_dir_all
from ry.ryo3._std import remove_file as remove_file
from ry.ryo3._std import rename as rename
from ry.ryo3._std import set_permissions as set_permissions
from ry.ryo3._std import sleep as sleep
from ry.ryo3._std import soft_link as soft_link
from ry.ryo3._std import symlink_metadata as symlink_metadata
from ry.ryo3._std import write as write
from ry.ryo3._std import write_bytes as write_bytes
from ry.ryo3._std import write_text as write_text
from ry.ryo3._std_constants import I8_BITS as I8_BITS
from ry.ryo3._std_constants import I8_MAX as I8_MAX
from ry.ryo3._std_constants import I8_MIN as I8_MIN
from ry.ryo3._std_constants import I16_BITS as I16_BITS
from ry.ryo3._std_constants import I16_MAX as I16_MAX
from ry.ryo3._std_constants import I16_MIN as I16_MIN
from ry.ryo3._std_constants import I32_BITS as I32_BITS
from ry.ryo3._std_constants import I32_MAX as I32_MAX
from ry.ryo3._std_constants import I32_MIN as I32_MIN
from ry.ryo3._std_constants import I64_BITS as I64_BITS
from ry.ryo3._std_constants import I64_MAX as I64_MAX
from ry.ryo3._std_constants import I64_MIN as I64_MIN
from ry.ryo3._std_constants import I128_BITS as I128_BITS
from ry.ryo3._std_constants import I128_MAX as I128_MAX
from ry.ryo3._std_constants import I128_MIN as I128_MIN
from ry.ryo3._std_constants import ISIZE_BITS as ISIZE_BITS
from ry.ryo3._std_constants import ISIZE_MAX as ISIZE_MAX
from ry.ryo3._std_constants import ISIZE_MIN as ISIZE_MIN
from ry.ryo3._std_constants import U8_BITS as U8_BITS
from ry.ryo3._std_constants import U8_MAX as U8_MAX
from ry.ryo3._std_constants import U8_MIN as U8_MIN
from ry.ryo3._std_constants import U16_BITS as U16_BITS
from ry.ryo3._std_constants import U16_MAX as U16_MAX
from ry.ryo3._std_constants import U16_MIN as U16_MIN
from ry.ryo3._std_constants import U32_BITS as U32_BITS
from ry.ryo3._std_constants import U32_MAX as U32_MAX
from ry.ryo3._std_constants import U32_MIN as U32_MIN
from ry.ryo3._std_constants import U64_BITS as U64_BITS
from ry.ryo3._std_constants import U64_MAX as U64_MAX
from ry.ryo3._std_constants import U64_MIN as U64_MIN
from ry.ryo3._std_constants import U128_BITS as U128_BITS
from ry.ryo3._std_constants import U128_MAX as U128_MAX
from ry.ryo3._std_constants import U128_MIN as U128_MIN
from ry.ryo3._std_constants import USIZE_BITS as USIZE_BITS
from ry.ryo3._std_constants import USIZE_MAX as USIZE_MAX
from ry.ryo3._std_constants import USIZE_MIN as USIZE_MIN
from ry.ryo3._tokio import AsyncDirEntry as AsyncDirEntry
from ry.ryo3._tokio import AsyncFile as AsyncFile
from ry.ryo3._tokio import AsyncFileReadStream as AsyncFileReadStream
from ry.ryo3._tokio import AsyncReadDir as AsyncReadDir
from ry.ryo3._tokio import aiopen as aiopen  # type: ignore[deprecated]
from ry.ryo3._tokio import aopen as aopen
from ry.ryo3._tokio import asleep as asleep
from ry.ryo3._tokio import canonicalize_async as canonicalize_async
from ry.ryo3._tokio import copy_async as copy_async
from ry.ryo3._tokio import create_dir_all_async as create_dir_all_async
from ry.ryo3._tokio import create_dir_async as create_dir_async
from ry.ryo3._tokio import exists_async as exists_async
from ry.ryo3._tokio import hard_link_async as hard_link_async
from ry.ryo3._tokio import metadata_async as metadata_async
from ry.ryo3._tokio import read_async as read_async
from ry.ryo3._tokio import read_dir_async as read_dir_async
from ry.ryo3._tokio import read_link_async as read_link_async
from ry.ryo3._tokio import read_stream_async as read_stream_async
from ry.ryo3._tokio import read_to_string_async as read_to_string_async
from ry.ryo3._tokio import remove_dir_all_async as remove_dir_all_async
from ry.ryo3._tokio import remove_dir_async as remove_dir_async
from ry.ryo3._tokio import remove_file_async as remove_file_async
from ry.ryo3._tokio import rename_async as rename_async
from ry.ryo3._tokio import sleep_async as sleep_async
from ry.ryo3._tokio import try_exists_async as try_exists_async
from ry.ryo3._tokio import write_async as write_async
from ry.ryo3._unindent import unindent as unindent
from ry.ryo3._unindent import unindent_bytes as unindent_bytes
from ry.ryo3._url import URL as URL
from ry.ryo3._walkdir import WalkDirEntry as WalkDirEntry
from ry.ryo3._walkdir import WalkdirGen as WalkdirGen
from ry.ryo3._walkdir import walkdir as walkdir
from ry.ryo3._which import which as which
from ry.ryo3._which import which_all as which_all
from ry.ryo3._which import which_re as which_re
from ry.ryo3._zstd import is_zstd as is_zstd
from ry.ryo3._zstd import zstd_compress as zstd_compress
from ry.ryo3._zstd import zstd_decode as zstd_decode
from ry.ryo3._zstd import zstd_decompress as zstd_decompress
from ry.ryo3._zstd import zstd_encode as zstd_encode
from ry.ryo3.errors import FeatureNotEnabledError as FeatureNotEnabledError
from ry.ryo3.JSON import stringify as stringify
from ry.ryo3.JSON import stringify_unsafe as stringify_unsafe
from ry.ryo3.orjson import orjson_default as orjson_default
from ry.ryo3.sh import cd as cd
from ry.ryo3.sh import home as home
from ry.ryo3.sh import ls as ls
from ry.ryo3.sh import mkdir as mkdir
from ry.ryo3.sh import mkdirp as mkdirp
from ry.ryo3.sh import pwd as pwd
</code></pre>
<h2 id="ry.ryo3.__about__"><code>ry.ryo3.__about__</code></h2>

<pre><code class="language-python">import typing as t

__version__: str
__authors__: str
__build_profile__: str
__build_timestamp__: str
__pkg_name__: str
__description__: str
__target__: str
__opt_level__: t.Literal["0", "1", "2", "3", "s", "z"]
__allocator__: t.Literal["mimalloc", "system"]
__crypto_provider__: t.Literal["ring", "aws-lc-rs"]
</code></pre>
<h2 id="ry.ryo3._aws_lc"><code>ry.ryo3._aws_lc</code></h2>

<pre><code class="language-python">import typing as t

from ry._types import Buffer

SHA1_BLOCK_SIZE: t.TypeAlias = t.Literal[64]
SHA1_DIGEST_SIZE: t.TypeAlias = t.Literal[20]

SHA224_BLOCK_SIZE: t.TypeAlias = t.Literal[64]
SHA224_DIGEST_SIZE: t.TypeAlias = t.Literal[28]

SHA256_BLOCK_SIZE: t.TypeAlias = t.Literal[64]
SHA256_DIGEST_SIZE: t.TypeAlias = t.Literal[32]

SHA384_BLOCK_SIZE: t.TypeAlias = t.Literal[128]
SHA384_DIGEST_SIZE: t.TypeAlias = t.Literal[48]

SHA3_256_BLOCK_SIZE: t.TypeAlias = t.Literal[136]
SHA3_256_DIGEST_SIZE: t.TypeAlias = t.Literal[32]

SHA3_384_BLOCK_SIZE: t.TypeAlias = t.Literal[104]
SHA3_384_DIGEST_SIZE: t.TypeAlias = t.Literal[48]

SHA3_512_BLOCK_SIZE: t.TypeAlias = t.Literal[72]
SHA3_512_DIGEST_SIZE: t.TypeAlias = t.Literal[64]

SHA512_BLOCK_SIZE: t.TypeAlias = t.Literal[128]
SHA512_DIGEST_SIZE: t.TypeAlias = t.Literal[64]

SHA512_256_BLOCK_SIZE: t.TypeAlias = t.Literal[128]
SHA512_256_DIGEST_SIZE: t.TypeAlias = t.Literal[32]

_TName = t.TypeVar("_TName", bound=str)
_TBlockSize = t.TypeVar("_TBlockSize", bound=int)
_TDigestSize = t.TypeVar("_TDigestSize", bound=int)


@t.type_check_only
class _Sha(t.Generic[_TName, _TBlockSize, _TDigestSize]):
    name: _TName
    digest_size: _TDigestSize
    block_size: _TBlockSize

    def copy(self) -&gt; t.Self: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def update(self, obj: Buffer, /) -&gt; None: ...
    @staticmethod
    def oneshot(data: Buffer) -&gt; bytes: ...


# fmt: off
sha1: type[_Sha[t.Literal["sha1"], SHA1_BLOCK_SIZE, SHA1_DIGEST_SIZE]]
sha224: type[_Sha[t.Literal["sha224"], SHA224_BLOCK_SIZE, SHA224_DIGEST_SIZE]]
sha256: type[_Sha[t.Literal["sha256"], SHA256_BLOCK_SIZE, SHA256_DIGEST_SIZE]]
sha384: type[_Sha[t.Literal["sha384"], SHA384_BLOCK_SIZE, SHA384_DIGEST_SIZE]]
sha3_256: type[_Sha[t.Literal["sha3_256"], SHA3_256_BLOCK_SIZE, SHA3_256_DIGEST_SIZE]]
sha3_384: type[_Sha[t.Literal["sha3_384"], SHA3_384_BLOCK_SIZE, SHA3_384_DIGEST_SIZE]]
sha3_512: type[_Sha[t.Literal["sha3_512"], SHA3_512_BLOCK_SIZE, SHA3_512_DIGEST_SIZE]]
sha512: type[_Sha[t.Literal["sha512"], SHA512_BLOCK_SIZE, SHA512_DIGEST_SIZE]]
sha512_256: type[_Sha[t.Literal["sha512_256"], SHA512_256_BLOCK_SIZE, SHA512_256_DIGEST_SIZE]]
# fmt: on
</code></pre>
<h2 id="ry.ryo3._brotli"><code>ry.ryo3._brotli</code></h2>

<pre><code class="language-python">"""ryo3-brotli types"""

from typing import Literal, TypeAlias

from ry._types import Buffer

_Quality: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]


def brotli_encode(
    data: Buffer, quality: _Quality = 11, *, magic_number: bool = False
) -&gt; bytes: ...
def brotli_decode(data: Buffer) -&gt; bytes: ...
def brotli(
    data: Buffer, quality: _Quality = 11, *, magic_number: bool = False
) -&gt; bytes:
    """Alias for brotli_encode"""
</code></pre>
<h2 id="ry.ryo3._bytes"><code>ry.ryo3._bytes</code></h2>

<pre><code class="language-python">import sys
from typing import overload

import typing_extensions

if sys.version_info &gt;= (3, 12):
    from collections.abc import Buffer as Buffer
else:
    from typing_extensions import Buffer as Buffer


class Bytes(Buffer):
    """
    A buffer implementing the Python buffer protocol, allowing zero-copy access
    to underlying Rust memory.

    You can pass this to `memoryview` for a zero-copy view into the underlying
    data or to `bytes` to copy the underlying data into a Python `bytes`.

    Many methods from the Python `bytes` class are implemented on this,
    """

    def __init__(self, buf: Buffer = b"") -&gt; None:
        """Construct a new Bytes object.

        This will be a zero-copy view on the Python byte slice.
        """

    def __add__(self, other: Buffer) -&gt; Bytes: ...
    def __buffer__(self, flags: int) -&gt; memoryview: ...
    def __contains__(self, other: Buffer) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @overload
    def __getitem__(self, other: int) -&gt; int: ...
    @overload
    def __getitem__(self, other: slice) -&gt; Bytes: ...
    def __mul__(self, other: int) -&gt; Bytes: ...
    def __rmul__(self, other: int) -&gt; Bytes: ...
    def __len__(self) -&gt; int: ...
    def __bytes__(self) -&gt; bytes:
        """Return the underlying data as a Python `bytes` object."""

    def removeprefix(self, prefix: Buffer, /) -&gt; Bytes:
        """
        If the binary data starts with the prefix string, return `bytes[len(prefix):]`.
        Otherwise, return the original binary data.
        """

    def removesuffix(self, suffix: Buffer, /) -&gt; Bytes:
        """
        If the binary data ends with the suffix string and that suffix is not empty,
        return `bytes[:-len(suffix)]`. Otherwise, return the original binary data.
        """

    def isalnum(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetical ASCII characters or
        ASCII decimal digits and the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal digits
        are those byte values in the sequence `b'0123456789'`.
        """

    def isalpha(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are alphabetic ASCII characters and
        the sequence is not empty, `False` otherwise.

        Alphabetic ASCII characters are those byte values in the sequence
        `b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
        """

    def isascii(self) -&gt; bool:
        """
        Return `True` if the sequence is empty or all bytes in the sequence are ASCII,
        `False` otherwise.

        ASCII bytes are in the range `0-0x7F`.
        """

    def isdigit(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII decimal digits and the
        sequence is not empty, `False` otherwise.

        ASCII decimal digits are those byte values in the sequence `b'0123456789'`.
        """

    def islower(self) -&gt; bool:
        """
        Return `True` if there is at least one lowercase ASCII character in the sequence
        and no uppercase ASCII characters, `False` otherwise.
        """

    def isspace(self) -&gt; bool:
        """
        Return `True` if all bytes in the sequence are ASCII whitespace and the sequence
        is not empty, `False` otherwise.

        ASCII whitespace characters are those byte values
        in the sequence `b' \t\n\r\x0b\f'` (space, tab, newline, carriage return,
        vertical tab, form feed).
        """

    def isupper(self) -&gt; bool:
        """
        Return `True` if there is at least one uppercase alphabetic ASCII character in
        the sequence and no lowercase ASCII characters, `False` otherwise.
        """

    def lower(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the uppercase ASCII characters converted
        to their corresponding lowercase counterpart.
        """

    def upper(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all the lowercase ASCII characters converted
        to their corresponding uppercase counterpart.
        """

    def to_bytes(self) -&gt; bytes:
        """Copy this buffer's contents into a Python `bytes` object."""

    # =========================================================================
    # IMPL IN RY
    # =========================================================================

    def istitle(self) -&gt; bool:
        """
        Return `True` if the sequence is non-empty and contains only ASCII letters,
        digits, underscores, and hyphens, and starts with an ASCII letter or underscore.
        Otherwise, return `False`.
        """

    def decode(self, encoding: str = "utf-8", errors: str = "strict") -&gt; str:
        """Decode the binary data using the given encoding."""

    def hex(
        self, sep: str | None = None, bytes_per_sep: int | None = None
    ) -&gt; str:
        """Return a hexadecimal representation of the binary data."""

    @classmethod
    def fromhex(cls, string: str) -&gt; Bytes:
        """Construct a `Bytes` object from a hexadecimal string."""

    def startswith(self, prefix: Buffer, /) -&gt; bool:
        """Return `True` if the binary data starts with the prefix string, `False` otherwise."""

    def endswith(self, suffix: Buffer, /) -&gt; bool:
        """Return `True` if the binary data ends with the suffix string, `False` otherwise."""

    def capitalize(self) -&gt; Bytes:
        """
        Return a copy of the sequence with the first byte converted to uppercase and
        all other bytes converted to lowercase.
        """

    def strip(self, chars: Buffer | None = None, /) -&gt; Bytes:
        """
        Return a copy of the sequence with leading and trailing bytes removed.
        If `chars` is provided, remove all bytes in `chars` from both ends.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def lstrip(self, chars: Buffer | None = None, /) -&gt; Bytes:
        """
        Return a copy of the sequence with leading bytes removed.
        If `chars` is provided, remove all bytes in `chars` from the left end.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def rstrip(self, chars: Buffer | None = None, /) -&gt; Bytes:
        """
        Return a copy of the sequence with trailing bytes removed.
        If `chars` is provided, remove all bytes in `chars` from the right end.
        If `chars` is not provided, remove all ASCII whitespace bytes.
        """

    def expandtabs(self, tabsize: int = 8) -&gt; Bytes:
        """
        Return a copy of the sequence with all ASCII tab characters replaced by spaces.
        The number of spaces is determined by the `tabsize` parameter.
        """

    def title(self) -&gt; Bytes:
        """
        Return a copy of the sequence with the first byte of each word converted to
        uppercase and all other bytes converted to lowercase.
        """

    def swapcase(self) -&gt; Bytes:
        """
        Return a copy of the sequence with all uppercase ASCII characters converted to
        their corresponding lowercase counterpart and vice versa.
        """


BytesLike: typing_extensions.TypeAlias = (
    Buffer | bytes | bytearray | memoryview | Bytes
)
</code></pre>
<h2 id="ry.ryo3._bzip2"><code>ry.ryo3._bzip2</code></h2>

<pre><code class="language-python">"""ryo3-bzip2 types"""

from typing import Literal, TypeAlias

from ry import Bytes
from ry._types import Buffer

_Quality: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, "best", "fast"]


def bzip2_decode(data: Buffer) -&gt; Bytes: ...
def bzip2_encode(data: Buffer, quality: _Quality = 6) -&gt; Bytes: ...
def bzip2(data: Buffer, quality: _Quality = 6) -&gt; Bytes:
    """Alias for bzip2_encode"""
</code></pre>
<h2 id="ry.ryo3._dev"><code>ry.ryo3._dev</code></h2>

<pre><code class="language-python">"""ry.ryo3.dev"""

import typing as t


# =============================================================================
# SUBPROCESS (VERY MUCH WIP)
# =============================================================================
def run(
    *args: str | list[str],
    capture_output: bool = True,
    input: bytes | None = None,  # noqa: A002
) -&gt; t.Any: ...


# =============================================================================
# STRING-DEV
# =============================================================================


def anystr_noop(s: t.AnyStr) -&gt; t.AnyStr: ...
def string_noop(s: str) -&gt; str: ...
def bytes_noop(s: bytes) -&gt; bytes: ...
</code></pre>
<h2 id="ry.ryo3._encoding_rs"><code>ry.ryo3._encoding_rs</code></h2>

<pre><code class="language-python">import typing as t

Encoding: t.TypeAlias = t.Literal[
    # UTF-8
    "utf8",
    "utf-8",
    "unicode20utf8",
    "unicode11utf8",
    "x-unicode20utf8",
    "unicode-1-1-utf-8",
    # UTF-16LE
    "ucs-2",
    "utf-16",
    "unicode",
    "utf-16le",
    "csunicode",
    "unicodefeff",
    "iso-10646-ucs-2",
    # UTF-16BE
    "utf-16be",
    "unicodefffe",
    # Big5
    "big5",
    "csbig5",
    "cn-big5",
    "x-x-big5",
    "big5-hkscs",
    # EUC-JP
    "euc-jp",
    "x-euc-jp",
    "cseucpkdfmtjapanese",
    # EUC-KR
    "korean",
    "euc-kr",
    "ksc5601",
    "cseuckr",
    "ksc_5601",
    "iso-ir-149",
    "windows-949",
    "csksc56011987",
    "ks_c_5601-1987",
    "ks_c_5601-1989",
    # GBK
    "gbk",
    "x-gbk",
    "gb2312",
    "gb_2312",
    "chinese",
    "csgb2312",
    "iso-ir-58",
    "gb_2312-80",
    "csiso58gb231280",
    # IBM866
    "866",
    "cp866",
    "ibm866",
    "csibm866",
    # ISO-2022-JP
    "iso-2022-jp",
    "csiso2022jp",
    # ISO-8859-10
    "l6",
    "latin6",
    "iso885910",
    "iso8859-10",
    "iso-ir-157",
    "iso-8859-10",
    "csisolatin6",
    # ISO-8859-13
    "iso885913",
    "iso8859-13",
    "iso-8859-13",
    # ISO-8859-14
    "iso885914",
    "iso8859-14",
    "iso-8859-14",
    # ISO-8859-15
    "l9",
    "iso885915",
    "iso8859-15",
    "iso-8859-15",
    "iso_8859-15",
    "csisolatin9",
    # ISO-8859-16
    "iso-8859-16",
    # ISO-8859-2
    "l2",
    "latin2",
    "iso88592",
    "iso8859-2",
    "iso-ir-101",
    "iso-8859-2",
    "iso_8859-2",
    "csisolatin2",
    "iso_8859-2:1987",
    # ISO-8859-3
    "l3",
    "latin3",
    "iso88593",
    "iso8859-3",
    "iso-8859-3",
    "iso_8859-3",
    "iso-ir-109",
    "csisolatin3",
    "iso_8859-3:1988",
    # ISO-8859-4
    "l4",
    "latin4",
    "iso88594",
    "iso8859-4",
    "iso-ir-110",
    "iso-8859-4",
    "iso_8859-4",
    "csisolatin4",
    "iso_8859-4:1988",
    # ISO-8859-5
    "iso88595",
    "cyrillic",
    "iso8859-5",
    "iso-ir-144",
    "iso-8859-5",
    "iso_8859-5",
    "iso_8859-5:1988",
    "csisolatincyrillic",
    # ISO-8859-6
    "arabic",
    "ecma-114",
    "iso88596",
    "asmo-708",
    "iso8859-6",
    "iso-8859-6",
    "iso_8859-6",
    "iso-ir-127",
    "csiso88596e",
    "csiso88596i",
    "iso-8859-6-e",
    "iso-8859-6-i",
    "iso_8859-6:1987",
    "csisolatinarabic",
    # ISO-8859-7
    "greek",
    "greek8",
    "iso88597",
    "ecma-118",
    "elot_928",
    "iso8859-7",
    "iso-ir-126",
    "iso-8859-7",
    "iso_8859-7",
    "sun_eu_greek",
    "iso_8859-7:1987",
    "csisolatingreek",
    # ISO-8859-8
    "visual",
    "hebrew",
    "iso88598",
    "iso8859-8",
    "iso-8859-8",
    "iso_8859-8",
    "iso-ir-138",
    "csiso88598e",
    "iso-8859-8-e",
    "iso_8859-8:1988",
    "csisolatinhebrew",
    # ISO-8859-8-I
    "logical",
    "csiso88598i",
    "iso-8859-8-i",
    # KOI8-R
    "koi",
    "koi8",
    "koi8-r",
    "koi8_r",
    "cskoi8r",
    # KOI8-U
    "koi8-u",
    "koi8-ru",
    # Shift_JIS
    "sjis",
    "ms932",
    "x-sjis",
    "ms_kanji",
    "shift-jis",
    "shift_jis",
    "csshiftjis",
    "windows-31j",
    # gb18030
    "gb18030",
    # macintosh
    "mac",
    "macintosh",
    "csmacintosh",
    "x-mac-roman",
    # replacement
    "hz-gb-2312",
    "iso-2022-cn",
    "iso-2022-kr",
    "csiso2022kr",
    "replacement",
    "iso-2022-cn-ext",
    # windows-1250
    "cp1250",
    "x-cp1250",
    "windows-1250",
    # windows-1251
    "cp1251",
    "x-cp1251",
    "windows-1251",
    # windows-1252
    "l1",
    "cp819",
    "ascii",
    "latin1",
    "cp1252",
    "ibm819",
    "iso88591",
    "x-cp1252",
    "us-ascii",
    "iso8859-1",
    "iso-ir-100",
    "iso-8859-1",
    "iso_8859-1",
    "csisolatin1",
    "windows-1252",
    "ansi_x3.4-1968",
    "iso_8859-1:1987",
    # windows-1253
    "cp1253",
    "x-cp1253",
    "windows-1253",
    # windows-1254
    "l5",
    "cp1254",
    "latin5",
    "x-cp1254",
    "iso88599",
    "iso8859-9",
    "iso-ir-148",
    "iso-8859-9",
    "iso_8859-9",
    "csisolatin5",
    "windows-1254",
    "iso_8859-9:1989",
    # windows-1255
    "cp1255",
    "x-cp1255",
    "windows-1255",
    # windows-1256
    "cp1256",
    "x-cp1256",
    "windows-1256",
    # windows-1257
    "cp1257",
    "x-cp1257",
    "windows-1257",
    # windows-1258
    "cp1258",
    "x-cp1258",
    "windows-1258",
    # windows-874
    "tis-620",
    "dos-874",
    "iso885911",
    "iso8859-11",
    "iso-8859-11",
    "windows-874",
    # x-mac-cyrillic
    "x-mac-cyrillic",
    "x-mac-ukrainian",
    # x-user-defined
    "x-user-defined",
]
</code></pre>
<h2 id="ry.ryo3._flate2"><code>ry.ryo3._flate2</code></h2>

<pre><code class="language-python">"""ryo3-flate2 types"""

from typing import Literal, TypeAlias

from ry import Bytes
from ry._types import Buffer

Quality: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "best", "fast"]


def gzip_encode(data: Buffer, quality: Quality = 6) -&gt; Bytes: ...
def gzip_decode(data: Buffer) -&gt; Bytes: ...
def gzip(data: Buffer, quality: Quality = 6) -&gt; Bytes:
    """Alias for gzip_encode"""


def gunzip(data: Buffer) -&gt; Bytes:
    """Alias for gzip_decode"""


def is_gzipped(data: Buffer) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._fnv"><code>ry.ryo3._fnv</code></h2>

<pre><code class="language-python">"""ryo3-fnv types"""

import typing as t

from ry._types import Buffer


@t.final
class fnv1a:  # noqa: N801
    name: t.Literal["fnv1a"]
    digest_size: t.Literal[8]
    block_size: t.Literal[1]

    def __init__(
        self,
        data: Buffer | None = None,
        *,
        key: int | bytes = 0xCBF29CE484222325,  # noqa: PYI054
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def intdigest(self) -&gt; int: ...
    def hexdigest(self) -&gt; str: ...
    def copy(self) -&gt; t.Self: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, key: int | bytes = 0xCBF29CE484222325
    ) -&gt; int: ...  # noqa: PYI054
</code></pre>
<h2 id="ry.ryo3._fspath"><code>ry.ryo3._fspath</code></h2>

<pre><code class="language-python">"""ryo3-fspath types"""

import typing as t
from os import PathLike
from pathlib import Path

from ry._types import Buffer
from ry.protocols import RyIterator, ToPy, ToString
from ry.ryo3._bytes import Bytes
from ry.ryo3._regex import Regex
from ry.ryo3._std import Metadata


@t.final
class FsPath(ToPy[Path], ToString):
    def __init__(self, path: PathLike[str] | str | None = None) -&gt; None: ...
    def __fspath__(self) -&gt; str: ...
    def to_string(self) -&gt; str: ...
    def to_py(self) -&gt; Path: ...
    def to_pathlib(self) -&gt; Path: ...
    # =========================================================================
    # IO
    # =========================================================================
    def read(self) -&gt; Bytes: ...
    def read_bytes(self) -&gt; bytes: ...
    def read_text(self) -&gt; str: ...
    def write(self, data: Buffer | bytes) -&gt; None: ...
    def write_bytes(self, data: Buffer | bytes) -&gt; None: ...
    def write_text(self, data: str) -&gt; None: ...
    def touch(self, mode: int | None = None, exist_ok: bool = True) -&gt; bool:
        """Returns `True` if file was created `False` if already existed."""

    def open(
        self,
        mode: str,
        buffering: int = -1,
        encoding: str | None = None,
        errors: str | None = None,
        newline: str | None = None,
    ) -&gt; t.IO[t.Any]: ...

    # =========================================================================
    # METHODS
    # =========================================================================
    def absolute(self) -&gt; FsPath: ...
    def as_posix(self) -&gt; str: ...
    def as_uri(self) -&gt; str: ...
    def clone(self) -&gt; FsPath: ...
    def equiv(self, other: PathLike[str] | str | FsPath) -&gt; bool: ...
    def exists(self) -&gt; bool: ...
    def iterdir(self) -&gt; FsPathReaddir: ...
    def join(self, p: PathLike[str] | str | FsPath) -&gt; FsPath: ...
    # TODO: support *args
    def joinpath(self, other: str) -&gt; FsPath: ...
    def metadata(self) -&gt; Metadata: ...
    def mkdir(
        self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False
    ) -&gt; None: ...
    def read_dir(self) -&gt; FsPathReaddir: ...
    def read_link(self) -&gt; FsPath: ...
    def relative_to(self, other: PathLike[str] | str) -&gt; FsPath: ...
    def rename(self, new_path: PathLike[str] | str) -&gt; FsPath: ...
    def replace(self, new_path: PathLike[str] | str) -&gt; FsPath: ...
    def resolve(self) -&gt; FsPath: ...
    def rmdir(self, recursive: bool = False) -&gt; None: ...
    def unlink(
        self, missing_ok: bool = False, recursive: bool = False
    ) -&gt; None: ...
    def with_name(self, name: str) -&gt; t.Self: ...
    def with_suffix(self, suffix: str) -&gt; t.Self: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def cwd(cls) -&gt; t.Self: ...
    @classmethod
    def home(cls) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def anchor(self) -&gt; str: ...
    @property
    def drive(self) -&gt; str: ...
    @property
    def name(self) -&gt; str: ...
    @property
    def parent(self) -&gt; t.Self: ...
    @property
    def parents(self) -&gt; t.Sequence[t.Self]: ...
    @property
    def parts(self) -&gt; tuple[str, ...]: ...
    @property
    def root(self) -&gt; t.Self | None: ...
    @property
    def stem(self) -&gt; str: ...
    @property
    def suffix(self) -&gt; str: ...
    @property
    def suffixes(self) -&gt; list[str]: ...

    # =========================================================================
    # std::path::PathBuf (deref -&gt; std::path::Path)
    # =========================================================================
    def ancestors(self) -&gt; RyIterator[t.Self]: ...
    def canonicalize(self) -&gt; t.Self: ...
    def components(self) -&gt; t.Iterator[t.Self]: ...
    def display(self) -&gt; str: ...
    def ends_with(self, child: PathLike[str] | str) -&gt; bool: ...
    def extension(self) -&gt; str: ...
    def file_name(self) -&gt; str: ...
    def file_prefix(self) -&gt; t.Self: ...
    def file_stem(self) -&gt; str: ...
    def has_root(self) -&gt; bool: ...
    def is_absolute(self) -&gt; bool: ...
    def is_dir(self) -&gt; bool: ...
    def is_file(self) -&gt; bool: ...
    def is_relative(self) -&gt; bool: ...
    def is_symlink(self) -&gt; bool: ...
    def starts_with(self, base: PathLike[str] | str) -&gt; bool: ...
    def strip_prefix(self, base: PathLike[str] | str) -&gt; t.Self: ...
    def with_extension(self, extension: str) -&gt; t.Self: ...
    def with_file_name(self, name: str) -&gt; t.Self: ...

    # =========================================================================
    # FEATURE: `same-file`
    # =========================================================================
    def samefile(self, other: PathLike[str] | str | t.Self) -&gt; bool: ...
    def symlink_metadata(self) -&gt; Metadata: ...

    # =========================================================================
    # FEATURE: `which` &amp; `which-regex`
    # =========================================================================
    @staticmethod
    def which(cmd: str, path: str | None = None) -&gt; FsPath | None: ...
    @staticmethod
    def which_all(cmd: str, path: str | None = None) -&gt; list[FsPath]: ...
    @staticmethod
    def which_re(
        regex: str | Regex, path: str | None = None
    ) -&gt; list[FsPath]: ...

    # =========================================================================
    # DUNDERS
    # =========================================================================
    def __truediv__(self, other: PathLike[str] | str) -&gt; t.Self: ...
    def __rtruediv__(self, other: PathLike[str] | str) -&gt; t.Self: ...
    def __lt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __le__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __ge__(self, other: PathLike[str] | str) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __bytes__(self) -&gt; bytes: ...


class FsPathReaddir(RyIterator[FsPath]):
    def __init__(self) -&gt; t.NoReturn: ...
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; FsPath: ...
    def collect(self) -&gt; list[FsPath]: ...
    def take(self, n: int = 1) -&gt; list[FsPath]: ...
</code></pre>
<h2 id="ry.ryo3._glob"><code>ry.ryo3._glob</code></h2>

<pre><code class="language-python">"""ryo3-glob types"""

import typing as t
from os import PathLike
from pathlib import Path

from ry.protocols import RyIterator
from ry.ryo3._fspath import FsPath

_T = t.TypeVar("_T", bound=str | Path | FsPath)


@t.final
class GlobPaths(RyIterator[_T]):
    """glob::Paths iterable wrapper"""

    def __next__(self) -&gt; _T: ...
    def __iter__(self) -&gt; GlobPaths[_T]: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = True,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
    strict: bool = False,
    dtype: None = None,
) -&gt; GlobPaths[Path]: ...
@t.overload
def glob(
    pattern: str,
    *,
    case_sensitive: bool = True,
    require_literal_separator: bool = False,
    require_literal_leading_dot: bool = False,
    strict: bool = False,
    dtype: type[_T],
) -&gt; GlobPaths[_T]: ...


@t.final
class GlobPattern:
    """Glob pattern matching ~ `::glob::Pattern`

    [DOCS](https://docs.rs/glob/latest/glob/struct.Pattern.html)

    Prefer the `::globset` wrappers (`Glob` | `Globset` | `Globster`).
    """

    def __init__(
        self,
        pattern: str,
        *,
        case_sensitive: bool = True,
        require_literal_separator: bool = False,
        require_literal_leading_dot: bool = False,
    ) -&gt; None: ...
    def __call__(
        self,
        ob: str | PathLike[str],
        *,
        case_sensitive: bool | None = None,
        require_literal_separator: bool | None = None,
        require_literal_leading_dot: bool | None = None,
    ) -&gt; bool: ...
    def matches(self, s: str) -&gt; bool: ...
    def matches_path(self, path: PathLike[str]) -&gt; bool: ...
    def matches_with(
        self,
        s: str,
        *,
        case_sensitive: bool | None = None,
        require_literal_separator: bool | None = None,
        require_literal_leading_dot: bool | None = None,
    ) -&gt; bool: ...
    def matches_path_with(
        self,
        path: PathLike[str],
        *,
        case_sensitive: bool | None = None,
        require_literal_separator: bool | None = None,
        require_literal_leading_dot: bool | None = None,
    ) -&gt; bool: ...
    @staticmethod
    def escape(pattern: str) -&gt; str: ...
    @property
    def pattern(self) -&gt; str: ...
    def __hash__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._globset"><code>ry.ryo3._globset</code></h2>

<pre><code class="language-python">"""ryo3-globset types"""

import typing as t
from os import PathLike


@t.final
class Glob:
    """globset::Glob wrapper"""

    def __init__(
        self,
        pattern: str,
        /,
        *,
        case_insensitive: bool = False,
        literal_separator: bool = False,
        backslash_escape: bool = ...,  # True on windows, False otherwise
    ) -&gt; None: ...
    @property
    def regex(self) -&gt; str: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    def __invert__(self) -&gt; Glob: ...
    def globset(self) -&gt; GlobSet: ...
    def globster(self) -&gt; Globster: ...


@t.final
class GlobSet:
    """globset::GlobSet wrapper"""

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool = False,
        literal_separator: bool = False,
        backslash_escape: bool = ...,  # True on windows, False otherwise
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def matches(self, path: str) -&gt; list[int]: ...
    def __call__(self, path: str) -&gt; bool: ...
    def globster(self) -&gt; Globster: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


@t.final
class Globster:
    """Globster is a matcher with claws!

    Note: The north american `Globster` is similar to the european `Globset`
          but allows for negative patterns (prefixed with '!')

    """

    def __init__(
        self,
        patterns: list[str],
        /,
        *,
        case_insensitive: bool = False,
        literal_separator: bool = False,
        backslash_escape: bool = ...,  # True on windows, False otherwise
    ) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def is_match(self, path: str | PathLike[str]) -&gt; bool: ...
    def is_match_str(self, path: str) -&gt; bool: ...
    def __call__(self, path: str | PathLike[str]) -&gt; bool: ...
    @property
    def patterns(self) -&gt; tuple[str, ...]: ...


def globster(
    patterns: list[str] | tuple[str, ...],
    /,
    *,
    case_insensitive: bool = False,
    literal_separator: bool = False,
    backslash_escape: bool = ...,  # True on windows, False otherwise
) -&gt; Globster: ...
</code></pre>
<h2 id="ry.ryo3._heck"><code>ry.ryo3._heck</code></h2>

<pre><code class="language-python">"""ryo3-heck types"""


def camel_case(string: str) -&gt; str: ...
def kebab_case(string: str) -&gt; str: ...
def pascal_case(string: str) -&gt; str: ...
def shouty_kebab_case(string: str) -&gt; str: ...
def shouty_snake_case(string: str) -&gt; str: ...
def snake_case(string: str) -&gt; str: ...
def snek_case(string: str) -&gt; str: ...
def title_case(string: str) -&gt; str: ...
def train_case(string: str) -&gt; str: ...
</code></pre>
<h2 id="ry.ryo3._http"><code>ry.ryo3._http</code></h2>

<pre><code class="language-python">import typing as t
from collections.abc import Mapping

# fmt: off
HttpVersionLike: t.TypeAlias = t.Literal[
    "HTTP/0.9", "0.9", 0,
    "HTTP/1.0", "1.0", 1, 10,
    "HTTP/1.1", "1.1", 11,
    "HTTP/2.0", "2.0", 2, 20,
    "HTTP/3.0", "3.0", 3, 30,
]
# fmt: on

_StandardHeader: t.TypeAlias = t.Literal[
    "accept",
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept-ranges",
    "access-control-allow-credentials",
    "access-control-allow-headers",
    "access-control-allow-methods",
    "access-control-allow-origin",
    "access-control-expose-headers",
    "access-control-max-age",
    "access-control-request-headers",
    "access-control-request-method",
    "age",
    "allow",
    "alt-svc",
    "authorization",
    "cache-control",
    "cache-status",
    "cdn-cache-control",
    "connection",
    "content-disposition",
    "content-encoding",
    "content-language",
    "content-length",
    "content-location",
    "content-range",
    "content-security-policy",
    "content-security-policy-report-only",
    "content-type",
    "cookie",
    "dnt",
    "date",
    "etag",
    "expect",
    "expires",
    "forwarded",
    "from",
    "host",
    "if-match",
    "if-modified-since",
    "if-none-match",
    "if-range",
    "if-unmodified-since",
    "last-modified",
    "link",
    "location",
    "max-forwards",
    "origin",
    "pragma",
    "proxy-authenticate",
    "proxy-authorization",
    "public-key-pins",
    "public-key-pins-report-only",
    "range",
    "referer",
    "referrer-policy",
    "refresh",
    "retry-after",
    "sec-websocket-accept",
    "sec-websocket-extensions",
    "sec-websocket-key",
    "sec-websocket-protocol",
    "sec-websocket-version",
    "server",
    "set-cookie",
    "strict-transport-security",
    "te",
    "trailer",
    "transfer-encoding",
    "user-agent",
    "upgrade",
    "upgrade-insecure-requests",
    "vary",
    "via",
    "warning",
    "www-authenticate",
    "x-content-type-options",
    "x-dns-prefetch-control",
    "x-frame-options",
    "x-xss-protection",
]

_HeaderName: t.TypeAlias = _StandardHeader | str
_VT = t.TypeVar("_VT", bound=str | t.Sequence[str])


@t.final
class Headers:
    """python-ryo3-http `http::HeadersMap` wrapper"""

    def __init__(
        self,
        headers: Mapping[_HeaderName, _VT] | t.Self | None = None,
        /,
        **kwargs: _VT,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def __dbg__(self) -&gt; str: ...

    # =========================================================================
    # MAGIC METHODS
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __getitem__(self, key: _HeaderName) -&gt; str: ...
    def __setitem__(self, key: _HeaderName, value: str) -&gt; None: ...
    def __delitem__(self, key: _HeaderName) -&gt; None: ...
    def __contains__(self, key: _HeaderName) -&gt; bool: ...
    def __or__(self, other: t.Self | dict[str, str]) -&gt; t.Self: ...
    def __ror__(self, other: t.Self | dict[str, str]) -&gt; t.Self: ...
    def __iter__(self) -&gt; t.Iterator[_HeaderName]: ...
    def __bool__(self) -&gt; bool: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def to_py(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def to_dict(self) -&gt; dict[str, str | t.Sequence[str]]: ...
    def stringify(self, *, fmt: bool = False) -&gt; str: ...
    def append(self, key: _HeaderName, value: str) -&gt; None: ...
    def clear(self) -&gt; None: ...
    def contains_key(self, key: _HeaderName) -&gt; bool: ...
    def get(self, key: _HeaderName) -&gt; str | None: ...
    def get_all(self, key: _HeaderName) -&gt; list[str]: ...
    def insert(self, key: _HeaderName, value: str) -&gt; None: ...
    def is_empty(self) -&gt; bool: ...
    def keys(self) -&gt; list[str]: ...
    def keys_len(self) -&gt; int: ...
    def len(self) -&gt; int: ...
    def pop(self, key: _HeaderName) -&gt; str: ...
    def remove(self, key: _HeaderName) -&gt; None: ...
    def update(
        self, headers: t.Self | dict[str, str], *, append: bool = False
    ) -&gt; None: ...
    def values(self) -&gt; list[str]: ...
    @property
    def is_flat(self) -&gt; bool: ...
    @staticmethod
    def from_json(data: str) -&gt; Headers: ...


@t.final
class HttpStatus:
    def __init__(self, code: int) -&gt; None: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: t.Self | int) -&gt; bool: ...
    def __le__(self, other: t.Self | int) -&gt; bool: ...
    def __gt__(self, other: t.Self | int) -&gt; bool: ...
    def __ge__(self, other: t.Self | int) -&gt; bool: ...
    def to_py(self) -&gt; int: ...
    @property
    def reason(self) -&gt; str: ...
    @property
    def canonical_reason(self) -&gt; str: ...
    @property
    def is_informational(self) -&gt; bool: ...
    @property
    def is_success(self) -&gt; bool: ...
    @property
    def is_redirect(self) -&gt; bool: ...
    @property
    def is_redirection(self) -&gt; bool: ...
    @property
    def is_client_error(self) -&gt; bool: ...
    @property
    def is_server_error(self) -&gt; bool: ...
    @property
    def is_error(self) -&gt; bool: ...
    @property
    def is_ok(self) -&gt; bool: ...
    @property
    def ok(self) -&gt; bool: ...

    # =========================================================================
    # CONST STATUS CODES
    # =========================================================================
    # fmt: off
    # 1xx: Informational
    CONTINUE: t.ClassVar[HttpStatus]  # 100 ~ Continue
    SWITCHING_PROTOCOLS: t.ClassVar[HttpStatus]  # 101 ~ Switching Protocols
    PROCESSING: t.ClassVar[HttpStatus]  # 102 ~ Processing
    EARLY_HINTS: t.ClassVar[HttpStatus]  # 103 ~ Early Hints
    # 2xx: Success
    OK: t.ClassVar[HttpStatus]  # 200 ~ OK
    CREATED: t.ClassVar[HttpStatus]  # 201 ~ Created
    ACCEPTED: t.ClassVar[HttpStatus]  # 202 ~ Accepted
    NON_AUTHORITATIVE_INFORMATION: t.ClassVar[HttpStatus]  # 203 ~ Non Authoritative Information
    NO_CONTENT: t.ClassVar[HttpStatus]  # 204 ~ No Content
    RESET_CONTENT: t.ClassVar[HttpStatus]  # 205 ~ Reset Content
    PARTIAL_CONTENT: t.ClassVar[HttpStatus]  # 206 ~ Partial Content
    MULTI_STATUS: t.ClassVar[HttpStatus]  # 207 ~ Multi-Status
    ALREADY_REPORTED: t.ClassVar[HttpStatus]  # 208 ~ Already Reported
    IM_USED: t.ClassVar[HttpStatus]  # 226 ~ IM Used
    # 3xx: Redirection
    MULTIPLE_CHOICES: t.ClassVar[HttpStatus]  # 300 ~ Multiple Choices
    MOVED_PERMANENTLY: t.ClassVar[HttpStatus]  # 301 ~ Moved Permanently
    FOUND: t.ClassVar[HttpStatus]  # 302 ~ Found
    SEE_OTHER: t.ClassVar[HttpStatus]  # 303 ~ See Other
    NOT_MODIFIED: t.ClassVar[HttpStatus]  # 304 ~ Not Modified
    USE_PROXY: t.ClassVar[HttpStatus]  # 305 ~ Use Proxy
    TEMPORARY_REDIRECT: t.ClassVar[HttpStatus]  # 307 ~ Temporary Redirect
    PERMANENT_REDIRECT: t.ClassVar[HttpStatus]  # 308 ~ Permanent Redirect
    # 4xx: Client Error
    BAD_REQUEST: t.ClassVar[HttpStatus]  # 400 ~ Bad Request
    UNAUTHORIZED: t.ClassVar[HttpStatus]  # 401 ~ Unauthorized
    PAYMENT_REQUIRED: t.ClassVar[HttpStatus]  # 402 ~ Payment Required
    FORBIDDEN: t.ClassVar[HttpStatus]  # 403 ~ Forbidden
    NOT_FOUND: t.ClassVar[HttpStatus]  # 404 ~ Not Found
    METHOD_NOT_ALLOWED: t.ClassVar[HttpStatus]  # 405 ~ Method Not Allowed
    NOT_ACCEPTABLE: t.ClassVar[HttpStatus]  # 406 ~ Not Acceptable
    PROXY_AUTHENTICATION_REQUIRED: t.ClassVar[HttpStatus]  # 407 ~ Proxy Authentication Required
    REQUEST_TIMEOUT: t.ClassVar[HttpStatus]  # 408 ~ Request Timeout
    CONFLICT: t.ClassVar[HttpStatus]  # 409 ~ Conflict
    GONE: t.ClassVar[HttpStatus]  # 410 ~ Gone
    LENGTH_REQUIRED: t.ClassVar[HttpStatus]  # 411 ~ Length Required
    PRECONDITION_FAILED: t.ClassVar[HttpStatus]  # 412 ~ Precondition Failed
    PAYLOAD_TOO_LARGE: t.ClassVar[HttpStatus]  # 413 ~ Payload Too Large
    URI_TOO_LONG: t.ClassVar[HttpStatus]  # 414 ~ URI Too Long
    UNSUPPORTED_MEDIA_TYPE: t.ClassVar[HttpStatus]  # 415 ~ Unsupported Media Type
    RANGE_NOT_SATISFIABLE: t.ClassVar[HttpStatus]  # 416 ~ Range Not Satisfiable
    EXPECTATION_FAILED: t.ClassVar[HttpStatus]  # 417 ~ Expectation Failed
    IM_A_TEAPOT: t.ClassVar[HttpStatus]  # 418 ~ I'm a teapot
    MISDIRECTED_REQUEST: t.ClassVar[HttpStatus]  # 421 ~ Misdirected Request
    UNPROCESSABLE_ENTITY: t.ClassVar[HttpStatus]  # 422 ~ Unprocessable Entity
    LOCKED: t.ClassVar[HttpStatus]  # 423 ~ Locked
    FAILED_DEPENDENCY: t.ClassVar[HttpStatus]  # 424 ~ Failed Dependency
    TOO_EARLY: t.ClassVar[HttpStatus]  # 425 ~ Too Early
    UPGRADE_REQUIRED: t.ClassVar[HttpStatus]  # 426 ~ Upgrade Required
    PRECONDITION_REQUIRED: t.ClassVar[HttpStatus]  # 428 ~ Precondition Required
    TOO_MANY_REQUESTS: t.ClassVar[HttpStatus]  # 429 ~ Too Many Requests
    REQUEST_HEADER_FIELDS_TOO_LARGE: t.ClassVar[HttpStatus]  # 431 ~ Request Header Fields Too Large
    UNAVAILABLE_FOR_LEGAL_REASONS: t.ClassVar[HttpStatus]  # 451 ~ Unavailable For Legal Reasons
    # 5xx: Server Error
    INTERNAL_SERVER_ERROR: t.ClassVar[HttpStatus]  # 500 ~ Internal Server Error
    NOT_IMPLEMENTED: t.ClassVar[HttpStatus]  # 501 ~ Not Implemented
    BAD_GATEWAY: t.ClassVar[HttpStatus]  # 502 ~ Bad Gateway
    SERVICE_UNAVAILABLE: t.ClassVar[HttpStatus]  # 503 ~ Service Unavailable
    GATEWAY_TIMEOUT: t.ClassVar[HttpStatus]  # 504 ~ Gateway Timeout
    HTTP_VERSION_NOT_SUPPORTED: t.ClassVar[HttpStatus]  # 505 ~ HTTP Version Not Supported
    VARIANT_ALSO_NEGOTIATES: t.ClassVar[HttpStatus]  # 506 ~ Variant Also Negotiates
    INSUFFICIENT_STORAGE: t.ClassVar[HttpStatus]  # 507 ~ Insufficient Storage
    LOOP_DETECTED: t.ClassVar[HttpStatus]  # 508 ~ Loop Detected
    NOT_EXTENDED: t.ClassVar[HttpStatus]  # 510 ~ Not Extended
    NETWORK_AUTHENTICATION_REQUIRED: t.ClassVar[HttpStatus]  # 511 ~ Network Authentication Required
    # fmt: on
</code></pre>
<h2 id="ry.ryo3._jiff"><code>ry.ryo3._jiff</code></h2>

<pre><code class="language-python">"""ryo3-jiff types"""

import datetime as pydt
import sys
import typing as t

from ry._types import (
    DateDifferenceTypedDict,
    DateTimeDifferenceTypedDict,
    DateTimeRoundTypedDict,
    DateTimeTypedDict,
    DateTypedDict,
    ISOWeekDateTypedDict,
    OffsetInfoDict,
    OffsetRoundTypedDict,
    OffsetTypedDict,
    SignedDurationRoundTypedDict,
    SignedDurationTypedDict,
    TimeDifferenceTypedDict,
    TimeRoundTypedDict,
    TimeSpanTypedDict,
    TimestampDifferenceTypedDict,
    TimestampRoundTypedDict,
    TimestampTypedDict,
    TimeTypedDict,
    TimeZoneDict,
    ZonedDateTimeDifferenceTypedDict,
    ZonedDateTimeRoundTypedDict,
    ZonedDateTimeTypedDict,
)
from ry.protocols import (
    FromStr,
    Strftime,
    ToPy,
    ToPyDate,
    ToPyDateTime,
    ToPyTime,
    ToPyTimeDelta,
    ToPyTzInfo,
    ToString,
    _Parse,
)
from ry.ryo3 import Duration
from ry.ryo3._jiff_tz import TimezoneDbName

if sys.version_info &gt;= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated

_T = t.TypeVar("_T")
_Temporal = t.TypeVar(
    "_Temporal", bound=ZonedDateTime | DateTime | Timestamp | Date | Time
)

_TDict = t.TypeVar("_TDict")
TimezoneName: t.TypeAlias = TimezoneDbName | str
JiffUnit: t.TypeAlias = t.Literal[
    "year",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]

JiffRoundMode: t.TypeAlias = t.Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half-ceil",
    "half-floor",
    "half-expand",
    "half-trunc",
    "half-even",
]
_DateTimeRoundSmallest: t.TypeAlias = t.Literal[
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_SignedDurationRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_TimeRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_TimestampRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_ZonedDateTimeRoundSmallest: t.TypeAlias = t.Literal[
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_OffsetRoundSmallest: t.TypeAlias = t.Literal[
    "hour",
    "minute",
    "second",
]
_DateDifferenceUnit: t.TypeAlias = t.Literal[
    "year",
    "month",
    "week",
    "day",
]

WeekdayStr: t.TypeAlias = t.Literal[
    "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
]
WeekdayInt: t.TypeAlias = t.Literal[
    1,  # Monday
    2,  # Tuesday
    3,  # Wednesday
    4,  # Thursday
    5,  # Friday
    6,  # Saturday
    7,  # Sunday
]
Weekday: t.TypeAlias = WeekdayStr | WeekdayInt


@t.final
class Date(
    # protocols
    FromStr,
    Strftime,
    ToPyDate,
    ToPy[pydt.date],
    ToString,
    _Parse,
):
    MIN: t.ClassVar[Date]
    MAX: t.ClassVar[Date]
    ZERO: t.ClassVar[Date]

    def __init__(self, year: int, month: int, day: int) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.date: ...
    def to_pydate(self) -&gt; pydt.date: ...
    @classmethod
    def from_pydate(cls, date: pydt.date) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_iso_week_date(cls, iso_week_date: ISOWeekDate) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self:
        """Same as today for parity with other date/time types"""

    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...
    @t.overload
    def __sub__(self, other: Date) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; Date: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; Date: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; Date: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; Date: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; Date: ...
    def saturating_add(
        self,
        other: TimeSpan | SignedDuration | Duration | pydt.timedelta,
    ) -&gt; Date: ...
    def saturating_sub(
        self,
        other: TimeSpan | SignedDuration | Duration | pydt.timedelta,
    ) -&gt; Date: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def at(
        self, hour: int, minute: int, second: int, nanosecond: int = 0
    ) -&gt; DateTime: ...
    def to_dict(self) -&gt; DateTypedDict: ...
    def astuple(self) -&gt; tuple[int, int, int]: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def replace(
        self,
        *,
        year: int | None = None,
        month: int | None = None,
        day: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
    ) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def to_datetime(self, time: Time) -&gt; DateTime: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: _DateDifferenceUnit = "day",
        largest: _DateDifferenceUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: _DateDifferenceUnit = "day",
        largest: _DateDifferenceUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class Time(
    # protocols
    FromStr,
    Strftime,
    ToPyTime,
    ToPy[pydt.time],
    _Parse,
):
    MIN: t.ClassVar[Time]
    MAX: t.ClassVar[Time]

    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Time) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    def to_py(self) -&gt; pydt.time: ...
    def to_pytime(self) -&gt; pydt.time: ...
    @classmethod
    def from_pytime(cls, t: pydt.time) -&gt; t.Self: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def midnight(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def utcnow(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def wrapping_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def wrapping_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astuple(self) -&gt; tuple[int, int, int, int]: ...
    def to_dict(self) -&gt; TimeTypedDict: ...
    def duration_until(self, other: Time) -&gt; SignedDuration: ...
    def duration_since(self, other: Time) -&gt; SignedDuration: ...
    def on(self, year: int, month: int, day: int) -&gt; DateTime: ...
    def replace(
        self,
        *,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _TimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: TimeRound) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def to_datetime(self, date: Date) -&gt; DateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        t: Time | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        t: Time | DateTime | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class DateTime(
    # protocols
    FromStr,
    Strftime,
    ToPyDate,
    ToPyDateTime,
    ToPyTime,
    ToPy[pydt.datetime],
    _Parse,
):
    MIN: t.ClassVar[DateTime]
    MAX: t.ClassVar[DateTime]
    ZERO: t.ClassVar[DateTime]

    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
    ) -&gt; None: ...
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # STRPTIME/STRFTIME/PARSE
    # =========================================================================
    def strftime(self, fmt: str) -&gt; str: ...
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def __format__(self, fmt: str) -&gt; str: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, datetime: pydt.datetime) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def from_parts(cls, date: Date, time: Time) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def to_dict(self) -&gt; DateTimeTypedDict: ...
    def date(self) -&gt; Date: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; t.Self: ...
    def era_year(self) -&gt; tuple[int, t.Literal["BCE", "CE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; t.Self: ...
    def replace(
        self,
        obj: Date | DateTime | Time | None = None,
        *,
        date: Date | None = None,
        time: Time | None = None,
        year: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        month: int | None = None,
        day: int | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _DateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: DateTimeRound) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def start_of_day(self) -&gt; t.Self: ...
    def time(self) -&gt; Time: ...
    def to_zoned(self, tz: TimeZone) -&gt; ZonedDateTime: ...
    def tomorrow(self) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def _until(self, other: DateTimeDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Date | DateTime | ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


class TimeZoneTransition(t.TypedDict):
    timestamp: Timestamp
    offset: Offset
    dst: bool
    abbreviation: str


@t.final
class TimeZone(
    # protocols
    FromStr,
    ToPyTzInfo,
    ToPy[pydt.tzinfo],
    _Parse,
):
    UTC: t.ClassVar[TimeZone]

    def __init__(self, name: TimezoneName) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================

    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
    def to_dict(self) -&gt; TimeZoneDict: ...
    @classmethod
    def from_str(cls, s: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_pytzinfo(cls, tz: pydt.tzinfo) -&gt; t.Self: ...
    def to_offset_info(self, timestamp: Timestamp) -&gt; OffsetInfoDict: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def name(self) -&gt; str: ...
    @property
    def is_unknown(self) -&gt; bool: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def fixed(cls, offset: Offset) -&gt; t.Self: ...
    @classmethod
    def get(cls, tz_name: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def posix(cls, tz_name: TimezoneName) -&gt; t.Self: ...
    @classmethod
    def system(cls) -&gt; t.Self: ...
    @classmethod
    def try_system(cls) -&gt; t.Self: ...
    @classmethod
    def tzif(cls, name: str, data: bytes) -&gt; t.Self: ...
    @classmethod
    def utc(cls) -&gt; t.Self: ...
    def equiv(self, other: t.Self | pydt.tzinfo | str) -&gt; bool: ...
    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def iana_name(self) -&gt; str | None: ...
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_fixed_offset(self) -&gt; Offset:
        """Return a TimeZone with a fixed offset equivalent to this TimeZone.

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; tz = ry.TimeZone.fixed(ry.Offset(hours=-5))
            &gt;&gt;&gt; fixed_tz = tz.to_fixed_offset()
            &gt;&gt;&gt; fixed_tz
            Offset(hours=-5)

        """

    def to_offset(self, timestamp: Timestamp) -&gt; Offset: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_zoned(self, datetime: DateTime) -&gt; ZonedDateTime: ...
    def preceding(
        self,
        timestamp: Timestamp,
        /,
        limit: int | None = None,
    ) -&gt; list[TimeZoneTransition]: ...
    def following(
        self,
        timestamp: Timestamp,
        /,
        limit: int | None = None,
    ) -&gt; list[TimeZoneTransition]: ...
    # =========================================================================
    # NOT IMPLEMENTED
    # =========================================================================
    def to_ambiguous_timestamp(self) -&gt; t.NoReturn: ...
    def to_ambiguous_zoned(self) -&gt; t.NoReturn: ...


@t.final
class SignedDuration(
    # protocols
    FromStr,
    ToPyTimeDelta,
    ToPy[pydt.timedelta],
    _Parse,
):
    MIN: t.ClassVar[SignedDuration]
    MAX: t.ClassVar[SignedDuration]
    ZERO: t.ClassVar[SignedDuration]

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: object) -&gt; bool: ...
    def __le__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: object) -&gt; bool: ...
    def __neg__(self) -&gt; t.Self: ...
    @t.overload
    def __add__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    @t.overload
    def __add__(self, val: _Temporal) -&gt; _Temporal: ...
    def __radd__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    def __sub__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    def __rsub__(self, other: t.Self | Duration | pydt.timedelta) -&gt; t.Self: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __rmul__(self, other: int) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    @t.overload
    def __truediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __truediv__(self, other: float) -&gt; t.Self: ...
    def abs(self) -&gt; t.Self: ...
    def unsigned_abs(self) -&gt; Duration: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...
    # =========================================================================
    # EQUIV
    # =========================================================================
    def equiv(self, other: t.Self | Duration | pydt.timedelta) -&gt; bool: ...
    # =========================================================================
    # STRING
    # =========================================================================
    def isoformat(self) -&gt; str: ...
    @classmethod
    def from_isoformat(cls, s: str) -&gt; t.Self: ...
    def to_string(self, *, friendly: bool = False) -&gt; str: ...
    def friendly(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.timedelta: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_dict(self) -&gt; SignedDurationTypedDict: ...
    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; t.Self: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; t.Self: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; t.Self: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; t.Self: ...
    @classmethod
    def from_secs(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; t.Self: ...
    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def secs(self) -&gt; int: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def as_hours(self) -&gt; int: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_millis_f32(self) -&gt; float: ...
    def as_millis_f64(self) -&gt; float: ...
    def as_mins(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...
    def checked_add(self, other: t.Self) -&gt; t.Self | None: ...
    def checked_div(self, other: int) -&gt; t.Self | None: ...
    def checked_mul(self, other: int) -&gt; t.Self | None: ...
    def checked_neg(self) -&gt; t.Self | None: ...
    def checked_sub(self, other: t.Self) -&gt; t.Self | None: ...
    def div_duration_f32(self, other: t.Self) -&gt; float: ...
    def div_duration_f64(self, other: t.Self) -&gt; float: ...
    def div_f32(self, n: float) -&gt; float: ...
    def div_f64(self, n: float) -&gt; float: ...
    def mul_f32(self, n: float) -&gt; t.Self: ...
    def mul_f64(self, n: float) -&gt; t.Self: ...
    def saturating_add(self, other: t.Self) -&gt; t.Self: ...
    def saturating_mul(self, other: int) -&gt; t.Self: ...
    def saturating_sub(self, other: t.Self) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_timespan(self) -&gt; TimeSpan: ...
    def round(
        self,
        smallest: _SignedDurationRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: SignedDurationRound) -&gt; t.Self: ...


TimeSpanArithmetic: t.TypeAlias = (
    TimeSpan
    | Duration
    | SignedDuration
    | tuple[
        TimeSpan | Duration | SignedDuration, ZonedDateTime | Date | DateTime
    ]
)


@t.final
class TimeSpan(
    # protocols
    ToPy[pydt.timedelta],
    ToPyTimeDelta,
    FromStr,
    _Parse,
):
    def __init__(
        self,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def isoformat(self) -&gt; str: ...
    @classmethod
    def from_isoformat(cls, s: str) -&gt; t.Self: ...
    def to_string(self, *, friendly: bool = False) -&gt; str: ...
    def friendly(self) -&gt; str: ...
    def repr_full(self) -&gt; str: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def parse_common_iso(cls, s: str) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_positive(self) -&gt; bool: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def years(self) -&gt; int: ...
    @property
    def months(self) -&gt; int: ...
    @property
    def weeks(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def hours(self) -&gt; int: ...
    @property
    def minutes(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int: ...

    # =========================================================================
    # OPERATORS
    # =========================================================================
    @t.overload
    def __add__(self, val: TimeSpanArithmetic) -&gt; t.Self: ...
    @t.overload
    def __add__(self, val: _Temporal) -&gt; _Temporal: ...
    def __sub__(
        self,
        val: TimeSpanArithmetic,
    ) -&gt; t.Self: ...
    def __mul__(self, other: int) -&gt; t.Self: ...
    def __neg__(self) -&gt; t.Self: ...
    def __abs__(self) -&gt; t.Self: ...
    def __invert__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __rmul__(self, other: int) -&gt; t.Self: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    def add(self, other: TimeSpanArithmetic) -&gt; t.Self: ...
    def mul(self, other: int) -&gt; t.Self: ...
    def sub(self, other: TimeSpanArithmetic) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================

    def abs(self) -&gt; t.Self: ...
    def to_dict(self) -&gt; TimeSpanTypedDict: ...
    def fieldwise(self) -&gt; TimeSpanTypedDict: ...
    def compare(
        self,
        other: t.Self,
        relative: ZonedDateTime | DateTime | Date | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; int: ...
    def negate(self) -&gt; t.Self: ...
    def replace(
        self,
        years: int | None = None,
        months: int | None = None,
        weeks: int | None = None,
        days: int | None = None,
        hours: int | None = None,
        minutes: int | None = None,
        seconds: int | None = None,
        milliseconds: int | None = None,
        microseconds: int | None = None,
        nanoseconds: int | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: JiffUnit = "nanosecond",
        increment: int = 1,
        *,
        relative: ZonedDateTime | Date | DateTime | None = None,
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "half-expand",
        days_are_24_hours: bool = False,
    ) -&gt; t.Self: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_signed_duration(
        self,
        relative: ZonedDateTime | Date | DateTime | None = None,
    ) -&gt; SignedDuration: ...
    def total(
        self,
        unit: JiffUnit,
        relative: ZonedDateTime | Date | DateTime | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; float: ...
    def total_seconds(
        self,
        relative: ZonedDateTime | Date | DateTime | None = None,
        *,
        days_are_24_hours: bool = False,
    ) -&gt; float: ...
    def _years(self, years: int, /) -&gt; t.Self: ...
    def _months(self, months: int, /) -&gt; t.Self: ...
    def _weeks(self, weeks: int, /) -&gt; t.Self: ...
    def _days(self, days: int, /) -&gt; t.Self: ...
    def _hours(self, hours: int, /) -&gt; t.Self: ...
    def _minutes(self, minutes: int, /) -&gt; t.Self: ...
    def _seconds(self, seconds: int, /) -&gt; t.Self: ...
    def _milliseconds(self, milliseconds: int, /) -&gt; t.Self: ...
    def _microseconds(self, microseconds: int, /) -&gt; t.Self: ...
    def _nanoseconds(self, nanoseconds: int, /) -&gt; t.Self: ...


@t.final
class Timestamp(
    # protocols
    FromStr,
    Strftime,
    ToPyDate,
    ToPyDateTime,
    ToPyTime,
    ToPy[pydt.datetime],
    _Parse,
):
    """An instant in time represented as the number of nanoseconds since the Unix epoch.

    A timestamp is always in the Unix timescale with a UTC offset of zero.
    """

    MIN: t.ClassVar[Timestamp]
    MAX: t.ClassVar[Timestamp]
    UNIX_EPOCH: t.ClassVar[Timestamp]

    def __init__(self, second: int = 0, nanosecond: int = 0) -&gt; None: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_millisecond(cls, millisecond: int) -&gt; t.Self: ...
    @classmethod
    def from_microsecond(cls, microsecond: int) -&gt; t.Self: ...
    @classmethod
    def from_nanosecond(cls, nanosecond: int) -&gt; t.Self: ...
    @classmethod
    def from_second(cls, second: int) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, datetime: pydt.datetime) -&gt; t.Self: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    def to_dict(self) -&gt; TimestampTypedDict: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def second(self) -&gt; int:
        """Return the second component of the timestamp

        Returns:
            int: The second component of the timestamp.

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.second
            5
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.second
            -5

        """

    @property
    def nanosecond(self) -&gt; int:
        """Return the nanosecond component (-999_999_999..999_999_999)

        Returns:
            int: The nanosecond component of the timestamp (-999_999_999..999_999_999).

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.nanosecond
            123456789
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.nanosecond
            999999999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.nanosecond
            -123456789
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.nanosecond
            -999999999

        """

    @property
    def subsec_microsecond(self) -&gt; int:
        """Return the subsecond microsecond component (-999_999..999_999)

        Returns:
            int: subsecond microsecond component of the timestamp

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.subsec_microsecond
            123456
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.subsec_microsecond
            999999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.subsec_microsecond
            -123456
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.subsec_microsecond
            -999999

        """

    @property
    def subsec_millisecond(self) -&gt; int:
        """Return the subsecond millisecond component (-999..999)

        Returns:
            int: The subsecond millisecond component of the timestamp (-999..999).

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.subsec_millisecond
            123
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.subsec_millisecond
            999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.subsec_millisecond
            -123
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.subsec_millisecond
            -999

        """

    @property
    def subsec_nanosecond(self) -&gt; int:
        """Return the subsecond nanosecond component (-999_999_999..999_999_999)

        Returns:
            int: The subsecond nanosecond component of the timestamp (-999_999_999..999_999_999).

        Examples:
            &gt;&gt;&gt; import ry
            &gt;&gt;&gt; ts = ry.Timestamp(5, 123_456_789)
            &gt;&gt;&gt; ts.subsec_nanosecond
            123456789
            &gt;&gt;&gt; ts = ry.Timestamp(5, 999_999_999)
            &gt;&gt;&gt; ts.subsec_nanosecond
            999999999
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -123_456_789)
            &gt;&gt;&gt; ts.subsec_nanosecond
            -123456789
            &gt;&gt;&gt; ts = ry.Timestamp(-5, -999_999_999)
            &gt;&gt;&gt; ts.subsec_nanosecond
            -999999999

        """

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def isoformat(self) -&gt; str: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def time(self) -&gt; Time: ...
    def as_microsecond(self) -&gt; int: ...
    def as_millisecond(self) -&gt; int: ...
    def as_nanosecond(self) -&gt; int: ...
    def as_second(self) -&gt; int: ...
    def display_with_offset(self, offset: Offset) -&gt; str: ...
    def in_tz(self, tz: TimezoneName) -&gt; ZonedDateTime: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; ZonedDateTime:
        """Deprecated ~ use `in_tz`"""

    @property
    def is_zero(self) -&gt; bool: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def signum(self) -&gt; t.Literal[-1, 0, 1]: ...
    def to_string(self) -&gt; str: ...
    def to_zoned(self, time_zone: TimeZone) -&gt; ZonedDateTime: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def _since(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def _until(self, other: TimestampDifference) -&gt; TimeSpan: ...
    def since(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: Timestamp | ZonedDateTime,
        *,
        smallest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ] = "nanosecond",
        largest: t.Literal[
            "hour",
            "minute",
            "second",
            "millisecond",
            "microsecond",
            "nanosecond",
        ]
        | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def round(
        self,
        smallest: _TimestampRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: TimestampRound) -&gt; t.Self: ...


@t.final
class ZonedDateTime(
    # protocols
    ToPy[pydt.datetime],
    ToPyDate,
    ToPyTime,
    ToPyDateTime,
    ToPyTzInfo,
    FromStr,
    _Parse,
    Strftime,
):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        nanosecond: int = 0,
        tz: TimezoneName | None = None,
    ) -&gt; None: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pydatetime(cls, datetime: pydt.datetime) -&gt; t.Self: ...
    def to_dict(self) -&gt; ZonedDateTimeTypedDict: ...
    def to_py(self) -&gt; pydt.datetime: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_pydatetime(self) -&gt; pydt.datetime: ...
    def to_pytime(self) -&gt; pydt.time: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def now(cls, tz: TimezoneName | None = None) -&gt; t.Self: ...
    @classmethod
    def utcnow(cls) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_rfc2822(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse_rfc2822(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def from_parts(
        cls, timestamp: Timestamp, time_zone: TimeZone
    ) -&gt; t.Self: ...

    # =========================================================================
    # STRPTIME/STRFTIME
    # =========================================================================
    @classmethod
    def strptime(cls, string: str, /, fmt: str) -&gt; t.Self: ...
    def strftime(self, fmt: str) -&gt; str: ...
    def __format__(self, fmt: str) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def month(self) -&gt; int: ...
    @property
    def day(self) -&gt; int: ...
    @property
    def hour(self) -&gt; int: ...
    @property
    def minute(self) -&gt; int: ...
    @property
    def second(self) -&gt; int: ...
    @property
    def millisecond(self) -&gt; int: ...
    @property
    def microsecond(self) -&gt; int: ...
    @property
    def nanosecond(self) -&gt; int: ...
    @property
    def subsec_nanosecond(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; int: ...
    @property
    def timezone(self) -&gt; TimeZone: ...
    @property
    def tz(self) -&gt; TimeZone: ...

    # =========================================================================
    # STRING/FORMAT
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def to_rfc2822(self) -&gt; str: ...
    def format_rfc2822(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __add__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...

    # =========================================================================
    # OPERATORS/DUNDERS W/ OVERLOADS
    # =========================================================================
    @t.overload
    def __sub__(self, other: t.Self) -&gt; TimeSpan: ...
    @t.overload
    def __sub__(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(self, other: t.Self, /) -&gt; TimeSpan: ...
    @t.overload
    def sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: TimeSpan | SignedDuration | Duration | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def astimezone(self, tz: str) -&gt; t.Self: ...
    def date(self) -&gt; Date: ...
    def datetime(self) -&gt; DateTime: ...
    def iso_week_date(self) -&gt; ISOWeekDate: ...
    def day_of_year(self) -&gt; int: ...
    def day_of_year_no_leap(self) -&gt; int | None: ...
    def days_in_month(self) -&gt; int: ...
    def days_in_year(self) -&gt; int: ...
    def duration_since(self, other: t.Self) -&gt; SignedDuration: ...
    def duration_until(self, other: t.Self) -&gt; SignedDuration: ...
    def end_of_day(self) -&gt; t.Self: ...
    def era_year(self) -&gt; tuple[int, t.Literal["CE", "BCE"]]: ...
    def first_of_month(self) -&gt; t.Self: ...
    def first_of_year(self) -&gt; t.Self: ...
    def in_leap_year(self) -&gt; bool: ...
    def in_tz(self, tz: TimezoneName) -&gt; t.Self: ...
    @deprecated("intz is deprecated, use in_tz instead")
    def intz(self, tz: TimezoneName) -&gt; t.Self: ...
    def inutc(self) -&gt; t.Self: ...
    def last_of_month(self) -&gt; t.Self: ...
    def last_of_year(self) -&gt; t.Self: ...
    def nth_weekday(self, nth: int, weekday: Weekday) -&gt; Date: ...
    def nth_weekday_of_month(self, nth: int, weekday: Weekday) -&gt; Date: ...
    def offset(self) -&gt; Offset: ...
    def replace(
        self,
        obj: Date | DateTime | Time | Offset | None = None,
        *,
        date: Date | None = None,
        time: Time | None = None,
        year: int | None = None,
        era_year: tuple[int, t.Literal["BCE", "CE"]] | None = None,
        month: int | None = None,
        day: int | None = None,
        day_of_year: int | None = None,
        day_of_year_no_leap: int | None = None,
        hour: int | None = None,
        minute: int | None = None,
        second: int | None = None,
        millisecond: int | None = None,
        microsecond: int | None = None,
        nanosecond: int | None = None,
        subsec_nanosecond: int | None = None,
        offset: Offset | None = None,
        offset_conflict: t.Literal[
            "always-offset", "always-timezone", "prefer-offset", "reject"
        ]
        | None = None,
        disambiguation: t.Literal["compatible", "earliest", "latest", "reject"]
        | None = None,
    ) -&gt; t.Self: ...
    def round(
        self,
        smallest: _ZonedDateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: ZonedDateTimeRound) -&gt; t.Self: ...
    def series(self, period: TimeSpan) -&gt; JiffSeries[t.Self]: ...
    def start_of_day(self) -&gt; t.Self: ...
    def time(self) -&gt; Time: ...
    def timestamp(self) -&gt; Timestamp: ...
    def tomorrow(self) -&gt; t.Self: ...
    def with_time_zone(self, tz: TimeZone) -&gt; t.Self: ...
    def yesterday(self) -&gt; t.Self: ...

    # =========================================================================
    # SINCE/UNTIL
    # =========================================================================
    def since(
        self,
        other: t.Self,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...
    def until(
        self,
        other: t.Self,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; TimeSpan: ...


@t.final
class ISOWeekDate(
    # protocols
    ToPy[pydt.date],
    ToPyDate,
    FromStr,
    _Parse,
):
    MIN: t.ClassVar[ISOWeekDate]
    MAX: t.ClassVar[ISOWeekDate]
    ZERO: t.ClassVar[ISOWeekDate]

    def __init__(self, year: int, week: int, weekday: Weekday) -&gt; None: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================

    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __le__(self, other: ISOWeekDate) -&gt; bool: ...
    def __gt__(self, other: ISOWeekDate) -&gt; bool: ...
    def __ge__(self, other: ISOWeekDate) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # CLASS METHODS
    # =========================================================================
    @classmethod
    def from_date(cls, date: Date) -&gt; t.Self: ...
    @classmethod
    def from_pydate(cls, date: pydt.date) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def today(cls) -&gt; t.Self: ...
    @classmethod
    def now(cls) -&gt; t.Self: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def year(self) -&gt; int: ...
    @property
    def week(self) -&gt; int: ...
    @property
    def weekday(self) -&gt; WeekdayInt: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def date(self) -&gt; Date: ...
    def isoformat(self) -&gt; str: ...
    def to_py(self) -&gt; pydt.date: ...
    def to_pydate(self) -&gt; pydt.date: ...
    def to_string(self) -&gt; str: ...
    def to_dict(self) -&gt; ISOWeekDateTypedDict: ...


@t.final
class Offset(
    # protocols
    ToPy[pydt.tzinfo],
    ToPyTzInfo,
    ToPyTimeDelta,
    FromStr,
    _Parse,
):
    MIN: t.ClassVar[Offset]
    MAX: t.ClassVar[Offset]
    UTC: t.ClassVar[Offset]
    ZERO: t.ClassVar[Offset]

    def __init__(
        self,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
    ) -&gt; None: ...

    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...

    # =========================================================================
    # OPERATORS/DUNDERS
    # =========================================================================
    def __neg__(self) -&gt; t.Self: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Offset) -&gt; bool: ...
    def __le__(self, other: Offset) -&gt; bool: ...
    def __gt__(self, other: Offset) -&gt; bool: ...
    def __ge__(self, other: Offset) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # PYTHON CONVERSIONS
    # =========================================================================
    # __FROM__
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    @classmethod
    def from_pytzinfo(cls, tz: pydt.tzinfo) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...

    # __TO__
    def to_dict(self) -&gt; OffsetTypedDict: ...
    def to_py(self) -&gt; pydt.tzinfo: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def seconds(self) -&gt; int: ...
    @property
    def is_negative(self) -&gt; bool: ...
    @property
    def is_positive(self) -&gt; bool: ...

    # =========================================================================
    # FROM
    # =========================================================================
    @classmethod
    def utc(cls) -&gt; t.Self: ...
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_seconds(cls, seconds: int) -&gt; t.Self: ...

    # =========================================================================
    # TO
    # =========================================================================
    def to_datetime(self, timestamp: Timestamp) -&gt; DateTime: ...
    def to_timestamp(self, datetime: DateTime) -&gt; Timestamp: ...
    def to_timezone(self) -&gt; TimeZone: ...

    # =========================================================================
    # ARITHMETIC METHODS
    # =========================================================================
    @t.overload
    def add(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def add(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta, /
    ) -&gt; t.Self: ...
    @t.overload
    def sub(
        self,
        other: None = None,
        /,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
        nanoseconds: int = 0,
    ) -&gt; t.Self: ...
    def saturating_add(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...
    def saturating_sub(
        self, other: Duration | SignedDuration | TimeSpan | pydt.timedelta
    ) -&gt; t.Self: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def duration_since(self, other: Offset) -&gt; SignedDuration: ...
    def duration_until(self, other: Offset) -&gt; SignedDuration: ...
    def isoformat(self) -&gt; str: ...
    def negate(self) -&gt; t.Self: ...
    def since(self, other: t.Self) -&gt; TimeSpan: ...
    def until(self, other: t.Self) -&gt; TimeSpan: ...
    def round(
        self,
        smallest: _OffsetRoundSmallest = "second",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; t.Self: ...
    def _round(self, options: OffsetRound) -&gt; t.Self: ...


# =============================================================================
# DIFFERENCE
# =============================================================================
_TObj = t.TypeVar("_TObj", Date, DateTime, Time, Timestamp, ZonedDateTime)


@t.type_check_only
class _Difference(t.Generic[_TObj, _TDict]):
    def __init__(
        self,
        obj: _TObj,
        *,
        smallest: JiffUnit,
        largest: JiffUnit | None = None,
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    @property
    def smallest(self) -&gt; JiffUnit: ...
    @property
    def largest(self) -&gt; JiffUnit | None: ...
    @property
    def mode(self) -&gt; JiffRoundMode: ...
    @property
    def increment(self) -&gt; int: ...
    def _smallest(self, unit: JiffUnit) -&gt; t.Self: ...
    def _largest(self, unit: JiffUnit) -&gt; t.Self: ...
    def _mode(self, mode: JiffRoundMode) -&gt; t.Self: ...
    def _increment(self, increment: int) -&gt; t.Self: ...
    def to_dict(self) -&gt; _TDict: ...


@t.final
class DateDifference(_Difference[Date, DateDifferenceTypedDict]):
    def __init__(
        self,
        obj: Date,
        *,
        smallest: JiffUnit = "day",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def date(self) -&gt; Date: ...


@t.final
class DateTimeDifference(_Difference[DateTime, DateTimeDifferenceTypedDict]):
    def __init__(
        self,
        obj: DateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def datetime(self) -&gt; DateTime: ...


@t.final
class TimeDifference(_Difference[Time, TimeDifferenceTypedDict]):
    def __init__(
        self,
        obj: Time,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def time(self) -&gt; Time: ...


@t.final
class TimestampDifference(_Difference[Timestamp, TimestampDifferenceTypedDict]):
    def __init__(
        self,
        obj: Timestamp,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def timestamp(self) -&gt; Timestamp: ...


@t.final
class ZonedDateTimeDifference(
    _Difference[ZonedDateTime, ZonedDateTimeDifferenceTypedDict]
):
    def __init__(
        self,
        obj: ZonedDateTime,
        *,
        smallest: JiffUnit = "nanosecond",
        largest: JiffUnit | None = None,
        mode: JiffRoundMode = "trunc",
        increment: int = 1,
    ) -&gt; None: ...
    @property
    def zoned(self) -&gt; ZonedDateTime: ...


# =============================================================================
# ROUND
# =============================================================================

_TSmallest = t.TypeVar(
    "_TSmallest",
)


@t.type_check_only
class _Round(t.Generic[_TSmallest, _TDict]):
    def __eq__(self, other: object) -&gt; bool: ...
    def _mode(self, mode: JiffRoundMode) -&gt; t.Self: ...
    def _smallest(self, smallest: _TSmallest) -&gt; t.Self: ...
    def _increment(self, increment: int) -&gt; t.Self: ...
    @property
    def smallest(self) -&gt; _TSmallest: ...
    @property
    def mode(self) -&gt; JiffRoundMode: ...
    @property
    def increment(self) -&gt; int: ...
    def replace(
        self,
        smallest: _TSmallest | None = None,
        mode: JiffRoundMode | None = None,
        increment: int | None = None,
    ) -&gt; t.Self: ...
    def to_dict(self) -&gt; _TDict: ...


@t.final
class DateTimeRound(_Round[_DateTimeRoundSmallest, DateTimeRoundTypedDict]):
    def __init__(
        self,
        smallest: _DateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: DateTime) -&gt; DateTime: ...


@t.final
class SignedDurationRound(
    _Round[_SignedDurationRoundSmallest, SignedDurationRoundTypedDict]
):
    def __init__(
        self,
        smallest: _SignedDurationRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: SignedDuration) -&gt; SignedDuration: ...


@t.final
class TimeRound(_Round[_TimeRoundSmallest, TimeRoundTypedDict]):
    def __init__(
        self,
        smallest: _TimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: Time) -&gt; Time: ...


@t.final
class TimestampRound(_Round[_TimestampRoundSmallest, TimestampRoundTypedDict]):
    def __init__(
        self,
        smallest: _TimestampRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: Timestamp) -&gt; Timestamp: ...


@t.final
class ZonedDateTimeRound(
    _Round[_ZonedDateTimeRoundSmallest, ZonedDateTimeRoundTypedDict]
):
    def __init__(
        self,
        smallest: _ZonedDateTimeRoundSmallest = "nanosecond",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: ZonedDateTime) -&gt; ZonedDateTime: ...


@t.final
class OffsetRound(_Round[_OffsetRoundSmallest, OffsetRoundTypedDict]):
    def __init__(
        self,
        smallest: _OffsetRoundSmallest = "second",
        *,
        mode: JiffRoundMode = "half-expand",
        increment: int = 1,
    ) -&gt; None: ...
    def round(self, ob: Offset) -&gt; Offset: ...


@t.type_check_only
class JiffSeries(t.Protocol[_T]):
    def __iter__(self) -&gt; JiffSeries[_T]: ...
    def __next__(self) -&gt; _T: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...
    def take_until(self, value: _T) -&gt; list[_T]: ...
    def collect(self) -&gt; list[_T]: ...


def date(year: int, month: int, day: int) -&gt; Date: ...
def time(
    hour: int = 0, minute: int = 0, second: int = 0, nanosecond: int = 0
) -&gt; Time: ...
def datetime(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
) -&gt; DateTime: ...
def zoned(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    nanosecond: int = 0,
    tz: TimezoneName | None = None,
) -&gt; ZonedDateTime: ...
def timespan(
    *,
    years: int = 0,
    months: int = 0,
    weeks: int = 0,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0,
    milliseconds: int = 0,
    microseconds: int = 0,
    nanoseconds: int = 0,
) -&gt; TimeSpan: ...
def offset(hours: int) -&gt; Offset: ...
def now() -&gt; ZonedDateTime: ...
def utcnow() -&gt; ZonedDateTime: ...


# =============================================================================
# TIMEZONE-DATABASE
# =============================================================================
@t.final
class TimeZoneDatabase:
    def __init__(self) -&gt; None:
        """Defaults to using the `self.from_env`"""

    @t.overload
    def get(self, name: TimezoneName, err: t.Literal[False]) -&gt; TimeZone | None:
        """Returns TimeZone or None if the timezone is not found"""

    @t.overload
    def get(self, name: TimezoneName, err: t.Literal[True] = True) -&gt; TimeZone:
        """Returns TimeZone, if not found raises a ValueError"""

    def available(self) -&gt; list[str]: ...
    def __getitem__(self, name: TimezoneName) -&gt; TimeZone: ...
    def __len__(self) -&gt; int: ...
    def is_definitively_empty(self) -&gt; bool: ...
    @classmethod
    def from_env(cls) -&gt; t.Self: ...
    @classmethod
    def from_dir(cls, path: str) -&gt; t.Self: ...
    @classmethod
    def from_concatenated_path(cls, path: str) -&gt; t.Self: ...
    @classmethod
    def bundled(cls) -&gt; t.Self: ...
</code></pre>
<h2 id="ry.ryo3._jiff_tz"><code>ry.ryo3._jiff_tz</code></h2>

<pre><code class="language-python">from typing import Literal, TypeAlias

TimezoneDbName: TypeAlias = Literal[
    "Africa/Abidjan",
    "Africa/Accra",
    "Africa/Addis_Ababa",
    "Africa/Algiers",
    "Africa/Asmara",
    "Africa/Asmera",
    "Africa/Bamako",
    "Africa/Bangui",
    "Africa/Banjul",
    "Africa/Bissau",
    "Africa/Blantyre",
    "Africa/Brazzaville",
    "Africa/Bujumbura",
    "Africa/Cairo",
    "Africa/Casablanca",
    "Africa/Ceuta",
    "Africa/Conakry",
    "Africa/Dakar",
    "Africa/Dar_es_Salaam",
    "Africa/Djibouti",
    "Africa/Douala",
    "Africa/El_Aaiun",
    "Africa/Freetown",
    "Africa/Gaborone",
    "Africa/Harare",
    "Africa/Johannesburg",
    "Africa/Juba",
    "Africa/Kampala",
    "Africa/Khartoum",
    "Africa/Kigali",
    "Africa/Kinshasa",
    "Africa/Lagos",
    "Africa/Libreville",
    "Africa/Lome",
    "Africa/Luanda",
    "Africa/Lubumbashi",
    "Africa/Lusaka",
    "Africa/Malabo",
    "Africa/Maputo",
    "Africa/Maseru",
    "Africa/Mbabane",
    "Africa/Mogadishu",
    "Africa/Monrovia",
    "Africa/Nairobi",
    "Africa/Ndjamena",
    "Africa/Niamey",
    "Africa/Nouakchott",
    "Africa/Ouagadougou",
    "Africa/Porto-Novo",
    "Africa/Sao_Tome",
    "Africa/Timbuktu",
    "Africa/Tripoli",
    "Africa/Tunis",
    "Africa/Windhoek",
    "America/Adak",
    "America/Anchorage",
    "America/Anguilla",
    "America/Antigua",
    "America/Araguaina",
    "America/Argentina/Buenos_Aires",
    "America/Argentina/Catamarca",
    "America/Argentina/ComodRivadavia",
    "America/Argentina/Cordoba",
    "America/Argentina/Jujuy",
    "America/Argentina/La_Rioja",
    "America/Argentina/Mendoza",
    "America/Argentina/Rio_Gallegos",
    "America/Argentina/Salta",
    "America/Argentina/San_Juan",
    "America/Argentina/San_Luis",
    "America/Argentina/Tucuman",
    "America/Argentina/Ushuaia",
    "America/Aruba",
    "America/Asuncion",
    "America/Atikokan",
    "America/Atka",
    "America/Bahia",
    "America/Bahia_Banderas",
    "America/Barbados",
    "America/Belem",
    "America/Belize",
    "America/Blanc-Sablon",
    "America/Boa_Vista",
    "America/Bogota",
    "America/Boise",
    "America/Buenos_Aires",
    "America/Cambridge_Bay",
    "America/Campo_Grande",
    "America/Cancun",
    "America/Caracas",
    "America/Catamarca",
    "America/Cayenne",
    "America/Cayman",
    "America/Chicago",
    "America/Chihuahua",
    "America/Ciudad_Juarez",
    "America/Coral_Harbour",
    "America/Cordoba",
    "America/Costa_Rica",
    "America/Coyhaique",
    "America/Creston",
    "America/Cuiaba",
    "America/Curacao",
    "America/Danmarkshavn",
    "America/Dawson",
    "America/Dawson_Creek",
    "America/Denver",
    "America/Detroit",
    "America/Dominica",
    "America/Edmonton",
    "America/Eirunepe",
    "America/El_Salvador",
    "America/Ensenada",
    "America/Fort_Nelson",
    "America/Fort_Wayne",
    "America/Fortaleza",
    "America/Glace_Bay",
    "America/Godthab",
    "America/Goose_Bay",
    "America/Grand_Turk",
    "America/Grenada",
    "America/Guadeloupe",
    "America/Guatemala",
    "America/Guayaquil",
    "America/Guyana",
    "America/Halifax",
    "America/Havana",
    "America/Hermosillo",
    "America/Indiana/Indianapolis",
    "America/Indiana/Knox",
    "America/Indiana/Marengo",
    "America/Indiana/Petersburg",
    "America/Indiana/Tell_City",
    "America/Indiana/Vevay",
    "America/Indiana/Vincennes",
    "America/Indiana/Winamac",
    "America/Indianapolis",
    "America/Inuvik",
    "America/Iqaluit",
    "America/Jamaica",
    "America/Jujuy",
    "America/Juneau",
    "America/Kentucky/Louisville",
    "America/Kentucky/Monticello",
    "America/Knox_IN",
    "America/Kralendijk",
    "America/La_Paz",
    "America/Lima",
    "America/Los_Angeles",
    "America/Louisville",
    "America/Lower_Princes",
    "America/Maceio",
    "America/Managua",
    "America/Manaus",
    "America/Marigot",
    "America/Martinique",
    "America/Matamoros",
    "America/Mazatlan",
    "America/Mendoza",
    "America/Menominee",
    "America/Merida",
    "America/Metlakatla",
    "America/Mexico_City",
    "America/Miquelon",
    "America/Moncton",
    "America/Monterrey",
    "America/Montevideo",
    "America/Montreal",
    "America/Montserrat",
    "America/Nassau",
    "America/New_York",
    "America/Nipigon",
    "America/Nome",
    "America/Noronha",
    "America/North_Dakota/Beulah",
    "America/North_Dakota/Center",
    "America/North_Dakota/New_Salem",
    "America/Nuuk",
    "America/Ojinaga",
    "America/Panama",
    "America/Pangnirtung",
    "America/Paramaribo",
    "America/Phoenix",
    "America/Port-au-Prince",
    "America/Port_of_Spain",
    "America/Porto_Acre",
    "America/Porto_Velho",
    "America/Puerto_Rico",
    "America/Punta_Arenas",
    "America/Rainy_River",
    "America/Rankin_Inlet",
    "America/Recife",
    "America/Regina",
    "America/Resolute",
    "America/Rio_Branco",
    "America/Rosario",
    "America/Santa_Isabel",
    "America/Santarem",
    "America/Santiago",
    "America/Santo_Domingo",
    "America/Sao_Paulo",
    "America/Scoresbysund",
    "America/Shiprock",
    "America/Sitka",
    "America/St_Barthelemy",
    "America/St_Johns",
    "America/St_Kitts",
    "America/St_Lucia",
    "America/St_Thomas",
    "America/St_Vincent",
    "America/Swift_Current",
    "America/Tegucigalpa",
    "America/Thule",
    "America/Thunder_Bay",
    "America/Tijuana",
    "America/Toronto",
    "America/Tortola",
    "America/Vancouver",
    "America/Virgin",
    "America/Whitehorse",
    "America/Winnipeg",
    "America/Yakutat",
    "America/Yellowknife",
    "Antarctica/Casey",
    "Antarctica/Davis",
    "Antarctica/DumontDUrville",
    "Antarctica/Macquarie",
    "Antarctica/Mawson",
    "Antarctica/McMurdo",
    "Antarctica/Palmer",
    "Antarctica/Rothera",
    "Antarctica/South_Pole",
    "Antarctica/Syowa",
    "Antarctica/Troll",
    "Antarctica/Vostok",
    "Arctic/Longyearbyen",
    "Asia/Aden",
    "Asia/Almaty",
    "Asia/Amman",
    "Asia/Anadyr",
    "Asia/Aqtau",
    "Asia/Aqtobe",
    "Asia/Ashgabat",
    "Asia/Ashkhabad",
    "Asia/Atyrau",
    "Asia/Baghdad",
    "Asia/Bahrain",
    "Asia/Baku",
    "Asia/Bangkok",
    "Asia/Barnaul",
    "Asia/Beirut",
    "Asia/Bishkek",
    "Asia/Brunei",
    "Asia/Calcutta",
    "Asia/Chita",
    "Asia/Choibalsan",
    "Asia/Chongqing",
    "Asia/Chungking",
    "Asia/Colombo",
    "Asia/Dacca",
    "Asia/Damascus",
    "Asia/Dhaka",
    "Asia/Dili",
    "Asia/Dubai",
    "Asia/Dushanbe",
    "Asia/Famagusta",
    "Asia/Gaza",
    "Asia/Harbin",
    "Asia/Hebron",
    "Asia/Ho_Chi_Minh",
    "Asia/Hong_Kong",
    "Asia/Hovd",
    "Asia/Irkutsk",
    "Asia/Istanbul",
    "Asia/Jakarta",
    "Asia/Jayapura",
    "Asia/Jerusalem",
    "Asia/Kabul",
    "Asia/Kamchatka",
    "Asia/Karachi",
    "Asia/Kashgar",
    "Asia/Kathmandu",
    "Asia/Katmandu",
    "Asia/Khandyga",
    "Asia/Kolkata",
    "Asia/Krasnoyarsk",
    "Asia/Kuala_Lumpur",
    "Asia/Kuching",
    "Asia/Kuwait",
    "Asia/Macao",
    "Asia/Macau",
    "Asia/Magadan",
    "Asia/Makassar",
    "Asia/Manila",
    "Asia/Muscat",
    "Asia/Nicosia",
    "Asia/Novokuznetsk",
    "Asia/Novosibirsk",
    "Asia/Omsk",
    "Asia/Oral",
    "Asia/Phnom_Penh",
    "Asia/Pontianak",
    "Asia/Pyongyang",
    "Asia/Qatar",
    "Asia/Qostanay",
    "Asia/Qyzylorda",
    "Asia/Rangoon",
    "Asia/Riyadh",
    "Asia/Saigon",
    "Asia/Sakhalin",
    "Asia/Samarkand",
    "Asia/Seoul",
    "Asia/Shanghai",
    "Asia/Singapore",
    "Asia/Srednekolymsk",
    "Asia/Taipei",
    "Asia/Tashkent",
    "Asia/Tbilisi",
    "Asia/Tehran",
    "Asia/Tel_Aviv",
    "Asia/Thimbu",
    "Asia/Thimphu",
    "Asia/Tokyo",
    "Asia/Tomsk",
    "Asia/Ujung_Pandang",
    "Asia/Ulaanbaatar",
    "Asia/Ulan_Bator",
    "Asia/Urumqi",
    "Asia/Ust-Nera",
    "Asia/Vientiane",
    "Asia/Vladivostok",
    "Asia/Yakutsk",
    "Asia/Yangon",
    "Asia/Yekaterinburg",
    "Asia/Yerevan",
    "Atlantic/Azores",
    "Atlantic/Bermuda",
    "Atlantic/Canary",
    "Atlantic/Cape_Verde",
    "Atlantic/Faeroe",
    "Atlantic/Faroe",
    "Atlantic/Jan_Mayen",
    "Atlantic/Madeira",
    "Atlantic/Reykjavik",
    "Atlantic/South_Georgia",
    "Atlantic/St_Helena",
    "Atlantic/Stanley",
    "Australia/ACT",
    "Australia/Adelaide",
    "Australia/Brisbane",
    "Australia/Broken_Hill",
    "Australia/Canberra",
    "Australia/Currie",
    "Australia/Darwin",
    "Australia/Eucla",
    "Australia/Hobart",
    "Australia/LHI",
    "Australia/Lindeman",
    "Australia/Lord_Howe",
    "Australia/Melbourne",
    "Australia/North",
    "Australia/NSW",
    "Australia/Perth",
    "Australia/Queensland",
    "Australia/South",
    "Australia/Sydney",
    "Australia/Tasmania",
    "Australia/Victoria",
    "Australia/West",
    "Australia/Yancowinna",
    "Brazil/Acre",
    "Brazil/DeNoronha",
    "Brazil/East",
    "Brazil/West",
    "Canada/Atlantic",
    "Canada/Central",
    "Canada/Eastern",
    "Canada/Mountain",
    "Canada/Newfoundland",
    "Canada/Pacific",
    "Canada/Saskatchewan",
    "Canada/Yukon",
    "CET",
    "Chile/Continental",
    "Chile/EasterIsland",
    "CST6CDT",
    "Cuba",
    "EET",
    "Egypt",
    "Eire",
    "EST",
    "EST5EDT",
    "Etc/GMT",
    "Etc/GMT+0",
    "Etc/GMT+1",
    "Etc/GMT+10",
    "Etc/GMT+11",
    "Etc/GMT+12",
    "Etc/GMT+2",
    "Etc/GMT+3",
    "Etc/GMT+4",
    "Etc/GMT+5",
    "Etc/GMT+6",
    "Etc/GMT+7",
    "Etc/GMT+8",
    "Etc/GMT+9",
    "Etc/GMT-0",
    "Etc/GMT-1",
    "Etc/GMT-10",
    "Etc/GMT-11",
    "Etc/GMT-12",
    "Etc/GMT-13",
    "Etc/GMT-14",
    "Etc/GMT-2",
    "Etc/GMT-3",
    "Etc/GMT-4",
    "Etc/GMT-5",
    "Etc/GMT-6",
    "Etc/GMT-7",
    "Etc/GMT-8",
    "Etc/GMT-9",
    "Etc/GMT0",
    "Etc/Greenwich",
    "Etc/UCT",
    "Etc/Universal",
    "Etc/UTC",
    "Etc/Zulu",
    "Europe/Amsterdam",
    "Europe/Andorra",
    "Europe/Astrakhan",
    "Europe/Athens",
    "Europe/Belfast",
    "Europe/Belgrade",
    "Europe/Berlin",
    "Europe/Bratislava",
    "Europe/Brussels",
    "Europe/Bucharest",
    "Europe/Budapest",
    "Europe/Busingen",
    "Europe/Chisinau",
    "Europe/Copenhagen",
    "Europe/Dublin",
    "Europe/Gibraltar",
    "Europe/Guernsey",
    "Europe/Helsinki",
    "Europe/Isle_of_Man",
    "Europe/Istanbul",
    "Europe/Jersey",
    "Europe/Kaliningrad",
    "Europe/Kiev",
    "Europe/Kirov",
    "Europe/Kyiv",
    "Europe/Lisbon",
    "Europe/Ljubljana",
    "Europe/London",
    "Europe/Luxembourg",
    "Europe/Madrid",
    "Europe/Malta",
    "Europe/Mariehamn",
    "Europe/Minsk",
    "Europe/Monaco",
    "Europe/Moscow",
    "Europe/Nicosia",
    "Europe/Oslo",
    "Europe/Paris",
    "Europe/Podgorica",
    "Europe/Prague",
    "Europe/Riga",
    "Europe/Rome",
    "Europe/Samara",
    "Europe/San_Marino",
    "Europe/Sarajevo",
    "Europe/Saratov",
    "Europe/Simferopol",
    "Europe/Skopje",
    "Europe/Sofia",
    "Europe/Stockholm",
    "Europe/Tallinn",
    "Europe/Tirane",
    "Europe/Tiraspol",
    "Europe/Ulyanovsk",
    "Europe/Uzhgorod",
    "Europe/Vaduz",
    "Europe/Vatican",
    "Europe/Vienna",
    "Europe/Vilnius",
    "Europe/Volgograd",
    "Europe/Warsaw",
    "Europe/Zagreb",
    "Europe/Zaporozhye",
    "Europe/Zurich",
    "Factory",
    "GB",
    "GB-Eire",
    "GMT",
    "GMT+0",
    "GMT-0",
    "GMT0",
    "Greenwich",
    "Hongkong",
    "HST",
    "Iceland",
    "Indian/Antananarivo",
    "Indian/Chagos",
    "Indian/Christmas",
    "Indian/Cocos",
    "Indian/Comoro",
    "Indian/Kerguelen",
    "Indian/Mahe",
    "Indian/Maldives",
    "Indian/Mauritius",
    "Indian/Mayotte",
    "Indian/Reunion",
    "Iran",
    "Israel",
    "Jamaica",
    "Japan",
    "Kwajalein",
    "Libya",
    "MET",
    "Mexico/BajaNorte",
    "Mexico/BajaSur",
    "Mexico/General",
    "MST",
    "MST7MDT",
    "Navajo",
    "NZ",
    "NZ-CHAT",
    "Pacific/Apia",
    "Pacific/Auckland",
    "Pacific/Bougainville",
    "Pacific/Chatham",
    "Pacific/Chuuk",
    "Pacific/Easter",
    "Pacific/Efate",
    "Pacific/Enderbury",
    "Pacific/Fakaofo",
    "Pacific/Fiji",
    "Pacific/Funafuti",
    "Pacific/Galapagos",
    "Pacific/Gambier",
    "Pacific/Guadalcanal",
    "Pacific/Guam",
    "Pacific/Honolulu",
    "Pacific/Johnston",
    "Pacific/Kanton",
    "Pacific/Kiritimati",
    "Pacific/Kosrae",
    "Pacific/Kwajalein",
    "Pacific/Majuro",
    "Pacific/Marquesas",
    "Pacific/Midway",
    "Pacific/Nauru",
    "Pacific/Niue",
    "Pacific/Norfolk",
    "Pacific/Noumea",
    "Pacific/Pago_Pago",
    "Pacific/Palau",
    "Pacific/Pitcairn",
    "Pacific/Pohnpei",
    "Pacific/Ponape",
    "Pacific/Port_Moresby",
    "Pacific/Rarotonga",
    "Pacific/Saipan",
    "Pacific/Samoa",
    "Pacific/Tahiti",
    "Pacific/Tarawa",
    "Pacific/Tongatapu",
    "Pacific/Truk",
    "Pacific/Wake",
    "Pacific/Wallis",
    "Pacific/Yap",
    "Poland",
    "Portugal",
    "PRC",
    "PST8PDT",
    "ROC",
    "ROK",
    "Singapore",
    "Turkey",
    "UCT",
    "Universal",
    "US/Alaska",
    "US/Aleutian",
    "US/Arizona",
    "US/Central",
    "US/East-Indiana",
    "US/Eastern",
    "US/Hawaii",
    "US/Indiana-Starke",
    "US/Michigan",
    "US/Mountain",
    "US/Pacific",
    "US/Samoa",
    "UTC",
    "W-SU",
    "WET",
    "Zulu",
]
</code></pre>
<h2 id="ry.ryo3._jiter"><code>ry.ryo3._jiter</code></h2>

<pre><code class="language-python">import typing as t
from os import PathLike

from ry._types import Buffer, Unpack

# =============================================================================
# JSON
# =============================================================================
JsonPrimitive: t.TypeAlias = None | bool | int | float | str
JsonValue: t.TypeAlias = (
    JsonPrimitive
    | dict[str, JsonPrimitive | JsonValue]
    | list[JsonPrimitive | JsonValue]
)


class JsonParseKwargs(t.TypedDict, total=False):
    allow_inf_nan: bool
    """Allow parsing of `Infinity`, `-Infinity`, `NaN` ~ default: False"""
    cache_mode: t.Literal[True, False, "all", "keys", "none"]
    """Cache mode for JSON parsing ~ default: `all` """
    partial_mode: t.Literal[True, False, "off", "on", "trailing-strings"]
    """Partial mode for JSON parsing ~ default: False"""
    catch_duplicate_keys: bool
    """Catch duplicate keys in JSON objects ~ default: False"""


def parse_json(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse_jsonl(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; list[JsonValue]: ...
def read_json(
    p: str | PathLike[str],
    /,
    lines: bool = False,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def json_cache_clear() -&gt; None: ...
def json_cache_usage() -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._memchr"><code>ry.ryo3._memchr</code></h2>

<pre><code class="language-python">"""ryo3-memchr types"""

from typing import TypeAlias

from ry._types import Buffer

Byte: TypeAlias = int | bytes


def memchr(needle: Byte, haystack: Buffer) -&gt; int | None: ...
def memchr2(needle1: Byte, needle2: Byte, haystack: Buffer) -&gt; int | None: ...
def memchr3(
    needle1: Byte, needle2: Byte, needle3: Byte, haystack: Buffer
) -&gt; int | None: ...
def memrchr(needle: Byte, haystack: Buffer) -&gt; int | None: ...
def memrchr2(needle1: Byte, needle2: Byte, haystack: Buffer) -&gt; int | None: ...
def memrchr3(
    needle1: Byte, needle2: Byte, needle3: Byte, haystack: Buffer
) -&gt; int | None: ...
</code></pre>
<h2 id="ry.ryo3._quick_maths"><code>ry.ryo3._quick_maths</code></h2>

<pre><code class="language-python">"""ryo3-quick-maths types"""

import typing as t


def quick_maths() -&gt; t.Literal[3]:
    """Performs quick-maths

    Implements the algorithm for performing "quick-maths" as described by
    Big Shaq in his PHD thesis, 2017, in which he states:

    &gt; "2 plus 2 is 4, minus one that's 3, quick maths." (Big Shaq et al., 2017)

    Reference:
        https://youtu.be/3M_5oYU-IsU?t=60

    Example:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; result = ry.quick_maths()
        &gt;&gt;&gt; assert result == 3

    NOTE: THIS IS FROM MY TEMPLATE RY03-MODULE
    """
</code></pre>
<h2 id="ry.ryo3._regex"><code>ry.ryo3._regex</code></h2>

<pre><code class="language-python">"""ryo3-regex types"""

import typing as t

# =============================================================================
# Regex
# =============================================================================


@t.final
class Regex:
    def __init__(
        self,
        pattern: str,
        *,
        case_insensitive: bool = False,
        crlf: bool = False,
        dot_matches_new_line: bool = False,
        ignore_whitespace: bool = False,
        line_terminator: bytes | int | None = None,
        multi_line: bool = False,
        octal: bool = False,
        size_limit: int | None = None,
        swap_greed: bool = False,
        unicode: bool = False,
    ) -&gt; None: ...
    def is_match(self, haystack: str) -&gt; bool: ...
    def test(self, haystack: str) -&gt; bool: ...
    def find(self, haystack: str) -&gt; str | None: ...
    def find_all(self, haystack: str) -&gt; list[tuple[int, int]]: ...
    def findall(self, haystack: str) -&gt; list[tuple[int, int]]: ...
    def replace(self, haystack: str, replacement: str) -&gt; str: ...
    def replace_all(self, haystack: str, replacement: str) -&gt; str: ...
    def split(self, haystack: str) -&gt; list[str]: ...
    def splitn(self, haystack: str, n: int) -&gt; list[str]: ...
</code></pre>
<h2 id="ry.ryo3._reqwest"><code>ry.ryo3._reqwest</code></h2>

<pre><code class="language-python">import typing as t

import ry
from ry._types import Buffer, Unpack
from ry.protocols import FromStr, _Parse
from ry.ryo3._encoding_rs import Encoding
from ry.ryo3._http import Headers, HttpStatus, HttpVersionLike
from ry.ryo3._std import Duration, SocketAddr
from ry.ryo3._url import URL

_Body: t.TypeAlias = (
    Buffer
    | t.Generator[Buffer]
    | t.AsyncGenerator[Buffer]
    | t.Iterable[Buffer]
    | t.AsyncIterable[Buffer]
)
# proxy
_ProxyKw: t.TypeAlias = t.Sequence[Proxy | URL | str] | Proxy | URL | str
# resolve
_ResolveMapLike: t.TypeAlias = dict[str, t.Sequence[SocketAddr]]


class RequestKwargs(t.TypedDict, total=False):
    body: _Body | None
    headers: Headers | dict[str, str] | None
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None
    json: t.Any
    form: t.Any
    multipart: t.Any
    timeout: Duration | None
    basic_auth: tuple[str, str | None] | None
    bearer_auth: str | None
    version: HttpVersionLike | None


class ClientConfig(t.TypedDict):
    headers: Headers | None  # default: None
    cookies: bool
    user_agent: (
        str | bool | None
    )  # None/True =&gt; default ("ry/{ry.__version__}"), False =&gt; disabled
    redirect: int | None
    resolve: _ResolveMapLike | None  # default: None
    referer: bool
    proxy: list[Proxy] | Proxy | None  # default: None
    hickory_dns: bool
    connection_verbose: bool  # default: False
    # ____ TIMEOUT ____
    timeout: Duration | None  # default: None
    connect_timeout: Duration | None  # default: None
    read_timeout: Duration | None  # default: None
    # ____ COMPRESSION / CONTENT-ENCODING ____
    gzip: bool
    brotli: bool
    deflate: bool
    zstd: bool
    # ____ HTTP1 ____
    http1_only: bool
    https_only: bool
    http1_title_case_headers: bool
    http1_allow_obsolete_multiline_headers_in_responses: bool
    http1_allow_spaces_after_header_name_in_responses: bool
    http1_ignore_invalid_headers_in_responses: bool
    # ____ HTTP2 ____
    http2_prior_knowledge: bool
    http2_initial_stream_window_size: int | None
    http2_initial_connection_window_size: int | None
    http2_adaptive_window: bool
    http2_max_frame_size: int | None
    http2_max_header_list_size: int | None
    http2_keep_alive_interval: Duration | None
    http2_keep_alive_timeout: Duration | None
    http2_keep_alive_while_idle: bool
    # ____ POOL ____
    pool_idle_timeout: Duration | None
    pool_max_idle_per_host: int | None
    # ____ TCP ____
    tcp_keepalive: Duration | None
    tcp_keepalive_interval: Duration | None
    tcp_keepalive_retries: int | None
    tcp_nodelay: bool
    # ____ TLS ____
    identity: Identity | None
    tls_certs_merge: list[Certificate] | None
    tls_certs_only: list[Certificate] | None
    tls_crls_only: list[CertificateRevocationList] | None
    tls_info: bool
    tls_sni: bool
    tls_version_max: (
        t.Literal["1.0", "1.1", "1.2", "1.3"] | None
    )  # default: None
    tls_version_min: (
        t.Literal["1.0", "1.1", "1.2", "1.3"] | None
    )  # default: None
    tls_danger_accept_invalid_certs: bool  # default: False
    tls_danger_accept_invalid_hostnames: bool  # default: False
    # __ UNSTABLE __
    _tls_cached_native_certs: bool  # default: False


@t.final
class HttpClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | Headers | None = None,
        cookies: bool = False,
        user_agent: str | bool | None = None,
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        redirect: int | None = 10,
        resolve: _ResolveMapLike | None = None,
        referer: bool = True,
        connection_verbose: bool = False,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
        zstd: bool = True,
        hickory_dns: bool = True,
        http1_only: bool = False,
        https_only: bool = False,
        http1_title_case_headers: bool = False,
        http1_allow_obsolete_multiline_headers_in_responses: bool = False,
        http1_allow_spaces_after_header_name_in_responses: bool = False,
        http1_ignore_invalid_headers_in_responses: bool = False,
        http2_prior_knowledge: bool = False,
        http2_initial_stream_window_size: int | None = None,
        http2_initial_connection_window_size: int | None = None,
        http2_adaptive_window: bool = False,
        http2_max_frame_size: int | None = None,
        http2_max_header_list_size: int | None = None,
        http2_keep_alive_interval: Duration | None = None,
        http2_keep_alive_timeout: Duration | None = None,
        http2_keep_alive_while_idle: bool = False,
        pool_idle_timeout: Duration | None = ...,  # 90 seconds
        pool_max_idle_per_host: int | None = ...,  # usize::MAX
        tcp_keepalive: Duration | None = ...,  # 15 seconds
        tcp_keepalive_interval: Duration | None = ...,  # 15 seconds
        tcp_keepalive_retries: int | None = 3,
        tcp_nodelay: bool = True,
        identity: Identity | None = None,
        tls_certs_only: list[Certificate] | None = None,
        tls_certs_merge: list[Certificate] | None = None,
        tls_crls_only: list[CertificateRevocationList] | None = None,
        tls_version_min: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_version_max: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_info: bool = False,
        tls_sni: bool = True,
        tls_danger_accept_invalid_certs: bool = False,
        tls_danger_accept_invalid_hostnames: bool = False,
        proxy: _ProxyKw | None = None,
        _tls_cached_native_certs: bool = False,
    ) -&gt; None: ...
    def config(self) -&gt; ClientConfig: ...
    async def get(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def post(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def put(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def delete(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def patch(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def options(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def head(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    def fetch_sync(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    async def __call__(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...


@t.final
class Client:
    """experimental client using the `pyo3/experimental-async` feature"""

    def __init__(
        self,
        *,
        headers: dict[str, str] | Headers | None = None,
        cookies: bool = False,
        user_agent: str | bool | None = None,
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        redirect: int | None = 10,
        resolve: _ResolveMapLike | None = None,
        referer: bool = True,
        connection_verbose: bool = False,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
        zstd: bool = True,
        hickory_dns: bool = True,
        http1_only: bool = False,
        https_only: bool = False,
        http1_title_case_headers: bool = False,
        http1_allow_obsolete_multiline_headers_in_responses: bool = False,
        http1_allow_spaces_after_header_name_in_responses: bool = False,
        http1_ignore_invalid_headers_in_responses: bool = False,
        http2_prior_knowledge: bool = False,
        http2_initial_stream_window_size: int | None = None,
        http2_initial_connection_window_size: int | None = None,
        http2_adaptive_window: bool = False,
        http2_max_frame_size: int | None = None,
        http2_max_header_list_size: int | None = None,
        http2_keep_alive_interval: Duration | None = None,
        http2_keep_alive_timeout: Duration | None = None,
        http2_keep_alive_while_idle: bool = False,
        pool_idle_timeout: Duration | None = ...,  # 90 seconds
        pool_max_idle_per_host: int | None = ...,  # usize::MAX
        tcp_keepalive: Duration | None = ...,  # 15 seconds
        tcp_keepalive_interval: Duration | None = ...,  # 15 seconds
        tcp_keepalive_retries: int | None = 3,
        tcp_nodelay: bool = True,
        identity: Identity | None = None,
        tls_certs_only: list[Certificate] | None = None,
        tls_certs_merge: list[Certificate] | None = None,
        tls_crls_only: list[CertificateRevocationList] | None = None,
        tls_version_min: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_version_max: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_info: bool = False,
        tls_sni: bool = True,
        tls_danger_accept_invalid_certs: bool = False,
        tls_danger_accept_invalid_hostnames: bool = False,
        proxy: _ProxyKw | None = None,
        _tls_cached_native_certs: bool = False,
    ) -&gt; None: ...
    def config(self) -&gt; ClientConfig: ...
    async def get(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; AsyncResponse: ...
    async def post(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; AsyncResponse: ...
    async def put(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; AsyncResponse: ...
    async def delete(
        self, url: URL | str, **kwargs: Unpack[RequestKwargs]
    ) -&gt; AsyncResponse: ...
    async def patch(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def options(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def head(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    async def fetch(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...
    def fetch_sync(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    async def __call__(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; Response: ...


@t.final
class BlockingClient:
    def __init__(
        self,
        *,
        headers: dict[str, str] | Headers | None = None,
        cookies: bool = False,
        user_agent: str | bool | None = None,
        timeout: Duration | None = None,
        connect_timeout: Duration | None = None,
        read_timeout: Duration | None = None,
        redirect: int | None = 10,
        resolve: _ResolveMapLike | None = None,
        referer: bool = True,
        connection_verbose: bool = False,
        gzip: bool = True,
        brotli: bool = True,
        deflate: bool = True,
        zstd: bool = True,
        hickory_dns: bool = True,
        http1_only: bool = False,
        https_only: bool = False,
        http1_title_case_headers: bool = False,
        http1_allow_obsolete_multiline_headers_in_responses: bool = False,
        http1_allow_spaces_after_header_name_in_responses: bool = False,
        http1_ignore_invalid_headers_in_responses: bool = False,
        http2_prior_knowledge: bool = False,
        http2_initial_stream_window_size: int | None = None,
        http2_initial_connection_window_size: int | None = None,
        http2_adaptive_window: bool = False,
        http2_max_frame_size: int | None = None,
        http2_max_header_list_size: int | None = None,
        http2_keep_alive_interval: Duration | None = None,
        http2_keep_alive_timeout: Duration | None = None,
        http2_keep_alive_while_idle: bool = False,
        pool_idle_timeout: Duration | None = ...,  # 90 seconds
        pool_max_idle_per_host: int | None = ...,  # usize::MAX
        tcp_keepalive: Duration | None = ...,  # 15 seconds
        tcp_keepalive_interval: Duration | None = ...,  # 15 seconds
        tcp_keepalive_retries: int | None = 3,
        tcp_nodelay: bool = True,
        identity: Identity | None = None,
        tls_certs_only: list[Certificate] | None = None,
        tls_certs_merge: list[Certificate] | None = None,
        tls_crls_only: list[CertificateRevocationList] | None = None,
        tls_version_min: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_version_max: t.Literal["1.0", "1.1", "1.2", "1.3"] | None = None,
        tls_info: bool = False,
        tls_sni: bool = True,
        tls_danger_accept_invalid_certs: bool = False,
        tls_danger_accept_invalid_hostnames: bool = False,
        proxy: _ProxyKw | None = None,
        _tls_cached_native_certs: bool = False,
    ) -&gt; None: ...
    def config(self) -&gt; ClientConfig: ...
    def get(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def post(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def put(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def delete(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def patch(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def options(
        self, url: URL | str, **kwargs: Unpack[RequestKwargs]
    ) -&gt; BlockingResponse: ...
    def head(
        self,
        url: URL | str,
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def fetch(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...
    def __call__(
        self,
        url: URL | str,
        *,
        method: str = "GET",
        **kwargs: Unpack[RequestKwargs],
    ) -&gt; BlockingResponse: ...


@t.final
class ReqwestError(Exception):
    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None: ...
    def __dbg__(self) -&gt; str: ...
    def is_body(self) -&gt; bool: ...
    def is_builder(self) -&gt; bool: ...
    def is_connect(self) -&gt; bool: ...
    def is_decode(self) -&gt; bool: ...
    def is_redirect(self) -&gt; bool: ...
    def is_request(self) -&gt; bool: ...
    def is_status(self) -&gt; bool: ...
    def is_timeout(self) -&gt; bool: ...
    @property
    def status(self) -&gt; HttpStatus | None: ...
    def url(self) -&gt; URL | None: ...
    def without_url(self) -&gt; None: ...
    def with_url(self, url: URL) -&gt; ReqwestError: ...


@t.final
class Response:
    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def headers(self) -&gt; Headers: ...
    async def text(self, *, encoding: Encoding = "utf-8") -&gt; str: ...
    async def text_with_charset(self, encoding: Encoding) -&gt; str: ...
    async def json(
        self,
        *,
        allow_inf_nan: bool = False,
        cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
        partial_mode: t.Literal[
            True, False, "off", "on", "trailing-strings"
        ] = False,
        catch_duplicate_keys: bool = False,
    ) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(
        self, min_read_size: int = 0, /
    ) -&gt; ResponseStream: ...  # min_read_size=0 -&gt; None
    def stream(
        self, min_read_size: int = 0, /
    ) -&gt; ResponseStream: ...  # min_read_size=0 -&gt; None
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def redirected(self) -&gt; bool: ...
    @property
    def content_length(self) -&gt; int | None: ...
    @property
    def content_encoding(self) -&gt; str | None: ...
    @property
    def cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def set_cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def body_used(self) -&gt; bool:
        """True if the body has been consumed"""

    @property
    def ok(self) -&gt; bool:
        """True if the status is a success (2xx)"""

    @property
    def remote_addr(self) -&gt; SocketAddr | None: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    def __bool__(self) -&gt; bool:
        """True if the status is a success (2xx)"""


@t.final
class AsyncResponse:
    """'experimental-async' response type"""

    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def headers(self) -&gt; Headers: ...
    async def text(self, *, encoding: Encoding = "utf-8") -&gt; str: ...
    async def text_with_charset(self, encoding: Encoding) -&gt; str: ...
    async def json(
        self,
        *,
        allow_inf_nan: bool = False,
        cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
        partial_mode: t.Literal[
            True, False, "off", "on", "trailing-strings"
        ] = False,
        catch_duplicate_keys: bool = False,
    ) -&gt; t.Any: ...
    async def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(
        self, min_read_size: int = 0, /
    ) -&gt; _AsyncResponseStream: ...  # min_read_size=0 -&gt; None
    def stream(
        self, min_read_size: int = 0, /
    ) -&gt; _AsyncResponseStream: ...  # min_read_size=0 -&gt; None
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def redirected(self) -&gt; bool: ...
    @property
    def content_length(self) -&gt; int | None: ...
    @property
    def content_encoding(self) -&gt; str | None: ...
    @property
    def cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def set_cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def body_used(self) -&gt; bool:
        """True if the body has been consumed"""

    @property
    def ok(self) -&gt; bool:
        """True if the status is a success (2xx)"""

    @property
    def remote_addr(self) -&gt; SocketAddr | None: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    def __bool__(self) -&gt; bool:
        """True if the status is a success (2xx)"""


@t.final
class BlockingResponse:
    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def headers(self) -&gt; Headers: ...
    def text(self, *, encoding: Encoding = "utf-8") -&gt; str: ...
    def text_with_charset(self, encoding: Encoding) -&gt; str: ...
    def json(
        self,
        *,
        allow_inf_nan: bool = False,
        cache_mode: t.Literal[True, False, "all", "keys", "none"] = "all",
        partial_mode: t.Literal[
            True, False, "off", "on", "trailing-strings"
        ] = False,
        catch_duplicate_keys: bool = False,
    ) -&gt; t.Any: ...
    def bytes(self) -&gt; ry.Bytes: ...
    def bytes_stream(
        self, min_read_size: int = 0, /
    ) -&gt; BlockingResponseStream: ...
    def stream(self, min_read_size: int = 0, /) -&gt; BlockingResponseStream: ...
    @property
    def url(self) -&gt; URL: ...
    @property
    def version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def http_version(
        self,
    ) -&gt; t.Literal[
        "HTTP/0.9", "HTTP/1.0", "HTTP/1.1", "HTTP/2.0", "HTTP/3.0"
    ]: ...
    @property
    def redirected(self) -&gt; bool: ...
    @property
    def content_length(self) -&gt; int | None: ...
    @property
    def content_encoding(self) -&gt; str | None: ...
    @property
    def cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def set_cookies(self) -&gt; list[Cookie] | None: ...
    @property
    def body_used(self) -&gt; bool:
        """True if the body has been consumed"""

    @property
    def ok(self) -&gt; bool:
        """True if the status is a success (2xx)"""

    @property
    def remote_addr(self) -&gt; SocketAddr | None: ...
    @property
    def status(self) -&gt; int: ...
    @property
    def status_text(self) -&gt; str: ...
    @property
    def status_code(self) -&gt; HttpStatus: ...
    def __bool__(self) -&gt; bool:
        """True if the status is a success (2xx)"""


@t.final
class ResponseStream:
    def __aiter__(self) -&gt; ResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...
    async def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    @t.overload
    async def collect(self, join: t.Literal[True]) -&gt; ry.Bytes: ...
    @t.overload
    async def collect(
        self, join: t.Literal[False] = False
    ) -&gt; list[ry.Bytes]: ...


@t.final
class _AsyncResponseStream:
    def __aiter__(self) -&gt; _AsyncResponseStream: ...
    async def __anext__(self) -&gt; ry.Bytes: ...
    async def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    async def collect(self) -&gt; list[ry.Bytes]: ...


@t.final
class BlockingResponseStream:
    def __iter__(self) -&gt; BlockingResponseStream: ...
    def __next__(self) -&gt; ry.Bytes: ...
    def take(self, n: int = 1) -&gt; list[ry.Bytes]: ...
    @t.overload
    def collect(self, join: t.Literal[True]) -&gt; ry.Bytes: ...
    @t.overload
    def collect(self, join: t.Literal[False] = False) -&gt; list[ry.Bytes]: ...


async def fetch(
    url: URL | str,
    *,
    method: str = "GET",
    body: _Body | None = None,
    headers: Headers | dict[str, str] | None = None,
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None = None,
    json: t.Any = None,
    form: t.Any = None,
    multipart: t.Any | None = None,
    timeout: Duration | None = None,
    basic_auth: tuple[str, str | None] | None = None,
    bearer_auth: str | None = None,
    version: HttpVersionLike | None = None,
) -&gt; Response: ...
def fetch_sync(
    url: URL | str,
    *,
    method: str = "GET",
    body: _Body | None = None,
    headers: Headers | dict[str, str] | None = None,
    query: dict[str, t.Any] | t.Sequence[tuple[str, t.Any]] | None = None,
    json: t.Any = None,
    form: t.Any = None,
    multipart: t.Any | None = None,
    timeout: Duration | None = None,
    basic_auth: tuple[str, str | None] | None = None,
    bearer_auth: str | None = None,
    version: HttpVersionLike | None = None,
) -&gt; BlockingResponse: ...


@t.final
class Cookie(FromStr, _Parse):
    def __init__(
        self,
        name: str,
        value: str,
        *,
        domain: str | None = None,
        expires: int | None = None,
        http_only: bool | None = None,
        max_age: Duration | None = None,
        partitioned: bool | None = None,
        path: str | None = None,
        permanent: bool = False,
        removal: bool = False,
        same_site: t.Literal["Lax", "Strict", "None"] | None = None,
        secure: bool | None = None,
    ) -&gt; None: ...
    @classmethod
    def from_str(cls, s: str) -&gt; Cookie: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; Cookie: ...
    @staticmethod
    def parse_encoded(s: str) -&gt; Cookie: ...

    # -------------------------------------------------------------------------
    # METHODS
    # -------------------------------------------------------------------------
    # -- STRING --
    def encoded(self) -&gt; str: ...
    def stripped(self) -&gt; str: ...
    def encoded_stripped(self) -&gt; str: ...
    def stripped_encoded(self) -&gt; str: ...

    # -------------------------------------------------------------------------
    # PROPERTIES
    # -------------------------------------------------------------------------
    @property
    def name(self) -&gt; str: ...
    @property
    def value(self) -&gt; str: ...
    @property
    def value_trimmed(self) -&gt; str: ...
    @property
    def name_value(self) -&gt; tuple[str, str]: ...
    @property
    def name_value_trimmed(self) -&gt; tuple[str, str]: ...
    @property
    def domain(self) -&gt; str | None: ...
    @property
    def expires(self) -&gt; int | None: ...
    @property
    def http_only(self) -&gt; bool | None: ...
    @property
    def max_age(self) -&gt; Duration | None: ...
    @property
    def partitioned(self) -&gt; bool | None: ...
    @property
    def path(self) -&gt; str | None: ...
    @property
    def same_site(self) -&gt; t.Literal["Lax", "Strict", "None"] | None: ...
    @property
    def secure(self) -&gt; bool | None: ...


@t.final
class Certificate:
    def __bytes__(self) -&gt; bytes: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    @classmethod
    def from_der(cls, der: Buffer) -&gt; t.Self: ...
    @classmethod
    def from_pem(cls, pem: Buffer) -&gt; t.Self: ...
    @classmethod
    def from_pem_bundle(cls, pem_bundle: Buffer) -&gt; list[t.Self]: ...


@t.final
class CertificateRevocationList:
    def __init__(self, pem: Buffer) -&gt; None: ...
    def __bytes__(self) -&gt; bytes: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    @classmethod
    def from_pem(cls, pem: Buffer) -&gt; t.Self: ...
    @classmethod
    def from_pem_bundle(cls, pem_bundle: Buffer) -&gt; list[t.Self]: ...


@t.final
class Identity:
    def __init__(self, pem: Buffer) -&gt; None: ...
    def __bytes__(self) -&gt; bytes: ...
    def __hash__(self) -&gt; int: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    @classmethod
    def from_pem(cls, pem: Buffer) -&gt; t.Self: ...


class ProxyKwargs(t.TypedDict, total=False):
    basic_auth: tuple[str, str] | None
    no_proxy: str | None
    headers: Headers | dict[str, str] | None


@t.final
class Proxy:
    def __init__(
        self,
        url: URL | str,
        ptype: t.Literal["http", "https", "all"] = "http",
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; None: ...
    @staticmethod
    def all(
        url: URL | str,
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; Proxy: ...
    @staticmethod
    def http(
        url: URL | str,
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; Proxy: ...
    @staticmethod
    def https(
        url: URL | str,
        *,
        basic_auth: tuple[str, str] | None = None,
        headers: Headers | dict[str, str] | None = None,
        no_proxy: str | None = None,
    ) -&gt; Proxy: ...
    # -------------------------------------------------------------------------
    # BUILDERS
    # -------------------------------------------------------------------------
    def basic_auth(self, username: str, password: str) -&gt; Proxy: ...
    def no_proxy(self, url: str) -&gt; Proxy: ...
    def headers(self, headers: Headers | dict[str, str]) -&gt; Proxy: ...
    # -------------------------------------------------------------------------
    # DUNDERS
    # -------------------------------------------------------------------------
    def __eq__(self, other: object) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._same_file"><code>ry.ryo3._same_file</code></h2>

<pre><code class="language-python">"""ryo3-same-file types"""

from os import PathLike


def is_same_file(left: PathLike[str], right: PathLike[str]) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._shlex"><code>ry.ryo3._shlex</code></h2>

<pre><code class="language-python">"""ryo3-shlex types"""


def shplit(s: str) -&gt; list[str]:
    """shlex::split wrapper much like python's stdlib shlex.split but faster"""
</code></pre>
<h2 id="ry.ryo3._size"><code>ry.ryo3._size</code></h2>

<pre><code class="language-python">import builtins
import typing as t

from ry.protocols import FromStr, _Parse

FormatSizeBase: t.TypeAlias = t.Literal[2, 10]  # default=2
FormatSizeStyle: t.TypeAlias = t.Literal[  # default="default"
    "default",
    "abbreviated",
    "abbreviated_lowercase",
    "abbreviated-lowercase",
    "full",
    "full-lowercase",
    "full_lowercase",
]


def fmt_size(
    n: int,
    *,
    base: FormatSizeBase = 2,
    style: FormatSizeStyle = "default",
) -&gt; str:
    """Return human-readable string representation of bytes-size."""


def parse_size(s: str) -&gt; int:
    """Return integer representation of human-readable bytes-size string.

    Raises:
        ValueError: If string is not a valid human-readable bytes-size string.
    """


@t.final
class SizeFormatter:
    """Human-readable bytes-size formatter."""

    def __init__(
        self,
        base: FormatSizeBase = 2,
        style: FormatSizeStyle = "default",
    ) -&gt; None:
        """Initialize human-readable bytes-size formatter."""

    def format(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""

    def __call__(self, n: int) -&gt; str:
        """Return human-readable string representation of bytes-size."""


@t.final
class Size(FromStr, _Parse):
    """Bytes-size object."""

    def __init__(self, size: int) -&gt; None: ...
    @property
    def bytes(self) -&gt; int: ...
    def format(
        self,
        *,
        base: FormatSizeBase = 2,
        style: FormatSizeStyle = "default",
    ) -&gt; str: ...

    # =========================================================================
    # CLASS-METHODS
    # =========================================================================

    # -------------------------------------------------------------------------
    # PARSING
    # -------------------------------------------------------------------------
    @classmethod
    def parse(cls, s: str | builtins.bytes) -&gt; Size: ...
    @classmethod
    def from_str(cls, s: str) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # BYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_bytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # KILOBYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_kb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kibibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_kilobytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # MEGABYTES
    # -------------------------------------------------------------------------

    @classmethod
    def from_mb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_mebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_megabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_mib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # GIGABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_gb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gibibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_gigabytes(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # TERABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_tb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_tebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_terabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_tib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # PETABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_pb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_pebibytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_petabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_pib(cls, size: float) -&gt; Size: ...

    # -------------------------------------------------------------------------
    # EXABYTES
    # -------------------------------------------------------------------------
    @classmethod
    def from_eb(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_eib(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_exabytes(cls, size: float) -&gt; Size: ...
    @classmethod
    def from_exbibytes(cls, size: float) -&gt; Size: ...

    # =========================================================================
    # DUNDERS
    # =========================================================================
    def __add__(self, other: Size | float) -&gt; Size: ...
    def __sub__(self, other: Size | float) -&gt; Size: ...
    def __mul__(self, other: Size | float) -&gt; Size: ...
    def __rmul__(self, other: Size | float) -&gt; Size: ...
    def __neg__(self) -&gt; Size: ...
    def __pos__(self) -&gt; Size: ...
    def __abs__(self) -&gt; Size: ...
    def __invert__(self) -&gt; Size: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Size | float) -&gt; bool: ...
    def __le__(self, other: Size | float) -&gt; bool: ...
    def __gt__(self, other: Size | float) -&gt; bool: ...
    def __ge__(self, other: Size | float) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __bool__(self) -&gt; bool: ...
    def __int__(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._sqlformat"><code>ry.ryo3._sqlformat</code></h2>

<pre><code class="language-python">"""ryo3-sqlformat types"""

import typing as t

Dialect: t.TypeAlias = t.Literal["generic", "postgresql", "sqlserver"]
Indent: t.TypeAlias = t.Literal["tabs", "\t"] | int
SqlfmtParamValue: t.TypeAlias = str | int | float | bool
_TSqlfmtParamValue_co = t.TypeVar(
    "_TSqlfmtParamValue_co", bound=SqlfmtParamValue, covariant=True
)
SqlfmtParamsLike: t.TypeAlias = (
    dict[str, _TSqlfmtParamValue_co]
    | t.Sequence[tuple[str, _TSqlfmtParamValue_co]]
    | t.Sequence[_TSqlfmtParamValue_co]
)


@t.final
class SqlfmtQueryParams:
    def __init__(
        self, params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    ) -&gt; None: ...
    def __len__(self) -&gt; int: ...


def sqlfmt_params(
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
) -&gt; SqlfmtQueryParams: ...
def sqlfmt(
    sql: str,
    params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
    | SqlfmtQueryParams
    | None = None,
    *,
    indent: int | t.Literal["tabs", "\t"] = 2,
    uppercase: bool | None = None,
    lines_between_queries: int = 1,
    ignore_case_convert: list[str] | None = None,
    inline: bool = False,
    max_inline_block: int = 50,
    max_inline_arguments: int | None = None,
    max_inline_top_level: int | None = None,
    joins_as_top_level: bool = False,
    dialect: t.Literal["generic", "postgresql", "sqlserver"] = "generic",
) -&gt; str: ...


class _SqlFormatterDict(t.TypedDict):
    indent: int | t.Literal["tabs"]
    uppercase: bool | None
    lines_between_queries: int
    ignore_case_convert: list[str] | None
    inline: bool
    max_inline_block: int
    max_inline_arguments: int | None
    max_inline_top_level: int | None
    joins_as_top_level: bool
    dialect: t.Literal["generic", "postgresql", "sqlserver"]


@t.final
class SqlFormatter:
    def __init__(
        self,
        *,
        indent: int | t.Literal["tabs", "\t"] = 2,
        uppercase: bool | None = None,
        lines_between_queries: int = 1,
        ignore_case_convert: list[str] | None = None,
        inline: bool = False,
        max_inline_block: int = 50,
        max_inline_arguments: int | None = None,
        max_inline_top_level: int | None = None,
        joins_as_top_level: bool = False,
        dialect: t.Literal["generic", "postgresql", "sqlserver"] = "generic",
    ) -&gt; None: ...
    def to_dict(self) -&gt; _SqlFormatterDict: ...
    def fmt(
        self,
        sql: str,
        params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
        | SqlfmtQueryParams
        | None = None,
    ) -&gt; str: ...
    def __call__(
        self,
        sql: str,
        params: SqlfmtParamsLike[_TSqlfmtParamValue_co]
        | SqlfmtQueryParams
        | None = None,
    ) -&gt; str: ...
    def __eq__(self, value: object) -&gt; bool: ...
    def __ne__(self, value: object) -&gt; bool: ...
</code></pre>
<h2 id="ry.ryo3._std"><code>ry.ryo3._std</code></h2>

<pre><code class="language-python">"""ryo3-std types"""

import datetime as pydt
import ipaddress
import pathlib
import typing as t

from ry._types import (
    Buffer,
    DurationDict,
    FsPathLike,
    MetadataDict,
)
from ry.protocols import (
    FromStr,
    RyIterator,
    ToPy,
    ToPyTimeDelta,
    ToString,
    _Parse,
)
from ry.ryo3._bytes import Bytes


# =============================================================================
# STD::TIME
# =============================================================================
@t.final
class Duration(FromStr, ToPyTimeDelta, ToPy[pydt.timedelta], ToString, _Parse):
    ZERO: t.ClassVar[Duration]
    MIN: t.ClassVar[Duration]
    MAX: t.ClassVar[Duration]
    NANOSECOND: t.ClassVar[Duration]
    MICROSECOND: t.ClassVar[Duration]
    MILLISECOND: t.ClassVar[Duration]
    SECOND: t.ClassVar[Duration]

    def __init__(self, secs: int = 0, nanos: int = 0) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __add__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __sub__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __radd__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __rsub__(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __richcmp__(self, other: t.Self, op: int) -&gt; bool: ...
    def __bool__(self) -&gt; bool: ...
    def __float__(self) -&gt; float: ...
    def __int__(self) -&gt; int: ...
    @t.overload
    def __truediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __truediv__(self, other: float) -&gt; t.Self: ...
    @t.overload
    def __rtruediv__(self, other: t.Self | pydt.timedelta) -&gt; float: ...
    @t.overload
    def __rtruediv__(self, other: float) -&gt; t.Self: ...
    def __mul__(self, other: float) -&gt; t.Self: ...
    def __rmul__(self, other: float) -&gt; t.Self: ...
    def abs_diff(self, other: t.Self | pydt.timedelta) -&gt; t.Self: ...
    def sleep(self, *, interval: int = 10) -&gt; None: ...

    # =========================================================================
    # PYTHON_CONVERSIONS
    # =========================================================================
    @classmethod
    def from_pytimedelta(cls, delta: pydt.timedelta) -&gt; t.Self: ...
    def to_pytimedelta(self) -&gt; pydt.timedelta: ...
    def to_py(self) -&gt; pydt.timedelta: ...
    def to_dict(self) -&gt; DurationDict: ...
    @classmethod
    def from_dict(cls, d: DurationDict) -&gt; t.Self: ...

    # =========================================================================
    # TO/FROM STRING(s)
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def isoformat(self) -&gt; str: ...
    @classmethod
    def fromisoformat(cls, s: str) -&gt; t.Self: ...
    def friendly(
        self,
        designator: t.Literal[
            "compact", "human", "human-time", "short", "verbose"
        ] = "compact",
    ) -&gt; str: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def is_zero(self) -&gt; bool: ...
    @property
    def nanos(self) -&gt; int: ...
    @property
    def nanoseconds(self) -&gt; int:
        """Alias for .nanos"""

    @property
    def ns(self) -&gt; int:
        """Alias for .nanos"""

    @property
    def secs(self) -&gt; int: ...
    @property
    def days(self) -&gt; int: ...
    @property
    def seconds(self) -&gt; int: ...
    @property
    def seconds_remainder(self) -&gt; int: ...
    @property
    def microseconds(self) -&gt; int: ...
    @property
    def subsec_micros(self) -&gt; int: ...
    @property
    def subsec_millis(self) -&gt; int: ...
    @property
    def subsec_nanos(self) -&gt; int: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_hours(cls, hours: int) -&gt; t.Self: ...
    @classmethod
    def from_micros(cls, micros: int) -&gt; t.Self: ...
    @classmethod
    def from_millis(cls, millis: int) -&gt; t.Self: ...
    @classmethod
    def from_mins(cls, mins: int) -&gt; t.Self: ...
    @classmethod
    def from_nanos(cls, nanos: int) -&gt; t.Self: ...
    @classmethod
    def from_secs(cls, secs: int) -&gt; t.Self: ...
    @classmethod
    def from_secs_f32(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_secs_f64(cls, secs: float) -&gt; t.Self: ...
    @classmethod
    def from_days(cls, days: int) -&gt; t.Self: ...
    @classmethod
    def from_weeks(cls, weeks: int) -&gt; t.Self: ...
    def as_micros(self) -&gt; int: ...
    def as_millis(self) -&gt; int: ...
    def as_nanos(self) -&gt; int: ...
    def as_secs(self) -&gt; int: ...
    def as_secs_f32(self) -&gt; float: ...
    def as_secs_f64(self) -&gt; float: ...

    # =========================================================================
    # ARITHMETIC
    # =========================================================================
    def checked_add(self, other: t.Self) -&gt; t.Self | None: ...
    def checked_div(self, other: int) -&gt; t.Self | None: ...
    def checked_mul(self, other: float) -&gt; t.Self | None: ...
    def checked_sub(self, other: t.Self) -&gt; t.Self | None: ...
    def div_duration_f32(self, other: t.Self) -&gt; float: ...
    def div_duration_f64(self, other: t.Self) -&gt; float: ...
    def div_f32(self, n: float) -&gt; t.Self: ...
    def div_f64(self, n: float) -&gt; t.Self: ...
    def mul_f32(self, n: float) -&gt; t.Self: ...
    def mul_f64(self, n: float) -&gt; t.Self: ...
    def saturating_add(self, other: t.Self) -&gt; t.Self: ...
    def saturating_mul(self, other: int) -&gt; t.Self: ...
    def saturating_sub(self, other: t.Self) -&gt; t.Self: ...


@t.final
class Instant:
    def __init__(self) -&gt; None: ...
    @classmethod
    def now(cls) -&gt; Instant: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Instant) -&gt; bool: ...
    def __le__(self, other: Instant) -&gt; bool: ...
    def __gt__(self, other: Instant) -&gt; bool: ...
    def __ge__(self, other: Instant) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def __add__(self, other: Duration) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: Duration) -&gt; t.Self: ...
    @t.overload
    def __sub__(self, other: t.Self) -&gt; Duration: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def checked_add(self, other: Duration) -&gt; t.Self | None: ...
    def checked_duration_since(self, earlier: t.Self) -&gt; Duration | None: ...
    def checked_sub(self, other: Duration) -&gt; t.Self | None: ...
    def duration_since(self, earlier: t.Self) -&gt; Duration: ...
    def elapsed(self) -&gt; Duration: ...
    def saturating_duration_since(self, earlier: t.Self) -&gt; Duration: ...


def duration(secs: int = 0, nanos: int = 0) -&gt; Duration:
    """constructor alias for Duration"""


def instant() -&gt; Instant:
    """constructor alias for Instant"""


def sleep(secs: float) -&gt; float:
    """sleep for given seconds

    Args:
        secs: number of seconds to sleep

    Returns:
        number of seconds actually slept

    Raises:
        ValueError: if secs is negative
        OverflowError: if NaN or secs is too large to convert to a duration
    """


# =============================================================================
# STD::FS
# =============================================================================
FileTypeStr: t.TypeAlias = t.Literal[
    "file",
    "dir",
    "symlink",
    # unix
    "block-device",
    "char-device",
    "fifo",
    "socket",
    # windows
    "symlink-dir",
    "symlink-file",
    # unknown
    "unknown",
]


@t.final
class FileType(ToPy[FileTypeStr]):
    def __init__(
        self,
        t: t.Literal[
            "f",
            "file",
            "d",
            "dir",
            "directory",
            "l",
            "symlink",
            "link",
            "block-device",
            "char-device",
            "fifo",
            "socket",
            "symlink-dir",
            "symlink-file",
            "unknown",
        ],
    ) -&gt; None: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def is_block_device(self) -&gt; bool: ...
    @property
    def is_unknown(self) -&gt; bool: ...
    @property
    def is_char_device(self) -&gt; bool: ...
    @property
    def is_fifo(self) -&gt; bool: ...
    @property
    def is_socket(self) -&gt; bool: ...
    @property
    def is_symlink_dir(self) -&gt; bool: ...
    @property
    def is_symlink_file(self) -&gt; bool: ...
    def to_py(self) -&gt; FileTypeStr: ...


@t.final
class Permissions:
    @property
    def readonly(self) -&gt; bool: ...
    def __eq__(self, value: object) -&gt; bool: ...
    def __ne__(self, value: object) -&gt; bool: ...


@t.final
class Metadata:
    def __init__(self) -&gt; t.NoReturn: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def len(self) -&gt; int: ...
    @property
    def is_empty(self) -&gt; bool: ...
    @property
    def modified(self) -&gt; pydt.datetime: ...
    @property
    def accessed(self) -&gt; pydt.datetime: ...
    @property
    def created(self) -&gt; pydt.datetime: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def permissions(self) -&gt; Permissions: ...
    @property
    def readonly(self) -&gt; bool: ...
    def to_py(self) -&gt; MetadataDict: ...


@t.final
class DirEntry:
    def __init__(self) -&gt; t.NoReturn: ...
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def filename(self) -&gt; str: ...
    def metadata(self) -&gt; Metadata: ...
    def file_type(self) -&gt; FileType: ...


@t.final
class ReadDir(RyIterator[DirEntry]):
    def __init__(self) -&gt; t.NoReturn: ...
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; DirEntry: ...
    def collect(self) -&gt; list[DirEntry]: ...
    def take(self, n: int = 1) -&gt; list[DirEntry]: ...


@t.final
class FileReadStream(RyIterator[Bytes]):
    def __init__(
        self,
        path: FsPathLike,
        *,
        read_size: int = 65536,
        offset: int = 0,
        buffered: bool = True,
        strict: bool = True,
    ) -&gt; None:
        """Return a FileReadStream

        Args:
            path: path-like object
            read_size: number of bytes to read at a time. Defaults to 65536.
            offset: offset to start reading from. Defaults to 0.
            buffered: whether the stream is buffered. Defaults to True.
            strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

        Raises:
            FileNotFoundError: If file does not exist.
            IsADirectoryError: If path is a directory.
            ValueError: If offset is beyond EOF and strict is True.

        """

    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; Bytes: ...
    def collect(self) -&gt; list[Bytes]: ...
    def take(self, n: int = 1) -&gt; list[Bytes]: ...


# ============================================================================
# STD::FS ~ functions
# =============================================================================
_TPath = t.TypeVar("_TPath", bound=FsPathLike)


def canonicalize(path: _TPath) -&gt; _TPath: ...
def copy(from_path: FsPathLike, to_path: FsPathLike) -&gt; int: ...
def create_dir(path: FsPathLike) -&gt; None: ...
def create_dir_all(path: FsPathLike) -&gt; None: ...
def exists(path: FsPathLike) -&gt; bool: ...
def hard_link(original: FsPathLike, link: FsPathLike) -&gt; None: ...
def is_dir(path: FsPathLike) -&gt; bool: ...
def is_file(path: FsPathLike) -&gt; bool: ...
def is_symlink(path: FsPathLike) -&gt; bool: ...
def metadata(path: FsPathLike) -&gt; Metadata: ...
def read(path: FsPathLike) -&gt; Bytes: ...
def read_bytes(path: FsPathLike) -&gt; bytes: ...
def read_dir(path: FsPathLike) -&gt; ReadDir: ...
def read_link(path: FsPathLike) -&gt; pathlib.Path: ...
def read_stream(
    path: FsPathLike,
    read_size: int = 65536,
    *,
    offset: int = 0,
    buffered: bool = True,
    strict: bool = True,
) -&gt; FileReadStream:
    """Return a FileReadStream

    Args:
        path: path-like object
        read_size: number of bytes to read at a time. Defaults to 65536.
        offset: offset to start reading from. Defaults to 0.
        buffered: whether the stream is buffered. Defaults to True.
        strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

    Raises:
        FileNotFoundError: If file does not exist.
        IsADirectoryError: If path is a directory.
        ValueError: If offset is beyond EOF and strict is True.

    """


def read_text(path: FsPathLike) -&gt; str: ...
def read_str(path: FsPathLike) -&gt; str: ...
def read_to_string(path: FsPathLike) -&gt; str: ...
def remove_dir(path: FsPathLike) -&gt; None: ...
def remove_dir_all(path: FsPathLike) -&gt; None: ...
def remove_file(path: FsPathLike) -&gt; None: ...
def rename(from_path: FsPathLike, to_path: FsPathLike) -&gt; None: ...
def set_permissions(path: FsPathLike, perm: Permissions) -&gt; None: ...
def soft_link(original: FsPathLike, link: FsPathLike) -&gt; None: ...
def symlink_metadata(path: FsPathLike) -&gt; Metadata: ...
def write(path: FsPathLike, data: Buffer | str) -&gt; int: ...
def write_bytes(path: FsPathLike, buf: bytes) -&gt; int: ...
def write_text(path: FsPathLike, s: str) -&gt; int: ...


# =============================================================================
# STD::NET
# =============================================================================


class _Version4(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[4]: ...


class _Version6(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[6]: ...


class _Version(t.Protocol):
    @property
    def version(self) -&gt; t.Literal[4, 6]: ...


class _Ipv4AddrProperties(t.Protocol):
    @property
    def is_benchmarking(self) -&gt; bool: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_link_local(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_reserved(self) -&gt; bool: ...
    @property
    def is_shared(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...
    @property
    def is_unicast(self) -&gt; bool: ...


_T_ipaddress_co = t.TypeVar(
    "_T_ipaddress_co",
    bound=ipaddress.IPv4Address | ipaddress.IPv6Address,
    covariant=True,
)


class ToPyIpAddress(t.Protocol[_T_ipaddress_co]):
    def to_pyipaddress(self) -&gt; _T_ipaddress_co: ...


@t.final
class Ipv4Addr(
    _Ipv4AddrProperties,
    _Version4,
    FromStr,
    _Parse,
    ToPy[ipaddress.IPv4Address],
    ToPyIpAddress[ipaddress.IPv4Address],
    ToString,
):
    BROADCAST: Ipv4Addr
    LOCALHOST: Ipv4Addr
    UNSPECIFIED: Ipv4Addr

    @t.overload
    def __init__(self, a: int, b: int, c: int, d: int) -&gt; None: ...
    @t.overload
    def __init__(
        self, iplike: int | str | bytes | Ipv4Addr | ipaddress.IPv4Address
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __le__(self, other: Ipv4Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv4Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv4Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv4Address: ...
    def to_string(self) -&gt; str: ...
    @property
    def version(self) -&gt; t.Literal[4]: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[True]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[False]: ...
    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; Ipv4Addr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; Ipv4Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; Ipv4Addr: ...
    @classmethod
    def from_octets(cls, a: int, b: int, c: int, d: int) -&gt; Ipv4Addr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddrv4(self, port: int) -&gt; SocketAddrV4: ...
    def to_socketaddrv6(
        self, port: int, flowinfo: int = 0, scope_id: int = 0
    ) -&gt; SocketAddrV6: ...


class _Ipv6AddrProperties(t.Protocol):
    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def is_benchmarking(self) -&gt; bool: ...
    @property
    def is_global(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4_mapped(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_reserved(self) -&gt; bool: ...
    @property
    def is_shared(self) -&gt; bool: ...
    @property
    def is_unicast(self) -&gt; bool: ...
    @property
    def is_unicast_global(self) -&gt; t.NoReturn: ...
    @property
    def is_unicast_link_local(self) -&gt; bool: ...
    @property
    def is_unique_local(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...


@t.final
class Ipv6Addr(
    _Ipv6AddrProperties,
    _Version6,
    FromStr,
    _Parse,
    ToPy[ipaddress.IPv6Address],
    ToPyIpAddress[ipaddress.IPv6Address],
    ToString,
):
    LOCALHOST: Ipv6Addr
    UNSPECIFIED: Ipv6Addr

    @t.overload
    def __init__(
        self, a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int
    ) -&gt; None: ...
    @t.overload
    def __init__(
        self, iplike: int | str | bytes | Ipv6Addr | ipaddress.IPv6Address
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __le__(self, other: Ipv6Addr) -&gt; bool: ...
    def __gt__(self, other: Ipv6Addr) -&gt; bool: ...
    def __ge__(self, other: Ipv6Addr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_py(self) -&gt; ipaddress.IPv6Address: ...
    def to_string(self) -&gt; str: ...
    @property
    def version(self) -&gt; t.Literal[6]: ...
    @property
    def is_documentation(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[False]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[True]: ...
    # ========================================================================
    # CLASSMETHODS
    # ========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; Ipv6Addr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; Ipv6Addr: ...
    @classmethod
    def from_bits(cls, bits: int) -&gt; IpAddr: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddrv4(self, port: int) -&gt; SocketAddrV4: ...
    def to_socketaddrv6(
        self, port: int, flowinfo: int = 0, scope_id: int = 0
    ) -&gt; SocketAddrV6: ...


@t.final
class IpAddr(
    _Ipv4AddrProperties,
    _Ipv6AddrProperties,
    _Version,
    FromStr,
    _Parse,
    ToPy[ipaddress.IPv4Address | ipaddress.IPv6Address],
    ToPyIpAddress[ipaddress.IPv4Address | ipaddress.IPv6Address],
    ToString,
):
    BROADCAST: IpAddr
    LOCALHOST_V4: IpAddr
    UNSPECIFIED_V4: IpAddr
    LOCALHOST_V6: IpAddr
    UNSPECIFIED_V6: IpAddr

    def __init__(
        self,
        iplike: int
        | str
        | bytes
        | Ipv4Addr
        | Ipv6Addr
        | ipaddress.IPv4Address
        | ipaddress.IPv6Address,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: IpAddr) -&gt; bool: ...
    def __le__(self, other: IpAddr) -&gt; bool: ...
    def __gt__(self, other: IpAddr) -&gt; bool: ...
    def __ge__(self, other: IpAddr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_string(self) -&gt; str: ...
    def to_py(self) -&gt; ipaddress.IPv4Address | ipaddress.IPv6Address: ...
    def to_ipv4(self) -&gt; Ipv4Addr: ...
    def to_ipv6(self) -&gt; Ipv6Addr: ...

    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def from_str(cls, s: str) -&gt; IpAddr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; IpAddr: ...

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def version(self) -&gt; t.Literal[4, 6]: ...
    @property
    def is_benchmarking(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; bool: ...
    @property
    def is_ipv6(self) -&gt; bool: ...
    @property
    def is_broadcast(self) -&gt; bool: ...
    @property
    def is_documentation(self) -&gt; bool: ...
    @property
    def is_loopback(self) -&gt; bool: ...
    @property
    def is_multicast(self) -&gt; bool: ...
    @property
    def is_private(self) -&gt; bool: ...
    @property
    def is_unspecified(self) -&gt; bool: ...

    # =======================================================================
    # METHODS
    # =======================================================================
    def to_canonical(self) -&gt; IpAddr: ...


@t.final
class SocketAddrV4(
    _Ipv4AddrProperties,
    _Version4,
    # protocols
    FromStr,
    ToPyIpAddress[ipaddress.IPv4Address],
    ToString,
    _Parse,
):
    def __init__(
        self,
        ip: IpAddr | Ipv4Addr | ipaddress.IPv4Address | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddrV4) -&gt; bool: ...
    def __le__(self, other: SocketAddrV4) -&gt; bool: ...
    def __gt__(self, other: SocketAddrV4) -&gt; bool: ...
    def __ge__(self, other: SocketAddrV4) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_ipv4(self) -&gt; Ipv4Addr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddr(self) -&gt; SocketAddr: ...
    def to_string(self) -&gt; str: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @property
    def port(self) -&gt; int: ...
    @property
    def ip(self) -&gt; Ipv4Addr: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[True]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[False]: ...


@t.final
class SocketAddrV6(
    _Ipv6AddrProperties,
    _Version6,
    # protocols
    FromStr,
    ToPyIpAddress[ipaddress.IPv6Address],
    ToString,
    _Parse,
):
    def __init__(
        self,
        ip: IpAddr | Ipv6Addr | ipaddress.IPv4Address | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddrV6) -&gt; bool: ...
    def __le__(self, other: SocketAddrV6) -&gt; bool: ...
    def __gt__(self, other: SocketAddrV6) -&gt; bool: ...
    def __ge__(self, other: SocketAddrV6) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def to_string(self) -&gt; str: ...
    def to_ipv6(self) -&gt; Ipv6Addr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_socketaddr(self) -&gt; SocketAddr: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @property
    def port(self) -&gt; int: ...
    @property
    def ip(self) -&gt; Ipv6Addr: ...
    @property
    def is_documentation(self) -&gt; t.NoReturn: ...
    @property
    def is_ipv4(self) -&gt; t.Literal[True]: ...
    @property
    def is_ipv6(self) -&gt; t.Literal[False]: ...


@t.final
class SocketAddr(
    _Ipv4AddrProperties,
    _Ipv6AddrProperties,
    _Version,
    # protocols
    FromStr,
    _Parse,
    ToString,
    ToPyIpAddress[ipaddress.IPv4Address | ipaddress.IPv6Address],
):
    def __init__(
        self,
        ip: IpAddr
        | Ipv4Addr
        | Ipv6Addr
        | ipaddress.IPv4Address
        | ipaddress.IPv6Address,
        port: int,
    ) -&gt; None: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __lt__(self, other: SocketAddr) -&gt; bool: ...
    def __le__(self, other: SocketAddr) -&gt; bool: ...
    def __gt__(self, other: SocketAddr) -&gt; bool: ...
    def __ge__(self, other: SocketAddr) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    @classmethod
    def from_str(cls, s: str) -&gt; SocketAddr: ...
    @classmethod
    def parse(cls, s: str | bytes) -&gt; SocketAddr: ...
    def to_ipaddr(self) -&gt; IpAddr: ...
    def to_string(self) -&gt; str: ...
    def to_socketaddrv4(self) -&gt; SocketAddrV4:
        """Return SocketAddrV4 representation

        Raises:
            ValueError: if the internal SocketAddr v6
        """

    def to_socketaddrv6(self) -&gt; SocketAddrV6:
        """Return SocketAddrV6 representation

        Raises:
            ValueError: if the internal SocketAddr v4
        """

    @property
    def is_ipv4(self) -&gt; bool: ...
    @property
    def is_ipv6(self) -&gt; bool: ...
    @property
    def ip(self) -&gt; IpAddr: ...
    @property
    def port(self) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3._std_constants"><code>ry.ryo3._std_constants</code></h2>

<pre><code class="language-python">from typing import Literal

# ruff: noqa: PYI054
# u8
U8_BITS: Literal[8]
U8_MAX: Literal[255]
U8_MIN: Literal[0]
# i8
I8_BITS: Literal[8]
I8_MAX: Literal[127]
I8_MIN: Literal[-128]
# i16
I16_BITS: Literal[16]
I16_MAX: Literal[32_767]
I16_MIN: Literal[-32_768]
# u16
U16_BITS: Literal[16]
U16_MAX: Literal[65_535]
U16_MIN: Literal[0]

# u32
U32_BITS: Literal[32]
U32_MAX: Literal[4_294_967_295]
U32_MIN: Literal[0]

# i32
I32_BITS: Literal[32]
I32_MAX: Literal[2_147_483_647]
I32_MIN: Literal[-2_147_483_648]

# u64
U64_BITS: Literal[64]
U64_MAX: Literal[18_446_744_073_709_551_615]
U64_MIN: Literal[0]

# i64
I64_BITS: Literal[64]
I64_MAX: Literal[9_223_372_036_854_775_807]
I64_MIN: Literal[-9_223_372_036_854_775_808]

# u128
U128_BITS: Literal[128]
U128_MAX: Literal[340_282_366_920_938_463_463_374_607_431_768_211_455]
U128_MIN: Literal[0]

# i128
I128_BITS: Literal[128]
I128_MAX: Literal[170_141_183_460_469_231_731_687_303_715_884_105_727]
I128_MIN: Literal[-170_141_183_460_469_231_731_687_303_715_884_105_728]

# usize
USIZE_BITS: Literal[32, 64]
USIZE_MAX: Literal[4_294_967_295, 18_446_744_073_709_551_615]
USIZE_MIN: Literal[0]
# isize
ISIZE_BITS: Literal[32, 64]
ISIZE_MAX: Literal[2_147_483_647, 9_223_372_036_854_775_807]
ISIZE_MIN: Literal[-2_147_483_648, -9_223_372_036_854_775_808]
</code></pre>
<h2 id="ry.ryo3._tokio"><code>ry.ryo3._tokio</code></h2>

<pre><code class="language-python">"""ryo4-tokio types"""

import pathlib
import sys
import typing as t
from collections.abc import Generator
from types import TracebackType

from ry import Bytes
from ry._types import Buffer, FsPathLike, OpenBinaryMode
from ry.protocols import RyAsyncIterator
from ry.ryo3._std import FileType, Metadata

if sys.version_info &gt;= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated


# =============================================================================
# FS
# =============================================================================
async def canonicalize_async(path: FsPathLike) -&gt; FsPathLike: ...
async def copy_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def create_dir_async(path: FsPathLike) -&gt; None: ...
async def create_dir_all_async(path: FsPathLike) -&gt; None: ...
async def hard_link_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def metadata_async(path: FsPathLike) -&gt; None: ...
async def read_async(path: FsPathLike) -&gt; Bytes: ...
async def remove_dir_async(path: FsPathLike) -&gt; None: ...
async def remove_dir_all_async(path: FsPathLike) -&gt; None: ...
async def remove_file_async(path: FsPathLike) -&gt; None: ...
async def read_link_async(path: FsPathLike) -&gt; FsPathLike: ...
async def read_to_string_async(path: FsPathLike) -&gt; str: ...
async def rename_async(src: FsPathLike, dst: FsPathLike) -&gt; None: ...
async def write_async(path: FsPathLike, buf: Buffer) -&gt; None: ...
async def try_exists_async(path: FsPathLike) -&gt; bool: ...
async def exists_async(path: FsPathLike) -&gt; bool: ...


@t.final
class AsyncDirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; pathlib.Path: ...
    @property
    def filename(self) -&gt; str: ...
    async def metadata(self) -&gt; Metadata: ...
    async def file_type(self) -&gt; FileType: ...


@t.final
class AsyncReadDir:
    """Async iterator for read_dir_async"""

    async def collect(self) -&gt; list[AsyncDirEntry]: ...
    async def take(self, n: int) -&gt; list[AsyncDirEntry]: ...
    def __aiter__(self) -&gt; AsyncReadDir: ...
    async def __anext__(self) -&gt; AsyncDirEntry: ...


async def read_dir_async(path: FsPathLike) -&gt; AsyncReadDir: ...


# =============================================================================
# SLEEP
# =============================================================================
async def sleep_async(secs: float) -&gt; float: ...
async def asleep(secs: float) -&gt; float:
    """Alias for sleep_async"""


# =============================================================================
# ASYNC-FILE
# =============================================================================
@t.final
class AsyncFile:
    def __init__(
        self, path: FsPathLike, mode: OpenBinaryMode = "rb", buffering: int = -1
    ) -&gt; None: ...
    async def close(self) -&gt; None: ...
    async def flush(self) -&gt; None: ...
    async def isatty(self) -&gt; t.NoReturn: ...
    async def open(self) -&gt; None: ...
    async def peek(self, size: int = ..., /) -&gt; Bytes: ...
    async def read(self, size: int | None = None, /) -&gt; Bytes: ...
    async def readable(self) -&gt; bool: ...
    async def readall(self) -&gt; Bytes: ...
    async def readline(self, size: int | None = None, /) -&gt; Bytes: ...
    async def readlines(self, hint: int | None = None, /) -&gt; list[Bytes]: ...
    async def seek(self, offset: int, whence: int = ..., /) -&gt; int: ...
    async def seekable(self) -&gt; bool: ...
    async def tell(self) -&gt; int: ...
    async def truncate(self, pos: int | None = None, /) -&gt; int: ...
    async def writable(self) -&gt; bool: ...
    async def write(self, b: Buffer, /) -&gt; int: ...
    @property
    def closed(self) -&gt; bool: ...
    def __await__(self) -&gt; Generator[t.Any, t.Any, t.Self]: ...
    def __aiter__(self) -&gt; t.Self: ...
    async def __anext__(self) -&gt; Bytes: ...
    async def __aenter__(self) -&gt; t.Self: ...
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -&gt; None: ...


def aopen(
    path: FsPathLike, mode: OpenBinaryMode | str = "rb", buffering: int = -1
) -&gt; AsyncFile: ...
@deprecated("`aiopen` is deprecated, use `aopen` instead")
def aiopen(
    path: FsPathLike, mode: OpenBinaryMode | str = "rb", buffering: int = -1
) -&gt; AsyncFile: ...


@t.final
class AsyncFileReadStream(RyAsyncIterator[Bytes]):
    def __init__(
        self,
        path: FsPathLike,
        *,
        read_size: int = 65536,
        offset: int = 0,
        buffered: bool = True,
        strict: bool = True,
    ) -&gt; None:
        """Return an AsyncFileReadStream

        Args:
            path: path-like object
            read_size: number of bytes to read at a time. Defaults to 65536.
            offset: offset to start reading from. Defaults to 0.
            buffered: whether the stream is buffered. Defaults to True.
            strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

        Raises:
            FileNotFoundError: If file does not exist.
            IsADirectoryError: If path is a directory.
            ValueError: If offset is beyond EOF and strict is True.

        """

    def __await__(self) -&gt; Generator[t.Any, t.Any, t.Self]: ...
    def __aiter__(self) -&gt; t.Self: ...
    async def __anext__(self) -&gt; Bytes: ...
    async def collect(self) -&gt; list[Bytes]: ...
    async def take(self, n: int = 1) -&gt; list[Bytes]: ...


def read_stream_async(
    path: FsPathLike,
    read_size: int = 65536,
    *,
    offset: int = 0,
    buffered: bool = True,
    strict: bool = True,
) -&gt; AsyncFileReadStream:
    """Return a FileReadStream

    Args:
        path: path-like object
        read_size: number of bytes to read at a time. Defaults to 65536.
        offset: offset to start reading from. Defaults to 0.
        buffered: whether the stream is buffered. Defaults to True.
        strict: whether to raise a ValueError on offset beyond EOF. Defaults to True.

    Raises:
        FileNotFoundError: If file does not exist.
        IsADirectoryError: If path is a directory.
        ValueError: If offset is beyond EOF and strict is True.

    """
</code></pre>
<h2 id="ry.ryo3._unindent"><code>ry.ryo3._unindent</code></h2>

<pre><code class="language-python">"""ryo3-unindent types"""


def unindent(s: str, /) -&gt; str: ...
def unindent_bytes(b: bytes, /) -&gt; bytes: ...
</code></pre>
<h2 id="ry.ryo3._url"><code>ry.ryo3._url</code></h2>

<pre><code class="language-python">import sys
import typing as t
from ipaddress import IPv4Address, IPv6Address

from ry._types import FsPathLike
from ry.protocols import FromStr, ToString, _Parse
from ry.ryo3._std import IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr

if sys.version_info &gt;= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated


@t.final
class URL(FromStr, ToString, _Parse):
    def __init__(
        self, url: str | bytes | URL, *, params: dict[str, str] | None = None
    ) -&gt; None: ...
    # =========================================================================
    # CLASSMETHODS
    # =========================================================================
    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    @classmethod
    def parse_with_params(
        cls, url: str | bytes, params: dict[str, str]
    ) -&gt; t.Self: ...
    @classmethod
    def from_directory_path(cls, path: FsPathLike) -&gt; t.Self: ...
    @classmethod
    def from_filepath(cls, path: FsPathLike) -&gt; t.Self: ...
    # =========================================================================
    # STRING
    # =========================================================================
    def to_string(self) -&gt; str: ...
    def __fspath__(self) -&gt; str: ...

    # =========================================================================
    # PROPERTIES
    # =========================================================================
    @property
    def authority(self) -&gt; str: ...
    @property
    def domain(self) -&gt; str | None: ...
    @property
    def fragment(self) -&gt; str | None: ...
    @property
    def host(self) -&gt; str | Ipv4Addr | Ipv6Addr | None: ...
    @property
    def host_str(self) -&gt; str | None: ...
    @property
    def netloc(self) -&gt; str: ...
    @property
    def password(self) -&gt; str | None: ...
    @property
    def path(self) -&gt; str: ...
    @property
    def path_segments(self) -&gt; tuple[str, ...]: ...
    @property
    def port(self) -&gt; int | None:
        """
        Return the port number for this URL, if any.

        Note: the default port numbers are never reflected by the serialization,
        use the `port_or_known_default` if you want a default port number returned.

        Default port numbers:
            - `http`  | `ws`  =&gt; `80`
            - `https` | `wss` =&gt; `443`
            - `ftp`           =&gt; `21`

        Examples:

            &gt;&gt;&gt; from ry import URL
            &gt;&gt;&gt; assert URL("https://rotatingsandwiches.com:3000").port == 3000
            &gt;&gt;&gt; assert URL("https://rotatingsandwiches.com").port is None
            &gt;&gt;&gt; assert URL("https://rotatingsandwiches.com:443/").port is None
            &gt;&gt;&gt; assert URL("ssh://rotatingsandwiches.com:22").port == 22

        """

    @property
    def port_or_known_default(self) -&gt; int | None:
        """Return the port number, or the default port number if known.

        Default port numbers:
            - `http`  | `ws`  =&gt; `80`
            - `https` | `wss` =&gt; `443`
            - `ftp`           =&gt; `21`

        Examples:

            &gt;&gt;&gt; from ry import URL
            &gt;&gt;&gt; URL("https://rotatingsandwiches.com:3000").port_or_known_default
            3000
            &gt;&gt;&gt; URL("https://rotatingsandwiches.com").port_or_known_default
            443
            &gt;&gt;&gt; URL("https://rotatingsandwiches.com:443/").port_or_known_default
            443
            &gt;&gt;&gt; URL("ssh://rotatingsandwiches.com:22").port_or_known_default
            22

        """

    @property
    def query(self) -&gt; str | None: ...
    @property
    def query_string(self) -&gt; str: ...
    @property
    def query_pairs(self) -&gt; tuple[tuple[str, str], ...]: ...
    @property
    def scheme(self) -&gt; str: ...
    @property
    def user(self) -&gt; str:
        """alias for yarl compatibility"""

    @property
    def username(self) -&gt; str: ...
    @property
    def origin(self) -&gt; str: ...

    # =========================================================================
    # INSTANCE METHODS
    # =========================================================================
    def has_authority(self) -&gt; bool: ...
    def has_host(self) -&gt; bool: ...
    def equiv(self, other: URL | str) -&gt; bool: ...
    def is_special(self) -&gt; bool: ...
    def join(self, *parts: str) -&gt; URL: ...
    def make_relative(self, other: URL) -&gt; t.Self: ...
    def socket_addrs(
        self, default_port_number: int | None = None
    ) -&gt; list[SocketAddr]: ...
    def to_filepath(self) -&gt; str: ...
    def replace(
        self,
        *,
        fragment: str | None = None,
        host: str | None = None,
        ip_host: IPv4Address
        | IPv6Address
        | Ipv4Addr
        | Ipv6Addr
        | IpAddr
        | None = None,
        password: str | None = None,
        path: str | None = None,
        port: int | None = None,
        query: str | None = None,
        scheme: str | None = None,
        username: str | None = None,
    ) -&gt; t.Self: ...
    def with_fragment(self, fragment: str | None = None) -&gt; t.Self: ...
    def with_host(self, host: str | None = None) -&gt; t.Self: ...
    def with_ip_host(
        self, address: IPv4Address | IPv6Address | Ipv4Addr | Ipv6Addr | IpAddr
    ) -&gt; t.Self: ...
    def with_password(self, password: str | None = None) -&gt; t.Self: ...
    def with_path(self, path: str) -&gt; t.Self: ...
    def with_port(self, port: int | None = None) -&gt; t.Self: ...
    def with_query(self, query: str | None = None) -&gt; t.Self: ...
    def with_scheme(self, scheme: str) -&gt; t.Self: ...
    def with_username(self, username: str) -&gt; t.Self: ...

    # =========================================================================
    # OPERATORS/DUNDER
    # =========================================================================
    def __len__(self) -&gt; int: ...
    def __truediv__(self, relative: str) -&gt; t.Self: ...
    def __rtruediv__(self, relative: str) -&gt; t.Self: ...
    def __lt__(self, other: t.Self) -&gt; bool: ...
    def __le__(self, other: t.Self) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __ne__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: t.Self) -&gt; bool: ...
    def __ge__(self, other: t.Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # =========================================================================
    # DEPRECATED
    # =========================================================================
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_fragment(self, fragment: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_host(self, host: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_ip_host(
        self, address: IPv4Address | IPv6Address | Ipv4Addr | Ipv6Addr | IpAddr
    ) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_password(self, password: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_path(self, path: str) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_port(self, port: int | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_query(self, query: str | None = None) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_scheme(self, scheme: str) -&gt; t.Self: ...
    @deprecated(
        "`replace_*` methods are deprecated, use `with_*` methods instead"
    )
    def replace_username(self, username: str) -&gt; t.Self: ...
</code></pre>
<h2 id="ry.ryo3._walkdir"><code>ry.ryo3._walkdir</code></h2>

<pre><code class="language-python">"""ryo3-walkdir types"""

import typing as t
from os import PathLike

from ry import FileType, FsPath, Glob, GlobSet, Globster
from ry.protocols import RyIterator


@t.final
class WalkDirEntry:
    def __fspath__(self) -&gt; str: ...
    @property
    def path(self) -&gt; FsPath: ...
    @property
    def file_name(self) -&gt; str: ...
    @property
    def depth(self) -&gt; int: ...
    @property
    def path_is_symlink(self) -&gt; bool: ...
    @property
    def file_type(self) -&gt; FileType: ...
    @property
    def is_dir(self) -&gt; bool: ...
    @property
    def is_file(self) -&gt; bool: ...
    @property
    def is_symlink(self) -&gt; bool: ...
    @property
    def len(self) -&gt; int: ...


_T_walkdir = t.TypeVar(
    "_T_walkdir",
    bound=WalkDirEntry | str,
)


@t.final
class WalkdirGen(RyIterator[_T_walkdir]):
    """walkdir::Walkdir iterable wrapper"""

    def __init__(self) -&gt; t.NoReturn: ...
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; _T_walkdir: ...
    def collect(self) -&gt; list[_T_walkdir]: ...
    def take(self, n: int = 1) -&gt; list[_T_walkdir]: ...


@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    /,
    *,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    follow_root_links: bool = True,
    same_file_system: bool = False,
    sort_by_file_name: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
    objects: t.Literal[True],
) -&gt; WalkdirGen[WalkDirEntry]: ...
@t.overload
def walkdir(
    path: str | PathLike[str] | None = None,
    /,
    *,
    objects: t.Literal[False] = False,
    files: bool = True,
    dirs: bool = True,
    contents_first: bool = False,
    min_depth: int = 0,
    max_depth: int | None = None,
    follow_links: bool = False,
    follow_root_links: bool = True,
    same_file_system: bool = False,
    sort_by_file_name: bool = False,
    glob: Glob | GlobSet | Globster | t.Sequence[str] | str | None = None,
) -&gt; WalkdirGen[str]: ...
</code></pre>
<h2 id="ry.ryo3._which"><code>ry.ryo3._which</code></h2>

<pre><code class="language-python">"""ryo3-which types"""

from pathlib import Path

from ry.ryo3._regex import Regex


def which(cmd: str, path: None | str = None) -&gt; Path | None: ...
def which_all(cmd: str, path: None | str = None) -&gt; list[Path]: ...
def which_re(regex: str | Regex, path: None | str = None) -&gt; list[Path]: ...
</code></pre>
<h2 id="ry.ryo3._zstd"><code>ry.ryo3._zstd</code></h2>

<pre><code class="language-python">"""ry.ryo3 root level zstd exports"""

from ry.ryo3.zstd import compress as zstd_compress
from ry.ryo3.zstd import decode as zstd_decode
from ry.ryo3.zstd import decompress as zstd_decompress
from ry.ryo3.zstd import encode as zstd_encode
from ry.ryo3.zstd import is_zstd as is_zstd

__all__ = (
    "is_zstd",
    "zstd_compress",
    "zstd_decode",
    "zstd_decompress",
    "zstd_encode",
)
</code></pre>
<h2 id="ry.ryo3.dirs"><code>ry.ryo3.dirs</code></h2>

<pre><code class="language-python">def audio() -&gt; str | None: ...
def audio_dir() -&gt; str | None: ...
def cache() -&gt; str | None: ...
def cache_dir() -&gt; str | None: ...
def config() -&gt; str | None: ...
def config_dir() -&gt; str | None: ...
def config_local() -&gt; str | None: ...
def config_local_dir() -&gt; str | None: ...
def data() -&gt; str | None: ...
def data_dir() -&gt; str | None: ...
def data_local() -&gt; str | None: ...
def data_local_dir() -&gt; str | None: ...
def desktop() -&gt; str | None: ...
def desktop_dir() -&gt; str | None: ...
def document() -&gt; str | None: ...
def document_dir() -&gt; str | None: ...
def download() -&gt; str | None: ...
def download_dir() -&gt; str | None: ...
def executable() -&gt; str | None: ...
def executable_dir() -&gt; str | None: ...
def font() -&gt; str | None: ...
def font_dir() -&gt; str | None: ...
def home() -&gt; str | None: ...
def home_dir() -&gt; str | None: ...
def picture() -&gt; str | None: ...
def picture_dir() -&gt; str | None: ...
def preference() -&gt; str | None: ...
def preference_dir() -&gt; str | None: ...
def public() -&gt; str | None: ...
def public_dir() -&gt; str | None: ...
def runtime() -&gt; str | None: ...
def runtime_dir() -&gt; str | None: ...
def state() -&gt; str | None: ...
def state_dir() -&gt; str | None: ...
def template() -&gt; str | None: ...
def template_dir() -&gt; str | None: ...
def video() -&gt; str | None: ...
def video_dir() -&gt; str | None: ...
</code></pre>
<h2 id="ry.ryo3.errors"><code>ry.ryo3.errors</code></h2>

<pre><code class="language-python">class FeatureNotEnabledError(RuntimeError):
    """Raised when a feature is not enabled in the current build."""
</code></pre>
<h2 id="ry.ryo3.JSON"><code>ry.ryo3.JSON</code></h2>

<pre><code class="language-python">"""ry.ryo3.JSON"""

import typing as t

from ry._types import Buffer, Unpack
from ry.ryo3._bytes import Bytes
from ry.ryo3._jiter import JsonParseKwargs, JsonValue


def minify(buf: Buffer | str, /) -&gt; Bytes:
    """Return minified json data (remove whitespace, newlines)

    Args:
        data: The JSON data to minify.

    Returns:
        Minified JSON data as a `Bytes` object.

    Examples:
        &gt;&gt;&gt; import json as pyjson
        &gt;&gt;&gt; from ry.ryo3 import JSON
        &gt;&gt;&gt; data = {"key": "value", "number": 123, "bool": True}
        &gt;&gt;&gt; json_str = pyjson.dumps(data, indent=2)
        &gt;&gt;&gt; print(json_str)
        {
          "key": "value",
          "number": 123,
          "bool": true
        }
        &gt;&gt;&gt; bytes(JSON.minify(json_str))
        b'{"key":"value","number":123,"bool":true}'

    """


def fmt(buf: Buffer | str, /) -&gt; Bytes:
    """Return minified json data (remove whitespace, newlines)

    Args:
        data: The JSON data to minify.

    Returns:
        Minified JSON data as a `Bytes` object.

    Examples:
        &gt;&gt;&gt; import json as pyjson
        &gt;&gt;&gt; from ry.ryo3 import JSON
        &gt;&gt;&gt; data = {"key": "value", "number": 123, "bool": True}
        &gt;&gt;&gt; json_str = pyjson.dumps(data, indent=2)
        &gt;&gt;&gt; print(json_str)
        {
          "key": "value",
          "number": 123,
          "bool": true
        }
        &gt;&gt;&gt; bytes(JSON.fmt(json_str)).decode()
        '{\n  "key": "value",\n  "number": 123,\n  "bool": true\n}'
        &gt;&gt;&gt; print(bytes(JSON.fmt(json_str)).decode())
        {
          "key": "value",
          "number": 123,
          "bool": true
        }

    """


@t.overload
def stringify(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[True],
) -&gt; bytes: ...
@t.overload
def stringify(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[False] = False,
) -&gt; Bytes: ...
@t.overload
def dumps(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[True],
) -&gt; bytes: ...
@t.overload
def dumps(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: t.Literal[False] = False,
) -&gt; Bytes: ...
def loads(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def parse(
    data: Buffer | bytes | str,
    /,
    **kwargs: Unpack[JsonParseKwargs],
) -&gt; JsonValue: ...
def cache_clear() -&gt; None: ...
def cache_usage() -&gt; int: ...


# under construction
def stringify_unsafe(
    obj: t.Any,
    *,
    default: t.Callable[[t.Any], t.Any] | None = None,
    fmt: bool = False,
    sort_keys: bool = False,
    append_newline: bool = False,
    pybytes: bool = False,
) -&gt; t.NoReturn: ...
</code></pre>
<h2 id="ry.ryo3.orjson"><code>ry.ryo3.orjson</code></h2>

<pre><code class="language-python">"""orjson + ry types

orjson-types: https://github.com/ijl/orjson/blob/master/pysrc/orjson/__init__.pyi
"""

import typing as t

import orjson


def orjson_default(obj: t.Any) -&gt; orjson.Fragment:
    """Fn to be used with `orjson.dumps` to serialize ry-compatible types

    Example:
        &gt;&gt;&gt; import orjson
        &gt;&gt;&gt; from ry import orjson_default, Date
        &gt;&gt;&gt; data = {"key": "value", "date": Date(2023, 10, 1)}
        &gt;&gt;&gt; orjson.dumps(data, default=orjson_default)
        b'{"key":"value","date":"2023-10-01"}'

    """
</code></pre>
<h2 id="ry.ryo3.sh"><code>ry.ryo3.sh</code></h2>

<pre><code class="language-python">import typing as t
from os import PathLike

from ry.ryo3._fspath import FsPath


def pwd() -&gt; str: ...
def home() -&gt; str: ...
def cd(path: str | PathLike[str]) -&gt; None: ...
@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[False] = False,
) -&gt; list[str]:
    """List directory contents - returns list of strings"""


@t.overload
def ls(
    path: str | PathLike[str] | None = None,  # defaults to '.' if None
    *,
    absolute: bool = False,
    sort: bool = False,
    objects: t.Literal[True],
) -&gt; list[FsPath]:
    """List directory contents - returns list of FsPath objects"""


def mkdir(
    path: str | PathLike[str],
    *,
    exist_ok: bool = False,
    recursive: bool = False,
) -&gt; None: ...
def mkdirp(path: str | PathLike[str]) -&gt; None: ...
</code></pre>
<h2 id="ry.ryo3.ulid"><code>ry.ryo3.ulid</code></h2>

<pre><code class="language-python">import builtins
import datetime as pydt
import typing as t
import uuid
from collections.abc import Callable as Callable

from pydantic import GetCoreSchemaHandler as GetCoreSchemaHandler
from pydantic import (
    ValidatorFunctionWrapHandler as ValidatorFunctionWrapHandler,
)
from pydantic_core import CoreSchema as CoreSchema

from ry.protocols import FromStr


@t.final
class ULID(FromStr):
    def __init__(self, value: builtins.bytes | str | None = None) -&gt; None: ...

    # ----------------
    # INSTANCE METHODS
    # ----------------
    def to_bytes(self) -&gt; builtins.bytes: ...
    def to_uuid(self) -&gt; uuid.UUID: ...
    def to_uuid4(self) -&gt; uuid.UUID: ...

    # ----------
    # PROPERTIES
    # ----------
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def milliseconds(self) -&gt; int: ...
    @property
    def timestamp(self) -&gt; float: ...
    @property
    def datetime(self) -&gt; pydt.datetime: ...
    @property
    def hex(self) -&gt; str: ...

    # -------------
    # CLASS METHODS
    # -------------
    @classmethod
    def from_datetime(cls, value: pydt.datetime) -&gt; ULID: ...
    @classmethod
    def from_timestamp(cls, value: float) -&gt; ULID: ...
    @classmethod
    def from_timestamp_seconds(cls, value: float) -&gt; ULID: ...
    @classmethod
    def from_timestamp_milliseconds(cls, value: int) -&gt; ULID: ...
    @classmethod
    def from_uuid(cls, uu: uuid.UUID) -&gt; ULID: ...
    @classmethod
    def from_bytes(cls, b: builtins.bytes) -&gt; ULID: ...
    @classmethod
    def from_hex(cls, hexstr: str) -&gt; ULID: ...
    @classmethod
    def from_str(cls, s: str) -&gt; ULID: ...
    @classmethod
    def from_string(cls, s: str) -&gt; ULID:
        """Alias for `from_str` to match python-ulid lib"""

    @classmethod
    def from_int(cls, i: int) -&gt; ULID: ...
    @classmethod
    def parse(cls, value: t.Any) -&gt; ULID: ...

    # -------
    # DUNDERS
    # -------
    def __int__(self) -&gt; int: ...
    def __bytes__(self) -&gt; builtins.bytes: ...
    def __lt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __le__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __ge__(self, other: int | str | ULID | builtins.bytes) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...

    # --------
    # PYDANTIC
    # --------
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source: t.Any, handler: GetCoreSchemaHandler
    ) -&gt; CoreSchema: ...
</code></pre>
<h2 id="ry.ryo3.uuid"><code>ry.ryo3.uuid</code></h2>

<pre><code class="language-python">"""ryo3-uuid types

based on typeshed types for python's builtin uuid module

REF: https://github.com/python/typeshed/blob/main/stdlib/uuid.pyi
"""

import builtins
import typing as t
import uuid as pyuuid
from enum import Enum

from ry._types import Buffer
from ry.protocols import FromStr

_FieldsType: t.TypeAlias = tuple[int, int, int, int, int, int]


class SafeUUID(Enum):
    safe = 0
    unsafe = -1
    unknown = None


@t.final
class UUID(FromStr):
    NAMESPACE_DNS: UUID
    NAMESPACE_URL: UUID
    NAMESPACE_OID: UUID
    NAMESPACE_X500: UUID

    def __init__(
        self,
        hex: str | None = None,  # noqa: A002
        bytes: builtins.bytes | None = None,  # noqa: A002
        bytes_le: builtins.bytes | None = None,
        fields: _FieldsType | None = None,
        int: builtins.int | None = None,  # noqa: A002
        version: builtins.int | None = None,
        *,
        is_safe: SafeUUID = ...,
    ) -&gt; None: ...
    @property
    def is_nil(self) -&gt; bool: ...
    @property
    def bytes(self) -&gt; builtins.bytes: ...
    @property
    def bytes_le(self) -&gt; builtins.bytes: ...
    @property
    def clock_seq(self) -&gt; builtins.int: ...
    @property
    def clock_seq_hi_variant(self) -&gt; builtins.int: ...
    @property
    def clock_seq_low(self) -&gt; builtins.int: ...
    @property
    def fields(self) -&gt; _FieldsType: ...
    @property
    def hex(self) -&gt; str: ...
    @property
    def int(self) -&gt; builtins.int: ...
    @property
    def node(self) -&gt; builtins.int: ...
    @property
    def time(self) -&gt; builtins.int: ...
    @property
    def time_hi_version(self) -&gt; builtins.int: ...
    @property
    def time_low(self) -&gt; builtins.int: ...
    @property
    def time_mid(self) -&gt; builtins.int: ...
    @property
    def urn(self) -&gt; str: ...
    @property
    def variant(self) -&gt; str: ...
    @property
    def version(self) -&gt; builtins.int | None: ...
    def to_py(self) -&gt; pyuuid.UUID: ...
    def to_string(self) -&gt; str: ...
    # --- CLASSMETHODS --
    @classmethod
    def from_bytes(cls, b: builtins.bytes) -&gt; t.Self: ...
    @classmethod
    def from_bytes_le(cls, b: builtins.bytes) -&gt; t.Self: ...
    @classmethod
    def from_fields(cls, fields: _FieldsType) -&gt; t.Self: ...
    @classmethod
    def from_hex(cls, hexstr: str) -&gt; t.Self: ...
    @classmethod
    def from_int(cls, i: builtins.int) -&gt; t.Self: ...
    @classmethod
    def from_pyuuid(cls, ob: pyuuid.UUID) -&gt; t.Self: ...
    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...
    # --- DUNDERS ---
    def __bytes__(self) -&gt; builtins.bytes: ...
    def __lt__(self, other: UUID) -&gt; bool: ...
    def __le__(self, other: UUID) -&gt; bool: ...
    def __eq__(self, other: object) -&gt; bool: ...
    def __gt__(self, other: UUID) -&gt; bool: ...
    def __ge__(self, other: UUID) -&gt; bool: ...
    def __hash__(self) -&gt; builtins.int: ...
    def __int__(self) -&gt; builtins.int: ...


def getnode() -&gt; builtins.int: ...
def uuid1(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid3(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid4() -&gt; UUID: ...
def uuid5(namespace: UUID, name: str | builtins.bytes) -&gt; UUID: ...
def uuid6(node: int | None = None, clock_seq: int | None = None) -&gt; UUID: ...
def uuid7(timestamp: int | None = None) -&gt; UUID: ...
@t.overload
def uuid8(*, buf: Buffer) -&gt; UUID: ...  # 16 bytes buffer
@t.overload
def uuid8(
    a: int | None = None,
    b: int | None = None,
    c: int | None = None,
    *,
    buf: None = None,
) -&gt; UUID: ...


NAMESPACE_DNS: UUID
NAMESPACE_URL: UUID
NAMESPACE_OID: UUID
NAMESPACE_X500: UUID
RESERVED_NCS: str
RFC_4122: str
RESERVED_MICROSOFT: str
RESERVED_FUTURE: str
</code></pre>
<h2 id="ry.ryo3.xxhash"><code>ry.ryo3.xxhash</code></h2>

<pre><code class="language-python">import typing as t

from ry._types import Buffer


@t.final
class xxh32:  # noqa: N801
    name: t.Literal["xxh32"]
    digest_size: t.Literal[4]
    block_size: t.Literal[16]

    def __init__(self, data: Buffer = ..., *, seed: int = 0) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...
    @staticmethod
    def oneshot(data: Buffer, *, seed: int = 0) -&gt; int: ...


@t.final
class xxh64:  # noqa: N801
    name: t.Literal["xxh64"]
    digest_size: t.Literal[8]
    block_size: t.Literal[32]

    def __init__(
        self, data: Buffer | None = None, *, seed: int = 0
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @property
    def seed(self) -&gt; int: ...
    @staticmethod
    def oneshot(data: Buffer, *, seed: int = 0) -&gt; int: ...


@t.final
class xxh3_64:  # noqa: N801
    name: t.Literal["xxh3_64"]
    digest_size: t.Literal[8]
    block_size: t.Literal[32]

    def __init__(
        self,
        data: Buffer = ...,
        *,
        seed: int = 0,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, seed: int = 0, secret: bytes | None = None
    ) -&gt; int: ...


@t.final
class xxh3_128:  # noqa: N801
    name: t.Literal["xxh3_128"]
    digest_size: t.Literal[16]
    block_size: t.Literal[64]

    def __init__(
        self,
        data: Buffer = ...,
        *,
        seed: int | None = ...,
        secret: bytes | None = ...,
    ) -&gt; None: ...
    def update(self, data: Buffer) -&gt; None: ...
    def digest(self) -&gt; bytes: ...
    def hexdigest(self) -&gt; str: ...
    def intdigest(self) -&gt; int: ...
    @property
    def seed(self) -&gt; int: ...
    def copy(self) -&gt; t.Self: ...
    def reset(self, *, seed: int | None = None) -&gt; None: ...
    @staticmethod
    def oneshot(
        data: Buffer, *, seed: int = 0, secret: bytes | None = None
    ) -&gt; int: ...


xxh128 = xxh3_128

# -----------------------------------------------------------------------------
# ONE-SHOT FUNCTIONS
# -----------------------------------------------------------------------------


# xxh32
def xxh32_digest(data: Buffer, *, seed: int = 0) -&gt; bytes: ...
def xxh32_hexdigest(data: Buffer, *, seed: int = 0) -&gt; str: ...
def xxh32_intdigest(data: Buffer, *, seed: int = 0) -&gt; int: ...


# xxh64
def xxh64_digest(data: Buffer, *, seed: int = 0) -&gt; bytes: ...
def xxh64_hexdigest(data: Buffer, *, seed: int = 0) -&gt; str: ...
def xxh64_intdigest(data: Buffer, *, seed: int = 0) -&gt; int: ...


# xxh3
def xxh3_64_digest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; bytes: ...
def xxh3_64_intdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; int: ...
def xxh3_64_hexdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; str: ...


# xxh128
def xxh3_128_digest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; bytes: ...
def xxh3_128_intdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; int: ...
def xxh3_128_hexdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; str: ...


# xxh128
def xxh128_digest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; bytes: ...
def xxh128_hexdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; str: ...
def xxh128_intdigest(
    data: Buffer, *, seed: int = 0, secret: bytes | None = None
) -&gt; int: ...
</code></pre>
<h2 id="ry.ryo3.zstd"><code>ry.ryo3.zstd</code></h2>

<pre><code class="language-python">"""ryo3-zstd types"""

from typing import Literal, TypeAlias

from ry import Bytes
from ry._types import Buffer

__zstd_version__: str  # zstd version string ("1.5.7" as of 2025-03-14)
BLOCKSIZELOG_MAX: int
BLOCKSIZE_MAX: int
CLEVEL_DEFAULT: int  # default=3 (as of 2025-03-14)
CONTENTSIZE_ERROR: int
CONTENTSIZE_UNKNOWN: int
MAGICNUMBER: int
MAGIC_DICTIONARY: int
MAGIC_SKIPPABLE_MASK: int
MAGIC_SKIPPABLE_START: int
VERSION_MAJOR: int
VERSION_MINOR: int
VERSION_NUMBER: int
VERSION_RELEASE: int

_Quality: TypeAlias = Literal[
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
]


# __COMPRESSION__
def compress(data: Buffer, level: _Quality = 3) -&gt; Bytes: ...
def encode(data: Buffer, level: _Quality = 3) -&gt; Bytes: ...
def zstd(data: Buffer, level: _Quality = 3) -&gt; Bytes: ...


# __DECOMPRESSION__
def decode(data: Buffer) -&gt; Bytes: ...
def decompress(data: Buffer) -&gt; Bytes: ...
def unzstd(data: Buffer) -&gt; Bytes: ...


# __MAGIC__
def is_zstd(data: Buffer) -&gt; bool: ...
</code></pre>
<h2 id="ry._types"><code>ry._types</code></h2>

<pre><code class="language-python">"""ry-types"""

from __future__ import annotations

import sys
from os import PathLike
from typing import TYPE_CHECKING, Literal, TypeAlias

if TYPE_CHECKING:
    import datetime as pydt


if sys.version_info &gt;= (3, 12):  # pragma: no cover
    from collections.abc import Buffer
    from typing import TypedDict, Unpack
else:  # pragma: no cover
    from typing_extensions import Buffer, TypedDict, Unpack

__all__ = (
    "Buffer",
    "DateDifferenceTypedDict",
    "DateTimeDifferenceTypedDict",
    "DateTimeRoundTypedDict",
    "DateTimeTypedDict",
    "DateTimeTypedDict",
    "DateTypedDict",
    "DateTypedDict",
    "DurationDict",
    "FsPathLike",
    "ISOWeekDateTypedDict",
    "JiffRoundMode",
    "JiffUnit",
    "MetadataDict",
    "OffsetInfoDict",
    "OffsetRoundTypedDict",
    "SignedDurationRoundTypedDict",
    "TimeDifferenceTypedDict",
    "TimeRoundTypedDict",
    "TimeSpanTypedDict",
    "TimeTypedDict",
    "TimestampDifferenceTypedDict",
    "TimestampRoundTypedDict",
    "TimestampTypedDict",
    "Unpack",
    "ZonedDateTimeDifferenceTypedDict",
    "ZonedDateTimeRoundTypedDict",
)

FsPathLike = str | PathLike[str]


# =============================================================================
# STD
# =============================================================================
class DurationDict(TypedDict):
    secs: int
    nanos: int


class MetadataDict(TypedDict):
    is_dir: bool
    is_file: bool
    is_symlink: bool
    len: int
    readonly: bool
    file_type: Literal["file", "directory", "symlink"]
    accessed: pydt.datetime
    created: pydt.datetime
    modified: pydt.datetime


# =============================================================================
# JIFF
# =============================================================================
JiffUnit: TypeAlias = Literal[
    "year",  # 9
    "month",  # 8
    "day",  # 6
    "hour",  # 5
    "minute",  # 4
    "second",  # 3
    "millisecond",  # 2
    "microsecond",  # 1
    "nanosecond",  # 0
]
JiffRoundMode: TypeAlias = Literal[
    "ceil",
    "floor",
    "expand",
    "trunc",
    "half-ceil",
    "half-floor",
    "half-expand",
    "half-trunc",
    "half-even",
]


class DateTypedDict(TypedDict):
    year: int
    month: int
    day: int


class TimeTypedDict(TypedDict):
    hour: int
    minute: int
    second: int
    nanosecond: int


class DateTimeTypedDict(TypedDict):
    year: int
    month: int
    day: int
    hour: int
    minute: int
    second: int
    nanosecond: int


class ZonedDateTimeTypedDict(TypedDict):
    year: int
    month: int
    day: int
    hour: int
    minute: int
    second: int
    nanosecond: int
    tz: str


class TimestampTypedDict:
    second: int
    nanosecond: int


class SignedDurationTypedDict(TypedDict):
    secs: int
    nanos: int


class TimeSpanTypedDict(TypedDict):
    """TimeSpan TypedDict

    Examples:
        &gt;&gt;&gt; import ry
        &gt;&gt;&gt; ts = ry.timespan(years=1, months=2, weeks=3)
        &gt;&gt;&gt; ts.to_dict()
        {'years': 1, 'months': 2, 'weeks': 3, 'days': 0, 'hours': 0, 'minutes': 0, 'seconds': 0, 'milliseconds': 0, 'microseconds': 0, 'nanoseconds': 0}

    """

    years: int
    months: int
    weeks: int
    days: int
    hours: int
    minutes: int
    seconds: int
    milliseconds: int
    microseconds: int
    nanoseconds: int


class TimeZoneDict(TypedDict):
    tz: str


class OffsetTypedDict(TypedDict):
    seconds: int
    fmt: str


class OffsetInfoDict(TypedDict):
    offset: OffsetTypedDict
    dst: bool
    abbreviation: str


class ISOWeekDateTypedDict(TypedDict):
    year: int
    week: int
    weekday: int


# -----------------------------------------------------------------------------
# JIFF ROUND
# -----------------------------------------------------------------------------
class DateTimeRoundTypedDict(TypedDict):
    smallest: Literal[
        "day",
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class SignedDurationRoundTypedDict(TypedDict):
    smallest: Literal[
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class TimeRoundTypedDict(TypedDict):
    smallest: Literal[
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class TimestampRoundTypedDict(TypedDict):
    smallest: Literal[
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class ZonedDateTimeRoundTypedDict(TypedDict):
    smallest: Literal[
        "day",
        "hour",
        "minute",
        "second",
        "millisecond",
        "microsecond",
        "nanosecond",
    ]
    mode: JiffRoundMode
    increment: int


class OffsetRoundTypedDict(TypedDict):
    smallest: Literal[
        "second",
        "minute",
        "hour",
    ]
    mode: JiffRoundMode
    increment: int


# -----------------------------------------------------------------------------
# JIFF DIFFERENCE
# -----------------------------------------------------------------------------
class _DifferenceTypedDict(TypedDict):
    mode: JiffRoundMode
    increment: int


DateDifferenceUnit: TypeAlias = Literal["month", "year", "day"]


class DateDifferenceTypedDict(_DifferenceTypedDict):
    smallest: DateDifferenceUnit
    largest: DateDifferenceUnit | None


class DateTimeDifferenceTypedDict(_DifferenceTypedDict):
    smallest: JiffUnit
    largest: JiffUnit | None


TimeDifferenceUnit: TypeAlias = Literal[
    "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"
]


class TimeDifferenceTypedDict(_DifferenceTypedDict):
    smallest: TimeDifferenceUnit
    largest: TimeDifferenceUnit | None


class ZonedDateTimeDifferenceTypedDict(_DifferenceTypedDict):
    smallest: JiffUnit
    largest: JiffUnit | None


TimeStampDifferenceUnit: TypeAlias = Literal[
    "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"
]


class TimestampDifferenceTypedDict(_DifferenceTypedDict):
    smallest: TimeStampDifferenceUnit
    largest: TimeStampDifferenceUnit | None


# =============================================================================
# OPEN MODES (CANONICAL)
# =============================================================================
# ry accepts the non-canonical modes, but they are mapped to the canonical ones]

OpenTextModeUpdating: TypeAlias = Literal[
    "a+", "at+", "r+", "rt+", "w+", "wt+", "x+", "xt+"
]
OpenTextModeWriting: TypeAlias = Literal["a", "at", "w", "wt", "x", "xt"]
OpenTextModeReading: TypeAlias = Literal["r", "rt"]
OpenTextMode: TypeAlias = Literal[
    "a",
    "a+",
    "at",
    "at+",
    "r",
    "r+",
    "rt",
    "rt+",
    "w",
    "w+",
    "wt",
    "wt+",
    "x",
    "x+",
    "xt",
    "xt+",
]
OpenBinaryModeUpdating: TypeAlias = Literal["ab+", "rb+", "wb+", "xb+"]
OpenBinaryModeWriting: TypeAlias = Literal["ab", "wb", "xb"]
OpenBinaryModeReading: TypeAlias = Literal["rb"]
OpenBinaryMode: TypeAlias = Literal[
    "ab", "ab+", "rb", "rb+", "wb", "wb+", "xb", "xb+"
]
OpenMode: TypeAlias = Literal[
    "a",
    "a+",
    "ab",
    "ab+",
    "at",
    "at+",
    "r",
    "r+",
    "rb",
    "rb+",
    "rt",
    "rt+",
    "w",
    "w+",
    "wb",
    "wb+",
    "wt",
    "wt+",
    "x",
    "x+",
    "xb",
    "xb+",
    "xt",
    "xt+",
]
</code></pre>
<h2 id="ry.dirs"><code>ry.dirs</code></h2>

<pre><code class="language-python">from ry.ryo3.dirs import audio as audio
from ry.ryo3.dirs import audio_dir as audio_dir
from ry.ryo3.dirs import cache as cache
from ry.ryo3.dirs import cache_dir as cache_dir
from ry.ryo3.dirs import config as config
from ry.ryo3.dirs import config_dir as config_dir
from ry.ryo3.dirs import config_local as config_local
from ry.ryo3.dirs import config_local_dir as config_local_dir
from ry.ryo3.dirs import data as data
from ry.ryo3.dirs import data_dir as data_dir
from ry.ryo3.dirs import data_local as data_local
from ry.ryo3.dirs import data_local_dir as data_local_dir
from ry.ryo3.dirs import desktop as desktop
from ry.ryo3.dirs import desktop_dir as desktop_dir
from ry.ryo3.dirs import document as document
from ry.ryo3.dirs import document_dir as document_dir
from ry.ryo3.dirs import download as download
from ry.ryo3.dirs import download_dir as download_dir
from ry.ryo3.dirs import executable as executable
from ry.ryo3.dirs import executable_dir as executable_dir
from ry.ryo3.dirs import font as font
from ry.ryo3.dirs import font_dir as font_dir
from ry.ryo3.dirs import home as home
from ry.ryo3.dirs import home_dir as home_dir
from ry.ryo3.dirs import picture as picture
from ry.ryo3.dirs import picture_dir as picture_dir
from ry.ryo3.dirs import preference as preference
from ry.ryo3.dirs import preference_dir as preference_dir
from ry.ryo3.dirs import public as public
from ry.ryo3.dirs import public_dir as public_dir
from ry.ryo3.dirs import runtime as runtime
from ry.ryo3.dirs import runtime_dir as runtime_dir
from ry.ryo3.dirs import state as state
from ry.ryo3.dirs import state_dir as state_dir
from ry.ryo3.dirs import template as template
from ry.ryo3.dirs import template_dir as template_dir
from ry.ryo3.dirs import video as video
from ry.ryo3.dirs import video_dir as video_dir

__all__ = (
    "audio",
    "audio_dir",
    "cache",
    "cache_dir",
    "config",
    "config_dir",
    "config_local",
    "config_local_dir",
    "data",
    "data_dir",
    "data_local",
    "data_local_dir",
    "desktop",
    "desktop_dir",
    "document",
    "document_dir",
    "download",
    "download_dir",
    "executable",
    "executable_dir",
    "font",
    "font_dir",
    "home",
    "home_dir",
    "picture",
    "picture_dir",
    "preference",
    "preference_dir",
    "public",
    "public_dir",
    "runtime",
    "runtime_dir",
    "state",
    "state_dir",
    "template",
    "template_dir",
    "video",
    "video_dir",
)
</code></pre>
<h2 id="ry.JSON"><code>ry.JSON</code></h2>

<pre><code class="language-python">"""ry.JSON"""

from ry.ryo3.JSON import cache_clear as cache_clear
from ry.ryo3.JSON import cache_usage as cache_usage
from ry.ryo3.JSON import dumps as dumps
from ry.ryo3.JSON import fmt as fmt
from ry.ryo3.JSON import loads as loads
from ry.ryo3.JSON import minify as minify
from ry.ryo3.JSON import parse as parse
from ry.ryo3.JSON import stringify as stringify

__all__ = (
    "cache_clear",
    "cache_usage",
    "dumps",
    "fmt",
    "loads",
    "minify",
    "parse",
    "stringify",
)
</code></pre>
<h2 id="ry.protocols"><code>ry.protocols</code></h2>

<pre><code class="language-python">import datetime as pydt
import typing as t

__all__ = (
    "FromStr",
    "NoInit",
    "RyIterator",
    "Strftime",
    "ToPy",
    "ToPyDate",
    "ToPyDateTime",
    "ToPyTime",
    "ToPyTimeDelta",
    "ToPyTzInfo",
    "ToString",
    "_Parse",
)

_T = t.TypeVar("_T")
_T_co = t.TypeVar("_T_co", covariant=True)


class ToPy(t.Protocol[_T_co]):
    """Objects that can be converted to a python stdlib type (`_T_co`) via `obj.to_py()`."""

    def to_py(self) -&gt; _T_co: ...


class NoInit(t.Protocol):
    """Protocol for types that cannot be instantiated directly."""

    def __init__(self) -&gt; t.NoReturn: ...


# =============================================================================
# TO/FROM STRING
# =============================================================================
class FromStr(t.Protocol):
    """Protocol for types that have a `.from_str()` class method."""

    @classmethod
    def from_str(cls, s: str) -&gt; t.Self: ...


class _Parse(t.Protocol):
    """Protocol for types that have a `.parse()` class method."""

    @classmethod
    def parse(cls, s: str | bytes) -&gt; t.Self: ...


class ToString(t.Protocol):
    """Protocol for types that have a `.to_string()` method."""

    def to_string(self) -&gt; str: ...


# =============================================================================
# ITERABLE
# =============================================================================
class RyIterator(t.Protocol[_T]):
    def __iter__(self) -&gt; t.Self: ...
    def __next__(self) -&gt; _T: ...
    def collect(self) -&gt; list[_T]: ...
    def take(self, n: int = 1) -&gt; list[_T]: ...


class RyAsyncIterator(t.Protocol[_T]):
    def __aiter__(self) -&gt; t.Self: ...
    async def __anext__(self) -&gt; _T: ...
    async def collect(self) -&gt; list[_T]: ...
    async def take(self, n: int = 1) -&gt; list[_T]: ...


# =============================================================================
# DATETIME
# =============================================================================


class Strftime(t.Protocol):
    """Protocol for types that have a `.strftime()` method."""

    def strftime(self, fmt: str) -&gt; str: ...


class ToPyDate(t.Protocol):
    """Objects that can be converted to a Python `datetime.date`."""

    def to_pydate(self) -&gt; pydt.date: ...


class ToPyTime(t.Protocol):
    """Objects that can be converted to a Python `datetime.time`."""

    def to_pytime(self) -&gt; pydt.time: ...


class ToPyDateTime(t.Protocol):
    """Objects that can be converted to a Python `datetime.datetime`."""

    def to_pydatetime(self) -&gt; pydt.datetime: ...


class ToPyTimeDelta(t.Protocol):
    """Objects that can be converted to a Python `datetime.timedelta`."""

    def to_pytimedelta(self) -&gt; pydt.timedelta: ...


class ToPyTzInfo(t.Protocol):
    """Objects that can be converted to a Python `datetime.tzinfo`."""

    def to_pytzinfo(self) -&gt; pydt.tzinfo: ...
</code></pre>
<h2 id="ry.ulid"><code>ry.ulid</code></h2>

<pre><code class="language-python">from ry.ryo3.ulid import ULID

__all__ = ("ULID",)
</code></pre>
<h2 id="ry.uuid"><code>ry.uuid</code></h2>

<pre><code class="language-python">from ry.ryo3.uuid import (
    NAMESPACE_DNS,
    NAMESPACE_OID,
    NAMESPACE_URL,
    NAMESPACE_X500,
    RESERVED_FUTURE,
    RESERVED_MICROSOFT,
    RESERVED_NCS,
    RFC_4122,
    UUID,
    getnode,
    uuid1,
    uuid3,
    uuid4,
    uuid5,
    uuid6,
    uuid7,
    uuid8,
)

__all__ = (
    "NAMESPACE_DNS",
    "NAMESPACE_OID",
    "NAMESPACE_URL",
    "NAMESPACE_X500",
    "RESERVED_FUTURE",
    "RESERVED_MICROSOFT",
    "RESERVED_NCS",
    "RFC_4122",
    "UUID",
    "getnode",
    "uuid1",
    "uuid3",
    "uuid4",
    "uuid5",
    "uuid6",
    "uuid7",
    "uuid8",
)
</code></pre>
<h2 id="ry.xxhash"><code>ry.xxhash</code></h2>

<pre><code class="language-python">from ry.ryo3.xxhash import xxh3_64 as xxh3_64
from ry.ryo3.xxhash import xxh3_64_digest as xxh3_64_digest
from ry.ryo3.xxhash import xxh3_64_hexdigest as xxh3_64_hexdigest
from ry.ryo3.xxhash import xxh3_64_intdigest as xxh3_64_intdigest
from ry.ryo3.xxhash import xxh3_128 as xxh3_128
from ry.ryo3.xxhash import xxh3_128_digest as xxh3_128_digest
from ry.ryo3.xxhash import xxh3_128_hexdigest as xxh3_128_hexdigest
from ry.ryo3.xxhash import xxh3_128_intdigest as xxh3_128_intdigest
from ry.ryo3.xxhash import xxh32 as xxh32
from ry.ryo3.xxhash import xxh32_digest as xxh32_digest
from ry.ryo3.xxhash import xxh32_hexdigest as xxh32_hexdigest
from ry.ryo3.xxhash import xxh32_intdigest as xxh32_intdigest
from ry.ryo3.xxhash import xxh64 as xxh64
from ry.ryo3.xxhash import xxh64_digest as xxh64_digest
from ry.ryo3.xxhash import xxh64_hexdigest as xxh64_hexdigest
from ry.ryo3.xxhash import xxh64_intdigest as xxh64_intdigest
from ry.ryo3.xxhash import xxh128 as xxh128
from ry.ryo3.xxhash import xxh128_digest as xxh128_digest
from ry.ryo3.xxhash import xxh128_hexdigest as xxh128_hexdigest
from ry.ryo3.xxhash import xxh128_intdigest as xxh128_intdigest

__all__ = (
    "xxh3_64",
    "xxh3_64_digest",
    "xxh3_64_hexdigest",
    "xxh3_64_intdigest",
    "xxh3_128",
    "xxh3_128_digest",
    "xxh3_128_hexdigest",
    "xxh3_128_intdigest",
    "xxh32",
    "xxh32_digest",
    "xxh32_hexdigest",
    "xxh32_intdigest",
    "xxh64",
    "xxh64_digest",
    "xxh64_hexdigest",
    "xxh64_intdigest",
    "xxh128",
    "xxh128_digest",
    "xxh128_hexdigest",
    "xxh128_intdigest",
)
</code></pre>
<h2 id="ry.zstd"><code>ry.zstd</code></h2>

<pre><code class="language-python">from ry.ryo3.zstd import BLOCKSIZE_MAX as BLOCKSIZE_MAX
from ry.ryo3.zstd import BLOCKSIZELOG_MAX as BLOCKSIZELOG_MAX
from ry.ryo3.zstd import CLEVEL_DEFAULT as CLEVEL_DEFAULT
from ry.ryo3.zstd import CONTENTSIZE_ERROR as CONTENTSIZE_ERROR
from ry.ryo3.zstd import CONTENTSIZE_UNKNOWN as CONTENTSIZE_UNKNOWN
from ry.ryo3.zstd import MAGIC_DICTIONARY as MAGIC_DICTIONARY
from ry.ryo3.zstd import MAGIC_SKIPPABLE_MASK as MAGIC_SKIPPABLE_MASK
from ry.ryo3.zstd import MAGIC_SKIPPABLE_START as MAGIC_SKIPPABLE_START
from ry.ryo3.zstd import MAGICNUMBER as MAGICNUMBER
from ry.ryo3.zstd import VERSION_MAJOR as VERSION_MAJOR
from ry.ryo3.zstd import VERSION_MINOR as VERSION_MINOR
from ry.ryo3.zstd import VERSION_NUMBER as VERSION_NUMBER
from ry.ryo3.zstd import VERSION_RELEASE as VERSION_RELEASE
from ry.ryo3.zstd import __zstd_version__ as __zstd_version__
from ry.ryo3.zstd import compress as compress
from ry.ryo3.zstd import decode as decode
from ry.ryo3.zstd import decompress as decompress
from ry.ryo3.zstd import is_zstd as is_zstd
from ry.ryo3.zstd import unzstd as unzstd

__all__ = (
    "BLOCKSIZELOG_MAX",
    "BLOCKSIZE_MAX",
    "CLEVEL_DEFAULT",
    "CONTENTSIZE_ERROR",
    "CONTENTSIZE_UNKNOWN",
    "MAGICNUMBER",
    "MAGIC_DICTIONARY",
    "MAGIC_SKIPPABLE_MASK",
    "MAGIC_SKIPPABLE_START",
    "VERSION_MAJOR",
    "VERSION_MINOR",
    "VERSION_NUMBER",
    "VERSION_RELEASE",
    "__zstd_version__",
    "compress",
    "decode",
    "decompress",
    "is_zstd",
    "unzstd",
)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="examples.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="dep-graph.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="examples.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="dep-graph.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
